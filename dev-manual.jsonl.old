{"text": "\n\nSpeeding Up a Build\n\n\nSpeeding Up a Build\n*******************\n\nBuild time can be an issue. By default, the build system uses simple\ncontrols to try and maximize build efficiency. In general, the default\nsettings for all the following variables result in the most efficient\nbuild times when dealing with single socket systems (i.e. a single CPU).\nIf you have multiple CPUs, you might try increasing the default values\nto gain more speed. See the descriptions in the glossary for each\nvariable for more information:\n\n-  :term:`BB_NUMBER_THREADS`:\n   The maximum number of threads BitBake simultaneously executes.\n\n-  :term:`BB_NUMBER_PARSE_THREADS`:\n   The number of threads BitBake uses during parsing.\n\n-  :term:`PARALLEL_MAKE`: Extra\n   options passed to the ``make`` command during the\n   :ref:`ref-tasks-compile` task in\n   order to specify parallel compilation on the local build host.\n\n-  :term:`PARALLEL_MAKEINST`:\n   Extra options passed to the ``make`` command during the\n   :ref:`ref-tasks-install` task in\n   order to specify parallel installation on the local build host.\n\nAs mentioned, these variables all scale to the number of processor cores\navailable on the build system. For single socket systems, this\nauto-scaling ensures that the build system fundamentally takes advantage\nof potential parallel operations during the build based on the build\nmachine's capabilities.\n\nFollowing are additional factors that can affect build speed:\n\n-  File system type: The file system type that the build is being\n   performed on can also influence performance. Using ``ext4`` is\n   recommended as compared to ``ext2`` and ``ext3`` due to ``ext4``\n   improved features such as extents.\n\n-  Disabling the updating of access time using ``noatime``: The\n   ``noatime`` mount option prevents the build system from updating file\n   and directory access times.\n\n-  Setting a longer commit: Using the \"commit=\" mount option increases\n   the interval in seconds between disk cache writes. Changing this\n   interval from the five second default to something longer increases\n   the risk of data loss but decreases the need to write to the disk,\n   thus increasing the build performance.\n\n-  Choosing the packaging backend: Of the available packaging backends,\n   IPK is the fastest. Additionally, selecting a singular packaging\n   backend also helps.\n\n-  Using ``tmpfs`` for :term:`TMPDIR`\n   as a temporary file system: While this can help speed up the build,\n   the benefits are limited due to the compiler using ``-pipe``. The\n   build system goes to some lengths to avoid ``sync()`` calls into the\n   file system on the principle that if there was a significant failure,\n   the :term:`Build Directory` contents could easily be rebuilt.\n\n-  Inheriting the :ref:`ref-classes-rm-work` class:\n   Inheriting this class has shown to speed up builds due to\n   significantly lower amounts of data stored in the data cache as well\n   as on disk. Inheriting this class also makes cleanup of\n   :term:`TMPDIR` faster, at the\n   expense of being easily able to dive into the source code. File\n   system maintainers have recommended that the fastest way to clean up\n   large numbers of files is to reformat partitions rather than delete\n   files due to the linear nature of partitions. This, of course,\n   assumes you structure the disk partitions and file systems in a way\n   that this is practical.\n\nAside from the previous list, you should keep some trade offs in mind\nthat can help you speed up the build:\n\n-  Remove items from\n   :term:`DISTRO_FEATURES`\n   that you might not need.\n\n-  Exclude debug symbols and other debug information: If you do not need\n   these symbols and other debug information, disabling the ``*-dbg``\n   package generation can speed up the build. You can disable this\n   generation by setting the\n   :term:`INHIBIT_PACKAGE_DEBUG_SPLIT`\n   variable to \"1\".\n\n-  Disable static library generation for recipes derived from\n   ``autoconf`` or ``libtool``: Following is an example showing how to\n   disable static libraries and still provide an override to handle\n   exceptions::\n\n      STATICLIBCONF = \"--disable-static\"\n      STATICLIBCONF:sqlite3-native = \"\"\n      EXTRA_OECONF += \"${STATICLIBCONF}\"\n\n   .. note::\n\n"}
{"text": "\n\nSpeeding Up a Build\n      -  Some recipes need static libraries in order to work correctly\n         (e.g. ``pseudo-native`` needs ``sqlite3-native``). Overrides,\n         as in the previous example, account for these kinds of\n         exceptions.\n\n      -  Some packages have packaging code that assumes the presence of\n         the static libraries. If so, you might need to exclude them as\n         well.\n\n"}
{"text": "\n\nUpgrading Recipes\n\n\nUpgrading Recipes\n*****************\n\nOver time, upstream developers publish new versions for software built\nby layer recipes. It is recommended to keep recipes up-to-date with\nupstream version releases.\n\nWhile there are several methods to upgrade a recipe, you might\nconsider checking on the upgrade status of a recipe first. You can do so\nusing the ``devtool check-upgrade-status`` command. See the\n\":ref:`devtool-checking-on-the-upgrade-status-of-a-recipe`\"\nsection in the Yocto Project Reference Manual for more information.\n\nThe remainder of this section describes three ways you can upgrade a\nrecipe. You can use the Automated Upgrade Helper (AUH) to set up\nautomatic version upgrades. Alternatively, you can use\n``devtool upgrade`` to set up semi-automatic version upgrades. Finally,\nyou can manually upgrade a recipe by editing the recipe itself.\n\nUsing the Auto Upgrade Helper (AUH)\n===================================\n\nThe AUH utility works in conjunction with the OpenEmbedded build system\nin order to automatically generate upgrades for recipes based on new\nversions being published upstream. Use AUH when you want to create a\nservice that performs the upgrades automatically and optionally sends\nyou an email with the results.\n\nAUH allows you to update several recipes with a single use. You can also\noptionally perform build and integration tests using images with the\nresults saved to your hard drive and emails of results optionally sent\nto recipe maintainers. Finally, AUH creates Git commits with appropriate\ncommit messages in the layer's tree for the changes made to recipes.\n\n.. note::\n\n   In some conditions, you should not use AUH to upgrade recipes\n   and should instead use either ``devtool upgrade`` or upgrade your\n   recipes manually:\n\n   -  When AUH cannot complete the upgrade sequence. This situation\n      usually results because custom patches carried by the recipe\n      cannot be automatically rebased to the new version. In this case,\n      ``devtool upgrade`` allows you to manually resolve conflicts.\n\n   -  When for any reason you want fuller control over the upgrade\n      process. For example, when you want special arrangements for\n      testing.\n\nThe following steps describe how to set up the AUH utility:\n\n#. *Be Sure the Development Host is Set Up:* You need to be sure that\n   your development host is set up to use the Yocto Project. For\n   information on how to set up your host, see the\n   \":ref:`dev-manual/start:Preparing the Build Host`\" section.\n\n#. *Make Sure Git is Configured:* The AUH utility requires Git to be\n   configured because AUH uses Git to save upgrades. Thus, you must have\n   Git user and email configured. The following command shows your\n   configurations::\n\n      $ git config --list\n\n   If you do not have the user and\n   email configured, you can use the following commands to do so::\n\n      $ git config --global user.name some_name\n      $ git config --global user.email username@domain.com\n\n#. *Clone the AUH Repository:* To use AUH, you must clone the repository\n   onto your development host. The following command uses Git to create\n   a local copy of the repository on your system::\n\n      $ git clone git://git.yoctoproject.org/auto-upgrade-helper\n      Cloning into 'auto-upgrade-helper'... remote: Counting objects: 768, done.\n      remote: Compressing objects: 100% (300/300), done.\n      remote: Total 768 (delta 499), reused 703 (delta 434)\n      Receiving objects: 100% (768/768), 191.47 KiB | 98.00 KiB/s, done.\n      Resolving deltas: 100% (499/499), done.\n      Checking connectivity... done.\n\n   AUH is not part of the :term:`OpenEmbedded-Core (OE-Core)` or\n   :term:`Poky` repositories.\n\n#. *Create a Dedicated Build Directory:* Run the :ref:`structure-core-script`\n   script to create a fresh :term:`Build Directory` that you use exclusively\n   for running the AUH utility::\n\n      $ cd poky\n      $ source oe-init-build-env your_AUH_build_directory\n\n   Re-using an existing :term:`Build Directory` and its configurations is not\n   recommended as existing settings could cause AUH to fail or behave\n   undesirably.\n\n#. *Make Configurations in Your Local Configuration File:* Several\n   settings are needed in the ``local.conf`` file in the build\n   directory you just created for AUH. Make these following\n"}
{"text": "\n\nUpgrading Recipes\n   configurations:\n\n   -  If you want to enable :ref:`Build\n      History <dev-manual/build-quality:maintaining build output quality>`,\n      which is optional, you need the following lines in the\n      ``conf/local.conf`` file::\n\n         INHERIT =+ \"buildhistory\"\n         BUILDHISTORY_COMMIT = \"1\"\n\n      With this configuration and a successful\n      upgrade, a build history \"diff\" file appears in the\n      ``upgrade-helper/work/recipe/buildhistory-diff.txt`` file found in\n      your :term:`Build Directory`.\n\n   -  If you want to enable testing through the :ref:`ref-classes-testimage`\n      class, which is optional, you need to have the following set in\n      your ``conf/local.conf`` file::\n\n         IMAGE_CLASSES += \"testimage\"\n\n      .. note::\n\n         If your distro does not enable by default ptest, which Poky\n         does, you need the following in your ``local.conf`` file::\n\n                 DISTRO_FEATURES:append = \" ptest\"\n\n\n#. *Optionally Start a vncserver:* If you are running in a server\n   without an X11 session, you need to start a vncserver::\n\n      $ vncserver :1\n      $ export DISPLAY=:1\n\n#. *Create and Edit an AUH Configuration File:* You need to have the\n   ``upgrade-helper/upgrade-helper.conf`` configuration file in your\n   :term:`Build Directory`. You can find a sample configuration file in the\n   :yocto_git:`AUH source repository </auto-upgrade-helper/tree/>`.\n\n   Read through the sample file and make configurations as needed. For\n   example, if you enabled build history in your ``local.conf`` as\n   described earlier, you must enable it in ``upgrade-helper.conf``.\n\n   Also, if you are using the default ``maintainers.inc`` file supplied\n   with Poky and located in ``meta-yocto`` and you do not set a\n   \"maintainers_whitelist\" or \"global_maintainer_override\" in the\n   ``upgrade-helper.conf`` configuration, and you specify \"-e all\" on\n   the AUH command-line, the utility automatically sends out emails to\n   all the default maintainers. Please avoid this.\n\nThis next set of examples describes how to use the AUH:\n\n-  *Upgrading a Specific Recipe:* To upgrade a specific recipe, use the\n   following form::\n\n      $ upgrade-helper.py recipe_name\n\n   For example, this command upgrades the ``xmodmap`` recipe::\n\n      $ upgrade-helper.py xmodmap\n\n-  *Upgrading a Specific Recipe to a Particular Version:* To upgrade a\n   specific recipe to a particular version, use the following form::\n\n      $ upgrade-helper.py recipe_name -t version\n\n   For example, this command upgrades the ``xmodmap`` recipe to version 1.2.3::\n\n      $ upgrade-helper.py xmodmap -t 1.2.3\n\n-  *Upgrading all Recipes to the Latest Versions and Suppressing Email\n   Notifications:* To upgrade all recipes to their most recent versions\n   and suppress the email notifications, use the following command::\n\n      $ upgrade-helper.py all\n\n-  *Upgrading all Recipes to the Latest Versions and Send Email\n   Notifications:* To upgrade all recipes to their most recent versions\n   and send email messages to maintainers for each attempted recipe as\n   well as a status email, use the following command::\n\n      $ upgrade-helper.py -e all\n\nOnce you have run the AUH utility, you can find the results in the AUH\n:term:`Build Directory`::\n\n   ${BUILDDIR}/upgrade-helper/timestamp\n\nThe AUH utility\nalso creates recipe update commits from successful upgrade attempts in\nthe layer tree.\n\nYou can easily set up to run the AUH utility on a regular basis by using\na cron job. See the\n:yocto_git:`weeklyjob.sh </auto-upgrade-helper/tree/weeklyjob.sh>`\nfile distributed with the utility for an example.\n\nUsing ``devtool upgrade``\n=========================\n"}
{"text": "\n\nUpgrading Recipes\n\nAs mentioned earlier, an alternative method for upgrading recipes to\nnewer versions is to use\n:doc:`devtool upgrade </ref-manual/devtool-reference>`.\nYou can read about ``devtool upgrade`` in general in the\n\":ref:`sdk-manual/extensible:use \\`\\`devtool upgrade\\`\\` to create a version of the recipe that supports a newer version of the software`\"\nsection in the Yocto Project Application Development and the Extensible\nSoftware Development Kit (eSDK) Manual.\n\nTo see all the command-line options available with ``devtool upgrade``,\nuse the following help command::\n\n   $ devtool upgrade -h\n\nIf you want to find out what version a recipe is currently at upstream\nwithout any attempt to upgrade your local version of the recipe, you can\nuse the following command::\n\n   $ devtool latest-version recipe_name\n\nAs mentioned in the previous section describing AUH, ``devtool upgrade``\nworks in a less-automated manner than AUH. Specifically,\n``devtool upgrade`` only works on a single recipe that you name on the\ncommand line, cannot perform build and integration testing using images,\nand does not automatically generate commits for changes in the source\ntree. Despite all these \"limitations\", ``devtool upgrade`` updates the\nrecipe file to the new upstream version and attempts to rebase custom\npatches contained by the recipe as needed.\n\n.. note::\n\n   AUH uses much of ``devtool upgrade`` behind the scenes making AUH somewhat\n   of a \"wrapper\" application for ``devtool upgrade``.\n\nA typical scenario involves having used Git to clone an upstream\nrepository that you use during build operations. Because you have built the\nrecipe in the past, the layer is likely added to your\nconfiguration already. If for some reason, the layer is not added, you\ncould add it easily using the\n\":ref:`bitbake-layers <bsp-guide/bsp:creating a new bsp layer using the \\`\\`bitbake-layers\\`\\` script>`\"\nscript. For example, suppose you use the ``nano.bb`` recipe from the\n``meta-oe`` layer in the ``meta-openembedded`` repository. For this\nexample, assume that the layer has been cloned into following area::\n\n   /home/scottrif/meta-openembedded\n\nThe following command from your :term:`Build Directory` adds the layer to\nyour build configuration (i.e. ``${BUILDDIR}/conf/bblayers.conf``)::\n\n   $ bitbake-layers add-layer /home/scottrif/meta-openembedded/meta-oe\n   NOTE: Starting bitbake server...\n   Parsing recipes: 100% |##########################################| Time: 0:00:55\n   Parsing of 1431 .bb files complete (0 cached, 1431 parsed). 2040 targets, 56 skipped, 0 masked, 0 errors.\n   Removing 12 recipes from the x86_64 sysroot: 100% |##############| Time: 0:00:00\n   Removing 1 recipes from the x86_64_i586 sysroot: 100% |##########| Time: 0:00:00\n   Removing 5 recipes from the i586 sysroot: 100% |#################| Time: 0:00:00\n   Removing 5 recipes from the qemux86 sysroot: 100% |##############| Time: 0:00:00\n\nFor this example, assume that the ``nano.bb`` recipe that\nis upstream has a 2.9.3 version number. However, the version in the\nlocal repository is 2.7.4. The following command from your build\ndirectory automatically upgrades the recipe for you::\n\n   $ devtool upgrade nano -V 2.9.3\n   NOTE: Starting bitbake server...\n   NOTE: Creating workspace layer in /home/scottrif/poky/build/workspace\n   Parsing recipes: 100% |##########################################| Time: 0:00:46\n   Parsing of 1431 .bb files complete (0 cached, 1431 parsed). 2040 targets, 56 skipped, 0 masked, 0 errors.\n   NOTE: Extracting current version source...\n   NOTE: Resolving any missing task queue dependencies\n          .\n          .\n          .\n   NOTE: Executing SetScene Tasks\n   NOTE: Executing RunQueue Tasks\n   NOTE: Tasks Summary: Attempted 74 tasks of which 72 didn't need to be rerun and all succeeded.\n   Adding changed files: 100% |#####################################| Time: 0:00:00\n   NOTE: Upgraded source extracted to /home/scottrif/poky/build/workspace/sources/nano\n   NOTE: New recipe is /home/scottrif/poky/build/workspace/recipes/nano/nano_2.9.3.bb\n\n.. note::\n\n   Using the ``-V`` option is not necessary. Omitting the version number causes\n   ``devtool upgrade`` to upgrade the recipe to the most recent version.\n\nContinuing with this example, you can use ``devtool build`` to build the\nnewly upgraded recipe::\n\n   $ devtool build nano\n   NOTE: Starting bitbake server...\n   Loading cache: 100% |################################################################################################| Time: 0:00:01\n   Loaded 2040 entries from dependency cache.\n   Parsing recipes: 100% |##############################################################################################| Time: 0:00:00\n   Parsing of 1432 .bb files complete (1431 cached, 1 parsed). 2041 targets, 56 skipped, 0 masked, 0 errors.\n   NOTE: Resolving any missing task queue dependencies\n          .\n          .\n          .\n   NOTE: Executing SetScene Tasks\n   NOTE: Executing RunQueue Tasks\n"}
{"text": "\n\nUpgrading Recipes\n   NOTE: nano: compiling from external source tree /home/scottrif/poky/build/workspace/sources/nano\n   NOTE: Tasks Summary: Attempted 520 tasks of which 304 didn't need to be rerun and all succeeded.\n\nWithin the ``devtool upgrade`` workflow, you can\ndeploy and test your rebuilt software. For this example,\nhowever, running ``devtool finish`` cleans up the workspace once the\nsource in your workspace is clean. This usually means using Git to stage\nand submit commits for the changes generated by the upgrade process.\n\nOnce the tree is clean, you can clean things up in this example with the\nfollowing command from the ``${BUILDDIR}/workspace/sources/nano``\ndirectory::\n\n   $ devtool finish nano meta-oe\n   NOTE: Starting bitbake server...\n   Loading cache: 100% |################################################################################################| Time: 0:00:00\n   Loaded 2040 entries from dependency cache.\n   Parsing recipes: 100% |##############################################################################################| Time: 0:00:01\n   Parsing of 1432 .bb files complete (1431 cached, 1 parsed). 2041 targets, 56 skipped, 0 masked, 0 errors.\n   NOTE: Adding new patch 0001-nano.bb-Stuff-I-changed-when-upgrading-nano.bb.patch\n   NOTE: Updating recipe nano_2.9.3.bb\n   NOTE: Removing file /home/scottrif/meta-openembedded/meta-oe/recipes-support/nano/nano_2.7.4.bb\n   NOTE: Moving recipe file to /home/scottrif/meta-openembedded/meta-oe/recipes-support/nano\n   NOTE: Leaving source tree /home/scottrif/poky/build/workspace/sources/nano as-is; if you no longer need it then please delete it manually\n\n\nUsing the ``devtool finish`` command cleans up the workspace and creates a patch\nfile based on your commits. The tool puts all patch files back into the\nsource directory in a sub-directory named ``nano`` in this case.\n\nManually Upgrading a Recipe\n===========================\n\nIf for some reason you choose not to upgrade recipes using\n:ref:`dev-manual/upgrading-recipes:Using the Auto Upgrade Helper (AUH)` or\nby :ref:`dev-manual/upgrading-recipes:Using \\`\\`devtool upgrade\\`\\``,\nyou can manually edit the recipe files to upgrade the versions.\n\n.. note::\n\n   Manually updating multiple recipes scales poorly and involves many\n   steps. The recommendation to upgrade recipe versions is through AUH\n   or ``devtool upgrade``, both of which automate some steps and provide\n   guidance for others needed for the manual process.\n\nTo manually upgrade recipe versions, follow these general steps:\n\n#. *Change the Version:* Rename the recipe such that the version (i.e.\n   the :term:`PV` part of the recipe name)\n   changes appropriately. If the version is not part of the recipe name,\n   change the value as it is set for :term:`PV` within the recipe itself.\n\n#. *Update* :term:`SRCREV` *if Needed*: If the source code your recipe builds\n   is fetched from Git or some other version control system, update\n   :term:`SRCREV` to point to the\n   commit hash that matches the new version.\n\n#. *Build the Software:* Try to build the recipe using BitBake. Typical\n   build failures include the following:\n\n   -  License statements were updated for the new version. For this\n      case, you need to review any changes to the license and update the\n      values of :term:`LICENSE` and\n      :term:`LIC_FILES_CHKSUM`\n      as needed.\n\n      .. note::\n\n         License changes are often inconsequential. For example, the\n         license text's copyright year might have changed.\n\n   -  Custom patches carried by the older version of the recipe might\n      fail to apply to the new version. For these cases, you need to\n      review the failures. Patches might not be necessary for the new\n      version of the software if the upgraded version has fixed those\n      issues. If a patch is necessary and failing, you need to rebase it\n      into the new version.\n\n#. *Optionally Attempt to Build for Several Architectures:* Once you\n   successfully build the new software for a given architecture, you\n   could test the build for other architectures by changing the\n   :term:`MACHINE` variable and\n   rebuilding the software. This optional step is especially important\n   if the recipe is to be released publicly.\n\n#. *Check the Upstream Change Log or Release Notes:* Checking both these\n   reveals if there are new features that could break\n   backwards-compatibility. If so, you need to take steps to mitigate or\n   eliminate that situation.\n\n#. *Optionally Create a Bootable Image and Test:* If you want, you can\n   test the new software by booting it onto actual hardware.\n\n#. *Create a Commit with the Change in the Layer Repository:* After all\n   builds work and any testing is successful, you can create commits for\n   any changes in the layer holding your upgraded recipe.\n\n"}
{"text": "\n\n======================================\nYocto Project Development Tasks Manual\n======================================\n\n.. toctree::\n   :caption: Table of Contents\n   :numbered:\n\n   intro\n   start\n   layers\n   customizing-images\n   new-recipe\n   new-machine\n   upgrading-recipes\n   temporary-source-code\n   quilt.rst\n   development-shell\n   python-development-shell\n   building\n   speeding-up-build\n   libraries\n   prebuilt-libraries\n   x32-psabi\n   gobject-introspection\n   external-toolchain\n   wic\n   bmaptool\n   securing-images\n   custom-distribution\n   custom-template-configuration-directory\n   disk-space\n   packages\n   efficiently-fetching-sources\n   init-manager\n   device-manager\n   external-scm\n   read-only-rootfs\n   build-quality\n   runtime-testing\n   debugging\n   licenses\n   security-subjects\n   vulnerabilities\n   sbom\n   error-reporting-tool\n   wayland\n   qemu\n\n.. include:: /boilerplate.rst\n\n\n======================================\nYocto Project Development Tasks Manual\n======================================\n\n.. toctree::\n   :caption: Table of Contents\n   :numbered:\n\n   intro\n   start\n   layers\n   customizing-images\n   new-recipe\n   new-machine\n   upgrading-recipes\n   temporary-source-code\n   quilt.rst\n   development-shell\n   python-development-shell\n   building\n   speeding-up-build\n   libraries\n   prebuilt-libraries\n   x32-psabi\n   gobject-introspection\n   external-toolchain\n   wic\n   bmaptool\n   securing-images\n   custom-distribution\n   custom-template-configuration-directory\n   disk-space\n   packages\n   efficiently-fetching-sources\n   init-manager\n   device-manager\n   external-scm\n   read-only-rootfs\n   build-quality\n   runtime-testing\n   debugging\n   licenses\n   security-subjects\n   vulnerabilities\n   sbom\n   error-reporting-tool\n   wayland\n   qemu\n\n.. include:: /boilerplate.rst\n"}
{"text": "\n\nUsing the Error Reporting Tool\n\n\nUsing the Error Reporting Tool\n******************************\n\nThe error reporting tool allows you to submit errors encountered during\nbuilds to a central database. Outside of the build environment, you can\nuse a web interface to browse errors, view statistics, and query for\nerrors. The tool works using a client-server system where the client\nportion is integrated with the installed Yocto Project\n:term:`Source Directory` (e.g. ``poky``).\nThe server receives the information collected and saves it in a\ndatabase.\n\nThere is a live instance of the error reporting server at\nhttps://errors.yoctoproject.org.\nWhen you want to get help with build failures, you can submit all of the\ninformation on the failure easily and then point to the URL in your bug\nreport or send an email to the mailing list.\n\n.. note::\n\n   If you send error reports to this server, the reports become publicly\n   visible.\n\nEnabling and Using the Tool\n===========================\n\nBy default, the error reporting tool is disabled. You can enable it by\ninheriting the :ref:`ref-classes-report-error` class by adding the\nfollowing statement to the end of your ``local.conf`` file in your\n:term:`Build Directory`::\n\n   INHERIT += \"report-error\"\n\nBy default, the error reporting feature stores information in\n``${``\\ :term:`LOG_DIR`\\ ``}/error-report``.\nHowever, you can specify a directory to use by adding the following to\nyour ``local.conf`` file::\n\n   ERR_REPORT_DIR = \"path\"\n\nEnabling error\nreporting causes the build process to collect the errors and store them\nin a file as previously described. When the build system encounters an\nerror, it includes a command as part of the console output. You can run\nthe command to send the error file to the server. For example, the\nfollowing command sends the errors to an upstream server::\n\n   $ send-error-report /home/brandusa/project/poky/build/tmp/log/error-report/error_report_201403141617.txt\n\nIn the previous example, the errors are sent to a public database\navailable at https://errors.yoctoproject.org, which is used by the\nentire community. If you specify a particular server, you can send the\nerrors to a different database. Use the following command for more\ninformation on available options::\n\n   $ send-error-report --help\n\nWhen sending the error file, you are prompted to review the data being\nsent as well as to provide a name and optional email address. Once you\nsatisfy these prompts, the command returns a link from the server that\ncorresponds to your entry in the database. For example, here is a\ntypical link: https://errors.yoctoproject.org/Errors/Details/9522/\n\nFollowing the link takes you to a web interface where you can browse,\nquery the errors, and view statistics.\n\nDisabling the Tool\n==================\n\nTo disable the error reporting feature, simply remove or comment out the\nfollowing statement from the end of your ``local.conf`` file in your\n:term:`Build Directory`::\n\n   INHERIT += \"report-error\"\n\nSetting Up Your Own Error Reporting Server\n==========================================\n\nIf you want to set up your own error reporting server, you can obtain\nthe code from the Git repository at :yocto_git:`/error-report-web/`.\nInstructions on how to set it up are in the README document.\n\n"}
{"text": "\n\nFinding Temporary Source Code\n\n\nFinding Temporary Source Code\n*****************************\n\nYou might find it helpful during development to modify the temporary\nsource code used by recipes to build packages. For example, suppose you\nare developing a patch and you need to experiment a bit to figure out\nyour solution. After you have initially built the package, you can\niteratively tweak the source code, which is located in the\n:term:`Build Directory`, and then you can force a re-compile and quickly\ntest your altered code. Once you settle on a solution, you can then preserve\nyour changes in the form of patches.\n\nDuring a build, the unpacked temporary source code used by recipes to\nbuild packages is available in the :term:`Build Directory` as defined by the\n:term:`S` variable. Below is the default value for the :term:`S` variable as\ndefined in the ``meta/conf/bitbake.conf`` configuration file in the\n:term:`Source Directory`::\n\n   S = \"${WORKDIR}/${BP}\"\n\nYou should be aware that many recipes override the\n:term:`S` variable. For example, recipes that fetch their source from Git\nusually set :term:`S` to ``${WORKDIR}/git``.\n\n.. note::\n\n   The :term:`BP` represents the base recipe name, which consists of the name\n   and version::\n\n           BP = \"${BPN}-${PV}\"\n\n\nThe path to the work directory for the recipe\n(:term:`WORKDIR`) is defined as\nfollows::\n\n   ${TMPDIR}/work/${MULTIMACH_TARGET_SYS}/${PN}/${EXTENDPE}${PV}-${PR}\n\nThe actual directory depends on several things:\n\n-  :term:`TMPDIR`: The top-level build\n   output directory.\n\n-  :term:`MULTIMACH_TARGET_SYS`:\n   The target system identifier.\n\n-  :term:`PN`: The recipe name.\n\n-  :term:`EXTENDPE`: The epoch --- if\n   :term:`PE` is not specified, which is\n   usually the case for most recipes, then :term:`EXTENDPE` is blank.\n\n-  :term:`PV`: The recipe version.\n\n-  :term:`PR`: The recipe revision.\n\nAs an example, assume a Source Directory top-level folder named\n``poky``, a default :term:`Build Directory` at ``poky/build``, and a\n``qemux86-poky-linux`` machine target system. Furthermore, suppose your\nrecipe is named ``foo_1.3.0.bb``. In this case, the work directory the\nbuild system uses to build the package would be as follows::\n\n   poky/build/tmp/work/qemux86-poky-linux/foo/1.3.0-r0\n\n"}
{"text": "\n\nUsing a Development Shell\n\n\nUsing a Development Shell\n*************************\n\nWhen debugging certain commands or even when just editing packages,\n``devshell`` can be a useful tool. When you invoke ``devshell``, all\ntasks up to and including\n:ref:`ref-tasks-patch` are run for the\nspecified target. Then, a new terminal is opened and you are placed in\n``${``\\ :term:`S`\\ ``}``, the source\ndirectory. In the new terminal, all the OpenEmbedded build-related\nenvironment variables are still defined so you can use commands such as\n``configure`` and ``make``. The commands execute just as if the\nOpenEmbedded build system were executing them. Consequently, working\nthis way can be helpful when debugging a build or preparing software to\nbe used with the OpenEmbedded build system.\n\nFollowing is an example that uses ``devshell`` on a target named\n``matchbox-desktop``::\n\n  $ bitbake matchbox-desktop -c devshell\n\nThis command spawns a terminal with a shell prompt within the\nOpenEmbedded build environment. The\n:term:`OE_TERMINAL` variable\ncontrols what type of shell is opened.\n\nFor spawned terminals, the following occurs:\n\n-  The ``PATH`` variable includes the cross-toolchain.\n\n-  The ``pkgconfig`` variables find the correct ``.pc`` files.\n\n-  The ``configure`` command finds the Yocto Project site files as well\n   as any other necessary files.\n\nWithin this environment, you can run configure or compile commands as if\nthey were being run by the OpenEmbedded build system itself. As noted\nearlier, the working directory also automatically changes to the Source\nDirectory (:term:`S`).\n\nTo manually run a specific task using ``devshell``, run the\ncorresponding ``run.*`` script in the\n``${``\\ :term:`WORKDIR`\\ ``}/temp``\ndirectory (e.g., ``run.do_configure.``\\ `pid`). If a task's script does\nnot exist, which would be the case if the task was skipped by way of the\nsstate cache, you can create the task by first running it outside of the\n``devshell``::\n\n   $ bitbake -c task\n\n.. note::\n\n   -  Execution of a task's ``run.*`` script and BitBake's execution of\n      a task are identical. In other words, running the script re-runs\n      the task just as it would be run using the ``bitbake -c`` command.\n\n   -  Any ``run.*`` file that does not have a ``.pid`` extension is a\n      symbolic link (symlink) to the most recent version of that file.\n\nRemember, that the ``devshell`` is a mechanism that allows you to get\ninto the BitBake task execution environment. And as such, all commands\nmust be called just as BitBake would call them. That means you need to\nprovide the appropriate options for cross-compilation and so forth as\napplicable.\n\nWhen you are finished using ``devshell``, exit the shell or close the\nterminal window.\n\n.. note::\n\n   -  It is worth remembering that when using ``devshell`` you need to\n      use the full compiler name such as ``arm-poky-linux-gnueabi-gcc``\n      instead of just using ``gcc``. The same applies to other\n      applications such as ``binutils``, ``libtool`` and so forth.\n      BitBake sets up environment variables such as :term:`CC` to assist\n      applications, such as ``make`` to find the correct tools.\n\n   -  It is also worth noting that ``devshell`` still works over X11\n      forwarding and similar situations.\n\n"}
{"text": "\n\nCustomizing Images\n\n\nCustomizing Images\n******************\n\nYou can customize images to satisfy particular requirements. This\nsection describes several methods and provides guidelines for each.\n\nCustomizing Images Using ``local.conf``\n=======================================\n\nProbably the easiest way to customize an image is to add a package by\nway of the ``local.conf`` configuration file. Because it is limited to\nlocal use, this method generally only allows you to add packages and is\nnot as flexible as creating your own customized image. When you add\npackages using local variables this way, you need to realize that these\nvariable changes are in effect for every build and consequently affect\nall images, which might not be what you require.\n\nTo add a package to your image using the local configuration file, use\nthe :term:`IMAGE_INSTALL` variable with the ``:append`` operator::\n\n   IMAGE_INSTALL:append = \" strace\"\n\nUse of the syntax is important; specifically, the leading space\nafter the opening quote and before the package name, which is\n``strace`` in this example. This space is required since the ``:append``\noperator does not add the space.\n\nFurthermore, you must use ``:append`` instead of the ``+=`` operator if\nyou want to avoid ordering issues. The reason for this is because doing\nso unconditionally appends to the variable and avoids ordering problems\ndue to the variable being set in image recipes and ``.bbclass`` files\nwith operators like ``?=``. Using ``:append`` ensures the operation\ntakes effect.\n\nAs shown in its simplest use, ``IMAGE_INSTALL:append`` affects all\nimages. It is possible to extend the syntax so that the variable applies\nto a specific image only. Here is an example::\n\n   IMAGE_INSTALL:append:pn-core-image-minimal = \" strace\"\n\nThis example adds ``strace`` to the ``core-image-minimal`` image only.\n\nYou can add packages using a similar approach through the\n:term:`CORE_IMAGE_EXTRA_INSTALL` variable. If you use this variable, only\n``core-image-*`` images are affected.\n\nCustomizing Images Using Custom ``IMAGE_FEATURES`` and ``EXTRA_IMAGE_FEATURES``\n===============================================================================\n\nAnother method for customizing your image is to enable or disable\nhigh-level image features by using the\n:term:`IMAGE_FEATURES` and\n:term:`EXTRA_IMAGE_FEATURES`\nvariables. Although the functions for both variables are nearly\nequivalent, best practices dictate using :term:`IMAGE_FEATURES` from within\na recipe and using :term:`EXTRA_IMAGE_FEATURES` from within your\n``local.conf`` file, which is found in the :term:`Build Directory`.\n\nTo understand how these features work, the best reference is\n:ref:`meta/classes-recipe/image.bbclass <ref-classes-image>`.\nThis class lists out the available\n:term:`IMAGE_FEATURES` of which most map to package groups while some, such\nas ``debug-tweaks`` and ``read-only-rootfs``, resolve as general\nconfiguration settings.\n\nIn summary, the file looks at the contents of the :term:`IMAGE_FEATURES`\nvariable and then maps or configures the feature accordingly. Based on\nthis information, the build system automatically adds the appropriate\npackages or configurations to the\n:term:`IMAGE_INSTALL` variable.\nEffectively, you are enabling extra features by extending the class or\ncreating a custom class for use with specialized image ``.bb`` files.\n\nUse the :term:`EXTRA_IMAGE_FEATURES` variable from within your local\nconfiguration file. Using a separate area from which to enable features\nwith this variable helps you avoid overwriting the features in the image\nrecipe that are enabled with :term:`IMAGE_FEATURES`. The value of\n:term:`EXTRA_IMAGE_FEATURES` is added to :term:`IMAGE_FEATURES` within\n``meta/conf/bitbake.conf``.\n\nTo illustrate how you can use these variables to modify your image,\nconsider an example that selects the SSH server. The Yocto Project ships\nwith two SSH servers you can use with your images: Dropbear and OpenSSH.\nDropbear is a minimal SSH server appropriate for resource-constrained\nenvironments, while OpenSSH is a well-known standard SSH server\nimplementation. By default, the ``core-image-sato`` image is configured\nto use Dropbear. The ``core-image-full-cmdline`` and ``core-image-lsb``\nimages both include OpenSSH. The ``core-image-minimal`` image does not\ncontain an SSH server.\n\nYou can customize your image and change these defaults. Edit the\n:term:`IMAGE_FEATURES` variable in your recipe or use the\n:term:`EXTRA_IMAGE_FEATURES` in your ``local.conf`` file so that it\nconfigures the image you are working with to include\n``ssh-server-dropbear`` or ``ssh-server-openssh``.\n\n.. note::\n\n"}
{"text": "\n\nCustomizing Images\n   See the \":ref:`ref-manual/features:image features`\" section in the Yocto\n   Project Reference Manual for a complete list of image features that ship\n   with the Yocto Project.\n\nCustomizing Images Using Custom .bb Files\n=========================================\n\nYou can also customize an image by creating a custom recipe that defines\nadditional software as part of the image. The following example shows\nthe form for the two lines you need::\n\n   IMAGE_INSTALL = \"packagegroup-core-x11-base package1 package2\"\n   inherit core-image\n\nDefining the software using a custom recipe gives you total control over\nthe contents of the image. It is important to use the correct names of\npackages in the :term:`IMAGE_INSTALL` variable. You must use the\nOpenEmbedded notation and not the Debian notation for the names (e.g.\n``glibc-dev`` instead of ``libc6-dev``).\n\nThe other method for creating a custom image is to base it on an\nexisting image. For example, if you want to create an image based on\n``core-image-sato`` but add the additional package ``strace`` to the\nimage, copy the ``meta/recipes-sato/images/core-image-sato.bb`` to a new\n``.bb`` and add the following line to the end of the copy::\n\n   IMAGE_INSTALL += \"strace\"\n\nCustomizing Images Using Custom Package Groups\n==============================================\n\nFor complex custom images, the best approach for customizing an image is\nto create a custom package group recipe that is used to build the image\nor images. A good example of a package group recipe is\n``meta/recipes-core/packagegroups/packagegroup-base.bb``.\n\nIf you examine that recipe, you see that the :term:`PACKAGES` variable lists\nthe package group packages to produce. The ``inherit packagegroup``\nstatement sets appropriate default values and automatically adds\n``-dev``, ``-dbg``, and ``-ptest`` complementary packages for each\npackage specified in the :term:`PACKAGES` statement.\n\n.. note::\n\n   The ``inherit packagegroup`` line should be located near the top of the\n   recipe, certainly before the :term:`PACKAGES` statement.\n\nFor each package you specify in :term:`PACKAGES`, you can use :term:`RDEPENDS`\nand :term:`RRECOMMENDS` entries to provide a list of packages the parent\ntask package should contain. You can see examples of these further down\nin the ``packagegroup-base.bb`` recipe.\n\nHere is a short, fabricated example showing the same basic pieces for a\nhypothetical packagegroup defined in ``packagegroup-custom.bb``, where\nthe variable :term:`PN` is the standard way to abbreviate the reference to\nthe full packagegroup name ``packagegroup-custom``::\n\n   DESCRIPTION = \"My Custom Package Groups\"\n\n   inherit packagegroup\n\n   PACKAGES = \"\\\n       ${PN}-apps \\\n       ${PN}-tools \\\n       \"\n\n   RDEPENDS:${PN}-apps = \"\\\n       dropbear \\\n       portmap \\\n       psplash\"\n\n   RDEPENDS:${PN}-tools = \"\\\n       oprofile \\\n       oprofileui-server \\\n       lttng-tools\"\n\n   RRECOMMENDS:${PN}-tools = \"\\\n       kernel-module-oprofile\"\n\nIn the previous example, two package group packages are created with\ntheir dependencies and their recommended package dependencies listed:\n``packagegroup-custom-apps``, and ``packagegroup-custom-tools``. To\nbuild an image using these package group packages, you need to add\n``packagegroup-custom-apps`` and/or ``packagegroup-custom-tools`` to\n:term:`IMAGE_INSTALL`. For other forms of image dependencies see the other\nareas of this section.\n\nCustomizing an Image Hostname\n=============================\n\nBy default, the configured hostname (i.e. ``/etc/hostname``) in an image\nis the same as the machine name. For example, if\n:term:`MACHINE` equals \"qemux86\", the\nconfigured hostname written to ``/etc/hostname`` is \"qemux86\".\n\nYou can customize this name by altering the value of the \"hostname\"\nvariable in the ``base-files`` recipe using either an append file or a\nconfiguration file. Use the following in an append file::\n\n   hostname = \"myhostname\"\n"}
{"text": "\n\nCustomizing Images\n\nUse the following in a configuration file::\n\n   hostname:pn-base-files = \"myhostname\"\n\nChanging the default value of the variable \"hostname\" can be useful in\ncertain situations. For example, suppose you need to do extensive\ntesting on an image and you would like to easily identify the image\nunder test from existing images with typical default hostnames. In this\nsituation, you could change the default hostname to \"testme\", which\nresults in all the images using the name \"testme\". Once testing is\ncomplete and you do not need to rebuild the image for test any longer,\nyou can easily reset the default hostname.\n\nAnother point of interest is that if you unset the variable, the image\nwill have no default hostname in the filesystem. Here is an example that\nunsets the variable in a configuration file::\n\n  hostname:pn-base-files = \"\"\n\nHaving no default hostname in the filesystem is suitable for\nenvironments that use dynamic hostnames such as virtual machines.\n\n"}
{"text": "\n\n\n\n*******************************\nUsing the Quick EMUlator (QEMU)\n*******************************\n\nThe Yocto Project uses an implementation of the Quick EMUlator (QEMU)\nOpen Source project as part of the Yocto Project development \"tool set\".\nThis chapter provides both procedures that show you how to use the Quick\nEMUlator (QEMU) and other QEMU information helpful for development\npurposes.\n\nOverview\n========\n\nWithin the context of the Yocto Project, QEMU is an emulator and\nvirtualization machine that allows you to run a complete image you have\nbuilt using the Yocto Project as just another task on your build system.\nQEMU is useful for running and testing images and applications on\nsupported Yocto Project architectures without having actual hardware.\nAmong other things, the Yocto Project uses QEMU to run automated Quality\nAssurance (QA) tests on final images shipped with each release.\n\n.. note::\n\n   This implementation is not the same as QEMU in general.\n\nThis section provides a brief reference for the Yocto Project\nimplementation of QEMU.\n\nFor official information and documentation on QEMU in general, see the\nfollowing references:\n\n-  `QEMU Website <https://wiki.qemu.org/Main_Page>`__\\ *:* The official\n   website for the QEMU Open Source project.\n\n-  `Documentation <https://wiki.qemu.org/Manual>`__\\ *:* The QEMU user\n   manual.\n\nRunning QEMU\n============\n\nTo use QEMU, you need to have QEMU installed and initialized as well as\nhave the proper artifacts (i.e. image files and root filesystems)\navailable. Follow these general steps to run QEMU:\n\n#. *Install QEMU:* QEMU is made available with the Yocto Project a\n   number of ways. One method is to install a Software Development Kit\n   (SDK). See \":ref:`sdk-manual/intro:the qemu emulator`\" section in the\n   Yocto Project Application Development and the Extensible Software\n   Development Kit (eSDK) manual for information on how to install QEMU.\n\n#. *Setting Up the Environment:* How you set up the QEMU environment\n   depends on how you installed QEMU:\n\n   -  If you cloned the ``poky`` repository or you downloaded and\n      unpacked a Yocto Project release tarball, you can source the build\n      environment script (i.e. :ref:`structure-core-script`)::\n\n         $ cd poky\n         $ source oe-init-build-env\n\n   -  If you installed a cross-toolchain, you can run the script that\n      initializes the toolchain. For example, the following commands run\n      the initialization script from the default ``poky_sdk`` directory::\n\n         . poky_sdk/environment-setup-core2-64-poky-linux\n\n#. *Ensure the Artifacts are in Place:* You need to be sure you have a\n   pre-built kernel that will boot in QEMU. You also need the target\n   root filesystem for your target machine's architecture:\n\n   -  If you have previously built an image for QEMU (e.g. ``qemux86``,\n      ``qemuarm``, and so forth), then the artifacts are in place in\n      your :term:`Build Directory`.\n\n   -  If you have not built an image, you can go to the\n      :yocto_dl:`machines/qemu </releases/yocto/yocto-&DISTRO;/machines/qemu/>` area and download a\n      pre-built image that matches your architecture and can be run on\n      QEMU.\n\n   See the \":ref:`sdk-manual/appendix-obtain:extracting the root filesystem`\"\n   section in the Yocto Project Application Development and the\n   Extensible Software Development Kit (eSDK) manual for information on\n   how to extract a root filesystem.\n\n#. *Run QEMU:* The basic ``runqemu`` command syntax is as follows::\n\n      $ runqemu [option ] [...]\n\n   Based on what you provide on the command\n   line, ``runqemu`` does a good job of figuring out what you are trying\n   to do. For example, by default, QEMU looks for the most recently\n   built image according to the timestamp when it needs to look for an\n   image. Minimally, through the use of options, you must provide either\n   a machine name, a virtual machine image (``*wic.vmdk``), or a kernel\n   image (``*.bin``).\n\n   Here are some additional examples to help illustrate further QEMU:\n\n"}
{"text": "\n\nUsing the Quick EMUlator (QEMU)\n   -  This example starts QEMU with MACHINE set to \"qemux86-64\".\n      Assuming a standard :term:`Build Directory`, ``runqemu``\n      automatically finds the ``bzImage-qemux86-64.bin`` image file and\n      the ``core-image-minimal-qemux86-64-20200218002850.rootfs.ext4``\n      (assuming the current build created a ``core-image-minimal``\n      image)::\n\n        $ runqemu qemux86-64\n\n      .. note::\n\n         When more than one image with the same name exists, QEMU finds\n         and uses the most recently built image according to the\n         timestamp.\n\n   -  This example produces the exact same results as the previous\n      example. This command, however, specifically provides the image\n      and root filesystem type::\n\n         $ runqemu qemux86-64 core-image-minimal ext4\n\n   -  This example specifies to boot an :term:`Initramfs` image and to\n      enable audio in QEMU. For this case, ``runqemu`` sets the internal\n      variable ``FSTYPE`` to ``cpio.gz``. Also, for audio to be enabled,\n      an appropriate driver must be installed (see the ``audio`` option\n      in :ref:`dev-manual/qemu:\\`\\`runqemu\\`\\` command-line options`\n      for more information)::\n\n         $ runqemu qemux86-64 ramfs audio\n\n   -  This example does not provide enough information for QEMU to\n      launch. While the command does provide a root filesystem type, it\n      must also minimally provide a `MACHINE`, `KERNEL`, or `VM` option::\n\n         $ runqemu ext4\n\n   -  This example specifies to boot a virtual machine image\n      (``.wic.vmdk`` file). From the ``.wic.vmdk``, ``runqemu``\n      determines the QEMU architecture (`MACHINE`) to be \"qemux86-64\" and\n      the root filesystem type to be \"vmdk\"::\n\n         $ runqemu /home/scott-lenovo/vm/core-image-minimal-qemux86-64.wic.vmdk\n\nSwitching Between Consoles\n==========================\n\nWhen booting or running QEMU, you can switch between supported consoles\nby using Ctrl+Alt+number. For example, Ctrl+Alt+3 switches you to the\nserial console as long as that console is enabled. Being able to switch\nconsoles is helpful, for example, if the main QEMU console breaks for\nsome reason.\n\n.. note::\n\n   Usually, \"2\" gets you to the main console and \"3\" gets you to the\n   serial console.\n\nRemoving the Splash Screen\n==========================\n\nYou can remove the splash screen when QEMU is booting by using Alt+left.\nRemoving the splash screen allows you to see what is happening in the\nbackground.\n\nDisabling the Cursor Grab\n=========================\n\nThe default QEMU integration captures the cursor within the main window.\nIt does this since standard mouse devices only provide relative input\nand not absolute coordinates. You then have to break out of the grab\nusing the \"Ctrl+Alt\" key combination. However, the Yocto Project's\nintegration of QEMU enables the wacom USB touch pad driver by default to\nallow input of absolute coordinates. This default means that the mouse\ncan enter and leave the main window without the grab taking effect\nleading to a better user experience.\n\nRunning Under a Network File System (NFS) Server\n================================================\n\nOne method for running QEMU is to run it on an NFS server. This is\nuseful when you need to access the same file system from both the build\nand the emulated system at the same time. It is also worth noting that\nthe system does not need root privileges to run. It uses a user space\nNFS server to avoid that. Follow these steps to set up for running QEMU\nusing an NFS server.\n\n#. *Extract a Root Filesystem:* Once you are able to run QEMU in your\n   environment, you can use the ``runqemu-extract-sdk`` script, which is\n   located in the ``scripts`` directory along with the ``runqemu``\n   script.\n\n   The ``runqemu-extract-sdk`` takes a root filesystem tarball and\n   extracts it into a location that you specify. Here is an example that\n   takes a file system and extracts it to a directory named\n   ``test-nfs``:\n\n   .. code-block:: none\n\n      runqemu-extract-sdk ./tmp/deploy/images/qemux86-64/core-image-sato-qemux86-64.tar.bz2 test-nfs\n\n"}
{"text": "\n\nUsing the Quick EMUlator (QEMU)\n#. *Start QEMU:* Once you have extracted the file system, you can run\n   ``runqemu`` normally with the additional location of the file system.\n   You can then also make changes to the files within ``./test-nfs`` and\n   see those changes appear in the image in real time. Here is an\n   example using the ``qemux86`` image:\n\n   .. code-block:: none\n\n      runqemu qemux86-64 ./test-nfs\n\n.. note::\n\n   Should you need to start, stop, or restart the NFS share, you can use\n   the following commands:\n\n   -  To start the NFS share::\n\n         runqemu-export-rootfs start file-system-location\n\n   -  To stop the NFS share::\n\n         runqemu-export-rootfs stop file-system-location\n\n   -  To restart the NFS share::\n\n         runqemu-export-rootfs restart file-system-location\n\nQEMU CPU Compatibility Under KVM\n================================\n\nBy default, the QEMU build compiles for and targets 64-bit and x86 Intel\nCore2 Duo processors and 32-bit x86 Intel Pentium II processors. QEMU\nbuilds for and targets these CPU types because they display a broad\nrange of CPU feature compatibility with many commonly used CPUs.\n\nDespite this broad range of compatibility, the CPUs could support a\nfeature that your host CPU does not support. Although this situation is\nnot a problem when QEMU uses software emulation of the feature, it can\nbe a problem when QEMU is running with KVM enabled. Specifically,\nsoftware compiled with a certain CPU feature crashes when run on a CPU\nunder KVM that does not support that feature. To work around this\nproblem, you can override QEMU's runtime CPU setting by changing the\n``QB_CPU_KVM`` variable in ``qemuboot.conf`` in the :term:`Build Directory`\n``deploy/image`` directory. This setting specifies a ``-cpu`` option passed\ninto QEMU in the ``runqemu`` script. Running ``qemu -cpu help`` returns a\nlist of available supported CPU types.\n\nQEMU Performance\n================\n\nUsing QEMU to emulate your hardware can result in speed issues depending\non the target and host architecture mix. For example, using the\n``qemux86`` image in the emulator on an Intel-based 32-bit (x86) host\nmachine is fast because the target and host architectures match. On the\nother hand, using the ``qemuarm`` image on the same Intel-based host can\nbe slower. But, you still achieve faithful emulation of ARM-specific\nissues.\n\nTo speed things up, the QEMU images support using ``distcc`` to call a\ncross-compiler outside the emulated system. If you used ``runqemu`` to\nstart QEMU, and the ``distccd`` application is present on the host\nsystem, any BitBake cross-compiling toolchain available from the build\nsystem is automatically used from within QEMU simply by calling\n``distcc``. You can accomplish this by defining the cross-compiler\nvariable (e.g. ``export CC=\"distcc\"``). Alternatively, if you are using\na suitable SDK image or the appropriate stand-alone toolchain is\npresent, the toolchain is also automatically used.\n\n.. note::\n\n   There are several mechanisms to connect to the system running\n   on the QEMU emulator:\n\n   -  QEMU provides a framebuffer interface that makes standard consoles\n      available.\n\n   -  Generally, headless embedded devices have a serial port. If so,\n      you can configure the operating system of the running image to use\n      that port to run a console. The connection uses standard IP\n      networking.\n\n   -  SSH servers are available in some QEMU images. The ``core-image-sato``\n      QEMU image has a Dropbear secure shell (SSH) server that runs with\n      the root password disabled. The ``core-image-full-cmdline`` and\n      ``core-image-lsb`` QEMU images have OpenSSH instead of Dropbear.\n      Including these SSH servers allow you to use standard ``ssh`` and\n      ``scp`` commands. The ``core-image-minimal`` QEMU image, however,\n      contains no SSH server.\n\n   -  You can use a provided, user-space NFS server to boot the QEMU\n      session using a local copy of the root filesystem on the host. In\n      order to make this connection, you must extract a root filesystem\n      tarball by using the ``runqemu-extract-sdk`` command. After\n      running the command, you must then point the ``runqemu`` script to\n      the extracted directory instead of a root filesystem image file.\n      See the\n      \":ref:`dev-manual/qemu:running under a network file system (nfs) server`\"\n      section for more information.\n\nQEMU Command-Line Syntax\n"}
{"text": "\n\nUsing the Quick EMUlator (QEMU)\n========================\n\nThe basic ``runqemu`` command syntax is as follows::\n\n   $ runqemu [option ] [...]\n\nBased on what you provide on the command line, ``runqemu`` does a\ngood job of figuring out what you are trying to do. For example, by\ndefault, QEMU looks for the most recently built image according to the\ntimestamp when it needs to look for an image. Minimally, through the use\nof options, you must provide either a machine name, a virtual machine\nimage (``*wic.vmdk``), or a kernel image (``*.bin``).\n\nFollowing is the command-line help output for the ``runqemu`` command::\n\n   $ runqemu --help\n\n   Usage: you can run this script with any valid combination\n   of the following environment variables (in any order):\n     KERNEL - the kernel image file to use\n     ROOTFS - the rootfs image file or nfsroot directory to use\n     MACHINE - the machine name (optional, autodetected from KERNEL filename if unspecified)\n     Simplified QEMU command-line options can be passed with:\n       nographic - disable video console\n       serial - enable a serial console on /dev/ttyS0\n       slirp - enable user networking, no root privileges required\n       kvm - enable KVM when running x86/x86_64 (VT-capable CPU required)\n       kvm-vhost - enable KVM with vhost when running x86/x86_64 (VT-capable CPU required)\n       publicvnc - enable a VNC server open to all hosts\n       audio - enable audio\n       [*/]ovmf* - OVMF firmware file or base name for booting with UEFI\n     tcpserial=<port> - specify tcp serial port number\n     biosdir=<dir> - specify custom bios dir\n     biosfilename=<filename> - specify bios filename\n     qemuparams=<xyz> - specify custom parameters to QEMU\n     bootparams=<xyz> - specify custom kernel parameters during boot\n     help, -h, --help: print this text\n\n   Examples:\n     runqemu\n     runqemu qemuarm\n     runqemu tmp/deploy/images/qemuarm\n     runqemu tmp/deploy/images/qemux86/<qemuboot.conf>\n     runqemu qemux86-64 core-image-sato ext4\n     runqemu qemux86-64 wic-image-minimal wic\n     runqemu path/to/bzImage-qemux86.bin path/to/nfsrootdir/ serial\n     runqemu qemux86 iso/hddimg/wic.vmdk/wic.qcow2/wic.vdi/ramfs/cpio.gz...\n     runqemu qemux86 qemuparams=\"-m 256\"\n     runqemu qemux86 bootparams=\"psplash=false\"\n     runqemu path/to/<image>-<machine>.wic\n     runqemu path/to/<image>-<machine>.wic.vmdk\n\n``runqemu`` Command-Line Options\n================================\n\nFollowing is a description of ``runqemu`` options you can provide on the\ncommand line:\n\n.. note::\n\n   If you do provide some \"illegal\" option combination or perhaps you do\n   not provide enough in the way of options, ``runqemu``\n   provides appropriate error messaging to help you correct the problem.\n\n-  `QEMUARCH`: The QEMU machine architecture, which must be \"qemuarm\",\n   \"qemuarm64\", \"qemumips\", \"qemumips64\", \"qemuppc\", \"qemux86\", or\n   \"qemux86-64\".\n\n-  `VM`: The virtual machine image, which must be a ``.wic.vmdk``\n   file. Use this option when you want to boot a ``.wic.vmdk`` image.\n   The image filename you provide must contain one of the following\n   strings: \"qemux86-64\", \"qemux86\", \"qemuarm\", \"qemumips64\",\n   \"qemumips\", \"qemuppc\", or \"qemush4\".\n\n-  `ROOTFS`: A root filesystem that has one of the following filetype\n   extensions: \"ext2\", \"ext3\", \"ext4\", \"jffs2\", \"nfs\", or \"btrfs\". If\n   the filename you provide for this option uses \"nfs\", it must provide\n   an explicit root filesystem path.\n\n-  `KERNEL`: A kernel image, which is a ``.bin`` file. When you provide a\n   ``.bin`` file, ``runqemu`` detects it and assumes the file is a\n   kernel image.\n\n-  `MACHINE`: The architecture of the QEMU machine, which must be one of\n   the following: \"qemux86\", \"qemux86-64\", \"qemuarm\", \"qemuarm64\",\n   \"qemumips\", \"qemumips64\", or \"qemuppc\". The MACHINE and QEMUARCH\n   options are basically identical. If you do not provide a MACHINE\n   option, ``runqemu`` tries to determine it based on other options.\n\n-  ``ramfs``: Indicates you are booting an :term:`Initramfs`\n   image, which means the ``FSTYPE`` is ``cpio.gz``.\n\n-  ``iso``: Indicates you are booting an ISO image, which means the\n   ``FSTYPE`` is ``.iso``.\n\n-  ``nographic``: Disables the video console, which sets the console to\n   \"ttys0\". This option is useful when you have logged into a server and\n   you do not want to disable forwarding from the X Window System (X11)\n   to your workstation or laptop.\n\n"}
{"text": "\n\nUsing the Quick EMUlator (QEMU)\n-  ``serial``: Enables a serial console on ``/dev/ttyS0``.\n\n-  ``biosdir``: Establishes a custom directory for BIOS, VGA BIOS and\n   keymaps.\n\n-  ``biosfilename``: Establishes a custom BIOS name.\n\n-  ``qemuparams=\\\"xyz\\\"``: Specifies custom QEMU parameters. Use this\n   option to pass options other than the simple \"kvm\" and \"serial\"\n   options.\n\n-  ``bootparams=\\\"xyz\\\"``: Specifies custom boot parameters for the\n   kernel.\n\n-  ``audio``: Enables audio in QEMU. The MACHINE option must be either\n   \"qemux86\" or \"qemux86-64\" in order for audio to be enabled.\n   Additionally, the ``snd_intel8x0`` or ``snd_ens1370`` driver must be\n   installed in linux guest.\n\n-  ``slirp``: Enables \"slirp\" networking, which is a different way of\n   networking that does not need root access but also is not as easy to\n   use or comprehensive as the default.\n\n   Using ``slirp`` by default will forward the guest machine's\n   22 and 23 TCP ports to host machine's 2222 and 2323 ports\n   (or the next free ports). Specific forwarding rules can be configured\n   by setting ``QB_SLIRP_OPT`` as environment variable or in ``qemuboot.conf``\n   in the :term:`Build Directory` ``deploy/image`` directory.\n   Examples::\n\n      QB_SLIRP_OPT=\"-netdev user,id=net0,hostfwd=tcp::8080-:80\"\n\n      QB_SLIRP_OPT=\"-netdev user,id=net0,hostfwd=tcp::8080-:80,hostfwd=tcp::2222-:22\"\n\n   The first example forwards TCP port 80 from the emulated system to\n   port 8080 (or the next free port) on the host system,\n   allowing access to an http server running in QEMU from\n   ``http://<host ip>:8080/``.\n\n   The second example does the same, but also forwards TCP port 22 on the\n   guest system to 2222 (or the next free port) on the host system,\n   allowing ssh access to the emulated system using\n   ``ssh -P 2222 <user>@<host ip>``.\n\n   Keep in mind that proper configuration of firewall software is required.\n\n-  ``kvm``: Enables KVM when running \"qemux86\" or \"qemux86-64\" QEMU\n   architectures. For KVM to work, all the following conditions must be\n   met:\n\n   -  Your MACHINE must be either qemux86\" or \"qemux86-64\".\n\n   -  Your build host has to have the KVM modules installed, which are\n      ``/dev/kvm``.\n\n   -  The build host ``/dev/kvm`` directory has to be both writable and\n      readable.\n\n-  ``kvm-vhost``: Enables KVM with VHOST support when running \"qemux86\"\n   or \"qemux86-64\" QEMU architectures. For KVM with VHOST to work, the\n   following conditions must be met:\n\n   -  ``kvm`` option conditions defined above must be met.\n\n   -  Your build host has to have virtio net device, which are\n      ``/dev/vhost-net``.\n\n   -  The build host ``/dev/vhost-net`` directory has to be either\n      readable or writable and \"slirp-enabled\".\n\n-  ``publicvnc``: Enables a VNC server open to all hosts.\n"}
{"text": "\n\nCreating a Read-Only Root Filesystem\n\n\nCreating a Read-Only Root Filesystem\n************************************\n\nSuppose, for security reasons, you need to disable your target device's\nroot filesystem's write permissions (i.e. you need a read-only root\nfilesystem). Or, perhaps you are running the device's operating system\nfrom a read-only storage device. For either case, you can customize your\nimage for that behavior.\n\n.. note::\n\n   Supporting a read-only root filesystem requires that the system and\n   applications do not try to write to the root filesystem. You must\n   configure all parts of the target system to write elsewhere, or to\n   gracefully fail in the event of attempting to write to the root\n   filesystem.\n\nCreating the Root Filesystem\n============================\n\nTo create the read-only root filesystem, simply add the\n\"read-only-rootfs\" feature to your image, normally in one of two ways.\nThe first way is to add the \"read-only-rootfs\" image feature in the\nimage's recipe file via the :term:`IMAGE_FEATURES` variable::\n\n   IMAGE_FEATURES += \"read-only-rootfs\"\n\nAs an alternative, you can add the same feature\nfrom within your :term:`Build Directory`'s ``local.conf`` file with the\nassociated :term:`EXTRA_IMAGE_FEATURES` variable, as in::\n\n   EXTRA_IMAGE_FEATURES = \"read-only-rootfs\"\n\nFor more information on how to use these variables, see the\n\":ref:`dev-manual/customizing-images:Customizing Images Using Custom \\`\\`IMAGE_FEATURES\\`\\` and \\`\\`EXTRA_IMAGE_FEATURES\\`\\``\"\nsection. For information on the variables, see\n:term:`IMAGE_FEATURES` and\n:term:`EXTRA_IMAGE_FEATURES`.\n\nPost-Installation Scripts and Read-Only Root Filesystem\n=======================================================\n\nIt is very important that you make sure all post-Installation\n(``pkg_postinst``) scripts for packages that are installed into the\nimage can be run at the time when the root filesystem is created during\nthe build on the host system. These scripts cannot attempt to run during\nthe first boot on the target device. With the \"read-only-rootfs\" feature\nenabled, the build system makes sure that all post-installation scripts\nsucceed at file system creation time. If any of these scripts\nstill need to be run after the root filesystem is created, the build\nimmediately fails. These build-time checks ensure that the build fails\nrather than the target device fails later during its initial boot\noperation.\n\nMost of the common post-installation scripts generated by the build\nsystem for the out-of-the-box Yocto Project are engineered so that they\ncan run during root filesystem creation (e.g. post-installation scripts\nfor caching fonts). However, if you create and add custom scripts, you\nneed to be sure they can be run during this file system creation.\n\nHere are some common problems that prevent post-installation scripts\nfrom running during root filesystem creation:\n\n-  *Not using $D in front of absolute paths:* The build system defines\n   ``$``\\ :term:`D` when the root\n   filesystem is created. Furthermore, ``$D`` is blank when the script\n   is run on the target device. This implies two purposes for ``$D``:\n   ensuring paths are valid in both the host and target environments,\n   and checking to determine which environment is being used as a method\n   for taking appropriate actions.\n\n-  *Attempting to run processes that are specific to or dependent on the\n   target architecture:* You can work around these attempts by using\n   native tools, which run on the host system, to accomplish the same\n   tasks, or by alternatively running the processes under QEMU, which\n   has the ``qemu_run_binary`` function. For more information, see the\n   :ref:`ref-classes-qemu` class.\n\nAreas With Write Access\n=======================\n\nWith the \"read-only-rootfs\" feature enabled, any attempt by the target\nto write to the root filesystem at runtime fails. Consequently, you must\nmake sure that you configure processes and applications that attempt\nthese types of writes do so to directories with write access (e.g.\n``/tmp`` or ``/var/run``).\n\n"}
{"text": "\n\nWriting a New Recipe\n\n\nWriting a New Recipe\n********************\n\nRecipes (``.bb`` files) are fundamental components in the Yocto Project\nenvironment. Each software component built by the OpenEmbedded build\nsystem requires a recipe to define the component. This section describes\nhow to create, write, and test a new recipe.\n\n.. note::\n\n   For information on variables that are useful for recipes and for\n   information about recipe naming issues, see the\n   \":ref:`ref-manual/varlocality:recipes`\" section of the Yocto Project\n   Reference Manual.\n\nOverview\n========\n\nThe following figure shows the basic process for creating a new recipe.\nThe remainder of the section provides details for the steps.\n\n.. image:: figures/recipe-workflow.png\n   :align: center\n   :width: 50%\n\nLocate or Automatically Create a Base Recipe\n============================================\n\nYou can always write a recipe from scratch. However, there are three choices\nthat can help you quickly get started with a new recipe:\n\n-  ``devtool add``: A command that assists in creating a recipe and an\n   environment conducive to development.\n\n-  ``recipetool create``: A command provided by the Yocto Project that\n   automates creation of a base recipe based on the source files.\n\n-  *Existing Recipes:* Location and modification of an existing recipe\n   that is similar in function to the recipe you need.\n\n.. note::\n\n   For information on recipe syntax, see the\n   \":ref:`dev-manual/new-recipe:recipe syntax`\" section.\n\nCreating the Base Recipe Using ``devtool add``\n----------------------------------------------\n\nThe ``devtool add`` command uses the same logic for auto-creating the\nrecipe as ``recipetool create``, which is listed below. Additionally,\nhowever, ``devtool add`` sets up an environment that makes it easy for\nyou to patch the source and to make changes to the recipe as is often\nnecessary when adding a recipe to build a new piece of software to be\nincluded in a build.\n\nYou can find a complete description of the ``devtool add`` command in\nthe \":ref:`sdk-manual/extensible:a closer look at \\`\\`devtool add\\`\\``\" section\nin the Yocto Project Application Development and the Extensible Software\nDevelopment Kit (eSDK) manual.\n\nCreating the Base Recipe Using ``recipetool create``\n----------------------------------------------------\n\n``recipetool create`` automates creation of a base recipe given a set of\nsource code files. As long as you can extract or point to the source\nfiles, the tool will construct a recipe and automatically configure all\npre-build information into the recipe. For example, suppose you have an\napplication that builds using Autotools. Creating the base recipe using\n``recipetool`` results in a recipe that has the pre-build dependencies,\nlicense requirements, and checksums configured.\n\nTo run the tool, you just need to be in your :term:`Build Directory` and\nhave sourced the build environment setup script (i.e.\n:ref:`structure-core-script`). To get help on the tool, use the following\ncommand::\n\n   $ recipetool -h\n   NOTE: Starting bitbake server...\n   usage: recipetool [-d] [-q] [--color COLOR] [-h] <subcommand> ...\n\n   OpenEmbedded recipe tool\n\n   options:\n     -d, --debug     Enable debug output\n     -q, --quiet     Print only errors\n     --color COLOR   Colorize output (where COLOR is auto, always, never)\n     -h, --help      show this help message and exit\n\n   subcommands:\n     create          Create a new recipe\n     newappend       Create a bbappend for the specified target in the specified\n                       layer\n     setvar          Set a variable within a recipe\n     appendfile      Create/update a bbappend to replace a target file\n     appendsrcfiles  Create/update a bbappend to add or replace source files\n     appendsrcfile   Create/update a bbappend to add or replace a source file\n   Use recipetool <subcommand> --help to get help on a specific command\n\n"}
{"text": "\n\nWriting a New Recipe\nRunning ``recipetool create -oOUTFILE`` creates the base recipe and\nlocates it properly in the layer that contains your source files.\nFollowing are some syntax examples:\n\n - Use this syntax to generate a recipe based on source. Once generated,\n   the recipe resides in the existing source code layer::\n\n      recipetool create -o OUTFILEsource\n\n - Use this syntax to generate a recipe using code that\n   you extract from source. The extracted code is placed in its own layer\n   defined by :term:`EXTERNALSRC`::\n\n      recipetool create -o OUTFILE -x EXTERNALSRC source\n\n - Use this syntax to generate a recipe based on source. The options\n   direct ``recipetool`` to generate debugging information. Once generated,\n   the recipe resides in the existing source code layer::\n\n      recipetool create -d -o OUTFILE source\n\nLocating and Using a Similar Recipe\n-----------------------------------\n\nBefore writing a recipe from scratch, it is often useful to discover\nwhether someone else has already written one that meets (or comes close\nto meeting) your needs. The Yocto Project and OpenEmbedded communities\nmaintain many recipes that might be candidates for what you are doing.\nYou can find a good central index of these recipes in the\n:oe_layerindex:`OpenEmbedded Layer Index <>`.\n\nWorking from an existing recipe or a skeleton recipe is the best way to\nget started. Here are some points on both methods:\n\n-  *Locate and modify a recipe that is close to what you want to do:*\n   This method works when you are familiar with the current recipe\n   space. The method does not work so well for those new to the Yocto\n   Project or writing recipes.\n\n   Some risks associated with this method are using a recipe that has\n   areas totally unrelated to what you are trying to accomplish with\n   your recipe, not recognizing areas of the recipe that you might have\n   to add from scratch, and so forth. All these risks stem from\n   unfamiliarity with the existing recipe space.\n\n-  *Use and modify the following skeleton recipe:* If for some reason\n   you do not want to use ``recipetool`` and you cannot find an existing\n   recipe that is close to meeting your needs, you can use the following\n   structure to provide the fundamental areas of a new recipe::\n\n      DESCRIPTION = \"\"\n      HOMEPAGE = \"\"\n      LICENSE = \"\"\n      SECTION = \"\"\n      DEPENDS = \"\"\n      LIC_FILES_CHKSUM = \"\"\n\n      SRC_URI = \"\"\n\nStoring and Naming the Recipe\n=============================\n\nOnce you have your base recipe, you should put it in your own layer and\nname it appropriately. Locating it correctly ensures that the\nOpenEmbedded build system can find it when you use BitBake to process\nthe recipe.\n\n-  *Storing Your Recipe:* The OpenEmbedded build system locates your\n   recipe through the layer's ``conf/layer.conf`` file and the\n   :term:`BBFILES` variable. This\n   variable sets up a path from which the build system can locate\n   recipes. Here is the typical use::\n\n      BBFILES += \"${LAYERDIR}/recipes-*/*/*.bb \\\n                  ${LAYERDIR}/recipes-*/*/*.bbappend\"\n\n   Consequently, you need to be sure you locate your new recipe inside\n   your layer such that it can be found.\n\n   You can find more information on how layers are structured in the\n   \":ref:`dev-manual/layers:understanding and creating layers`\" section.\n\n-  *Naming Your Recipe:* When you name your recipe, you need to follow\n   this naming convention::\n\n      basename_version.bb\n\n   Use lower-cased characters and do not include the reserved suffixes\n   ``-native``, ``-cross``, ``-initial``, or ``-dev`` casually (i.e. do not use\n   them as part of your recipe name unless the string applies). Here are some\n   examples:\n\n   .. code-block:: none\n\n      cups_1.7.0.bb\n      gawk_4.0.2.bb\n      irssi_0.8.16-rc1.bb\n\nRunning a Build on the Recipe\n=============================\n"}
{"text": "\n\nWriting a New Recipe\n\nCreating a new recipe is usually an iterative process that requires\nusing BitBake to process the recipe multiple times in order to\nprogressively discover and add information to the recipe file.\n\nAssuming you have sourced the build environment setup script (i.e.\n:ref:`structure-core-script`) and you are in the :term:`Build Directory`, use\nBitBake to process your recipe. All you need to provide is the\n``basename`` of the recipe as described in the previous section::\n\n   $ bitbake basename\n\nDuring the build, the OpenEmbedded build system creates a temporary work\ndirectory for each recipe\n(``${``\\ :term:`WORKDIR`\\ ``}``)\nwhere it keeps extracted source files, log files, intermediate\ncompilation and packaging files, and so forth.\n\nThe path to the per-recipe temporary work directory depends on the\ncontext in which it is being built. The quickest way to find this path\nis to have BitBake return it by running the following::\n\n   $ bitbake -e basename | grep ^WORKDIR=\n\nAs an example, assume a Source Directory\ntop-level folder named ``poky``, a default :term:`Build Directory` at\n``poky/build``, and a ``qemux86-poky-linux`` machine target system.\nFurthermore, suppose your recipe is named ``foo_1.3.0.bb``. In this\ncase, the work directory the build system uses to build the package\nwould be as follows::\n\n   poky/build/tmp/work/qemux86-poky-linux/foo/1.3.0-r0\n\nInside this directory you can find sub-directories such as ``image``,\n``packages-split``, and ``temp``. After the build, you can examine these\nto determine how well the build went.\n\n.. note::\n\n   You can find log files for each task in the recipe's ``temp``\n   directory (e.g. ``poky/build/tmp/work/qemux86-poky-linux/foo/1.3.0-r0/temp``).\n   Log files are named ``log.taskname`` (e.g. ``log.do_configure``,\n   ``log.do_fetch``, and ``log.do_compile``).\n\nYou can find more information about the build process in\n\":doc:`/overview-manual/development-environment`\"\nchapter of the Yocto Project Overview and Concepts Manual.\n\nFetching Code\n=============\n\nThe first thing your recipe must do is specify how to fetch the source\nfiles. Fetching is controlled mainly through the\n:term:`SRC_URI` variable. Your recipe\nmust have a :term:`SRC_URI` variable that points to where the source is\nlocated. For a graphical representation of source locations, see the\n\":ref:`overview-manual/concepts:sources`\" section in\nthe Yocto Project Overview and Concepts Manual.\n\nThe :ref:`ref-tasks-fetch` task uses the prefix of each entry in the\n:term:`SRC_URI` variable value to determine which\n:ref:`fetcher <bitbake-user-manual/bitbake-user-manual-fetching:fetchers>`\nto use to get your source files. It is the :term:`SRC_URI` variable that triggers\nthe fetcher. The :ref:`ref-tasks-patch` task uses the variable after source is\nfetched to apply patches. The OpenEmbedded build system uses\n:term:`FILESOVERRIDES` for scanning directory locations for local files in\n:term:`SRC_URI`.\n\nThe :term:`SRC_URI` variable in your recipe must define each unique location\nfor your source files. It is good practice to not hard-code version\nnumbers in a URL used in :term:`SRC_URI`. Rather than hard-code these\nvalues, use ``${``\\ :term:`PV`\\ ``}``,\nwhich causes the fetch process to use the version specified in the\nrecipe filename. Specifying the version in this manner means that\nupgrading the recipe to a future version is as simple as renaming the\nrecipe to match the new version.\n\nHere is a simple example from the\n``meta/recipes-devtools/strace/strace_5.5.bb`` recipe where the source\ncomes from a single tarball. Notice the use of the\n:term:`PV` variable::\n\n   SRC_URI = \"https://strace.io/files/${PV}/strace-${PV}.tar.xz \\\n\nFiles mentioned in :term:`SRC_URI` whose names end in a typical archive\nextension (e.g. ``.tar``, ``.tar.gz``, ``.tar.bz2``, ``.zip``, and so\nforth), are automatically extracted during the\n:ref:`ref-tasks-unpack` task. For\nanother example that specifies these types of files, see the\n\":ref:`dev-manual/new-recipe:building an autotooled package`\" section.\n\nAnother way of specifying source is from an SCM. For Git repositories,\nyou must specify :term:`SRCREV` and you should specify :term:`PV` to include\nthe revision with :term:`SRCPV`. Here is an example from the recipe\n``meta/recipes-core/musl/gcompat_git.bb``::\n\n   SRC_URI = \"git://git.adelielinux.org/adelie/gcompat.git;protocol=https;branch=current\"\n\n   PV = \"1.0.0+1.1+git${SRCPV}\"\n   SRCREV = \"af5a49e489fdc04b9cf02547650d7aeaccd43793\"\n"}
{"text": "\n\nWriting a New Recipe\n\nIf your :term:`SRC_URI` statement includes URLs pointing to individual files\nfetched from a remote server other than a version control system,\nBitBake attempts to verify the files against checksums defined in your\nrecipe to ensure they have not been tampered with or otherwise modified\nsince the recipe was written. Multiple checksums are supported:\n``SRC_URI[md5sum]``, ``SRC_URI[sha1sum]``, ``SRC_URI[sha256sum]``.\n``SRC_URI[sha384sum]`` and ``SRC_URI[sha512sum]``, but only\n``SRC_URI[sha256sum]`` is commonly used.\n\n.. note::\n\n   ``SRC_URI[md5sum]`` used to also be commonly used, but it is deprecated\n   and should be replaced by ``SRC_URI[sha256sum]`` when updating existing\n   recipes.\n\nIf your :term:`SRC_URI` variable points to more than a single URL (excluding\nSCM URLs), you need to provide the ``sha256`` checksum for each URL. For these\ncases, you provide a name for each URL as part of the :term:`SRC_URI` and then\nreference that name in the subsequent checksum statements. Here is an example\ncombining lines from the files ``git.inc`` and ``git_2.24.1.bb``::\n\n   SRC_URI = \"${KERNELORG_MIRROR}/software/scm/git/git-${PV}.tar.gz;name=tarball \\\n              ${KERNELORG_MIRROR}/software/scm/git/git-manpages-${PV}.tar.gz;name=manpages\"\n\n   SRC_URI[tarball.sha256sum] = \"ad5334956301c86841eb1e5b1bb20884a6bad89a10a6762c958220c7cf64da02\"\n   SRC_URI[manpages.sha256sum] = \"9a7ae3a093bea39770eb96ca3e5b40bff7af0b9f6123f089d7821d0e5b8e1230\"\n\nThe proper value for the ``sha256`` checksum might be available together\nwith other signatures on the download page for the upstream source (e.g.\n``md5``, ``sha1``, ``sha256``, ``GPG``, and so forth). Because the\nOpenEmbedded build system typically only deals with ``sha256sum``,\nyou should verify all the signatures you find by hand.\n\nIf no :term:`SRC_URI` checksums are specified when you attempt to build the\nrecipe, or you provide an incorrect checksum, the build will produce an\nerror for each missing or incorrect checksum. As part of the error\nmessage, the build system provides the checksum string corresponding to\nthe fetched file. Once you have the correct checksums, you can copy and\npaste them into your recipe and then run the build again to continue.\n\n.. note::\n\n   As mentioned, if the upstream source provides signatures for\n   verifying the downloaded source code, you should verify those\n   manually before setting the checksum values in the recipe and\n   continuing with the build.\n\nThis final example is a bit more complicated and is from the\n``meta/recipes-sato/rxvt-unicode/rxvt-unicode_9.20.bb`` recipe. The\nexample's :term:`SRC_URI` statement identifies multiple files as the source\nfiles for the recipe: a tarball, a patch file, a desktop file, and an icon::\n\n   SRC_URI = \"http://dist.schmorp.de/rxvt-unicode/Attic/rxvt-unicode-${PV}.tar.bz2 \\\n              file://xwc.patch \\\n              file://rxvt.desktop \\\n              file://rxvt.png\"\n\nWhen you specify local files using the ``file://`` URI protocol, the\nbuild system fetches files from the local machine. The path is relative\nto the :term:`FILESPATH` variable\nand searches specific directories in a certain order:\n``${``\\ :term:`BP`\\ ``}``,\n``${``\\ :term:`BPN`\\ ``}``, and\n``files``. The directories are assumed to be subdirectories of the\ndirectory in which the recipe or append file resides. For another\nexample that specifies these types of files, see the\n\"`building a single .c file package`_\" section.\n\nThe previous example also specifies a patch file. Patch files are files\nwhose names usually end in ``.patch`` or ``.diff`` but can end with\ncompressed suffixes such as ``diff.gz`` and ``patch.bz2``, for example.\nThe build system automatically applies patches as described in the\n\":ref:`dev-manual/new-recipe:patching code`\" section.\n\nFetching Code Through Firewalls\n-------------------------------\n\nSome users are behind firewalls and need to fetch code through a proxy.\nSee the \":doc:`/ref-manual/faq`\" chapter for advice.\n\nLimiting the Number of Parallel Connections\n-------------------------------------------\n\nSome users are behind firewalls or use servers where the number of parallel\nconnections is limited. In such cases, you can limit the number of fetch\ntasks being run in parallel by adding the following to your ``local.conf``\nfile::\n\n   do_fetch[number_threads] = \"4\"\n\nUnpacking Code\n==============\n\nDuring the build, the\n:ref:`ref-tasks-unpack` task unpacks\nthe source with ``${``\\ :term:`S`\\ ``}``\npointing to where it is unpacked.\n\nIf you are fetching your source files from an upstream source archived\n"}
{"text": "\n\nWriting a New Recipe\ntarball and the tarball's internal structure matches the common\nconvention of a top-level subdirectory named\n``${``\\ :term:`BPN`\\ ``}-${``\\ :term:`PV`\\ ``}``,\nthen you do not need to set :term:`S`. However, if :term:`SRC_URI` specifies to\nfetch source from an archive that does not use this convention, or from\nan SCM like Git or Subversion, your recipe needs to define :term:`S`.\n\nIf processing your recipe using BitBake successfully unpacks the source\nfiles, you need to be sure that the directory pointed to by ``${S}``\nmatches the structure of the source.\n\nPatching Code\n=============\n\nSometimes it is necessary to patch code after it has been fetched. Any\nfiles mentioned in :term:`SRC_URI` whose names end in ``.patch`` or\n``.diff`` or compressed versions of these suffixes (e.g. ``diff.gz``,\n``patch.bz2``, etc.) are treated as patches. The\n:ref:`ref-tasks-patch` task\nautomatically applies these patches.\n\nThe build system should be able to apply patches with the \"-p1\" option\n(i.e. one directory level in the path will be stripped off). If your\npatch needs to have more directory levels stripped off, specify the\nnumber of levels using the \"striplevel\" option in the :term:`SRC_URI` entry\nfor the patch. Alternatively, if your patch needs to be applied in a\nspecific subdirectory that is not specified in the patch file, use the\n\"patchdir\" option in the entry.\n\nAs with all local files referenced in\n:term:`SRC_URI` using ``file://``,\nyou should place patch files in a directory next to the recipe either\nnamed the same as the base name of the recipe\n(:term:`BP` and\n:term:`BPN`) or \"files\".\n\nLicensing\n=========\n\nYour recipe needs to define variables related to the license\nunder whith the software is distributed. See the\n:ref:`contributor-guide/recipe-style-guide:recipe license fields`\nsection in the Contributor Guide for details.\n\nDependencies\n============\n\nMost software packages have a short list of other packages that they\nrequire, which are called dependencies. These dependencies fall into two\nmain categories: build-time dependencies, which are required when the\nsoftware is built; and runtime dependencies, which are required to be\ninstalled on the target in order for the software to run.\n\nWithin a recipe, you specify build-time dependencies using the\n:term:`DEPENDS` variable. Although there are nuances,\nitems specified in :term:`DEPENDS` should be names of other\nrecipes. It is important that you specify all build-time dependencies\nexplicitly.\n\nAnother consideration is that configure scripts might automatically\ncheck for optional dependencies and enable corresponding functionality\nif those dependencies are found. If you wish to make a recipe that is\nmore generally useful (e.g. publish the recipe in a layer for others to\nuse), instead of hard-disabling the functionality, you can use the\n:term:`PACKAGECONFIG` variable to allow functionality and the\ncorresponding dependencies to be enabled and disabled easily by other\nusers of the recipe.\n\nSimilar to build-time dependencies, you specify runtime dependencies\nthrough a variable -\n:term:`RDEPENDS`, which is\npackage-specific. All variables that are package-specific need to have\nthe name of the package added to the end as an override. Since the main\npackage for a recipe has the same name as the recipe, and the recipe's\nname can be found through the\n``${``\\ :term:`PN`\\ ``}`` variable, then\nyou specify the dependencies for the main package by setting\n``RDEPENDS:${PN}``. If the package were named ``${PN}-tools``, then you\nwould set ``RDEPENDS:${PN}-tools``, and so forth.\n\nSome runtime dependencies will be set automatically at packaging time.\nThese dependencies include any shared library dependencies (i.e. if a\npackage \"example\" contains \"libexample\" and another package \"mypackage\"\ncontains a binary that links to \"libexample\" then the OpenEmbedded build\nsystem will automatically add a runtime dependency to \"mypackage\" on\n\"example\"). See the\n\":ref:`overview-manual/concepts:automatically added runtime dependencies`\"\nsection in the Yocto Project Overview and Concepts Manual for further\ndetails.\n\nConfiguring the Recipe\n======================\n\nMost software provides some means of setting build-time configuration\noptions before compilation. Typically, setting these options is\naccomplished by running a configure script with options, or by modifying\na build configuration file.\n\n.. note::\n\n"}
{"text": "\n\nWriting a New Recipe\n   As of Yocto Project Release 1.7, some of the core recipes that\n   package binary configuration scripts now disable the scripts due to\n   the scripts previously requiring error-prone path substitution. The\n   OpenEmbedded build system uses ``pkg-config`` now, which is much more\n   robust. You can find a list of the ``*-config`` scripts that are disabled\n   in the \":ref:`migration-1.7-binary-configuration-scripts-disabled`\" section\n   in the Yocto Project Reference Manual.\n\nA major part of build-time configuration is about checking for\nbuild-time dependencies and possibly enabling optional functionality as\na result. You need to specify any build-time dependencies for the\nsoftware you are building in your recipe's\n:term:`DEPENDS` value, in terms of\nother recipes that satisfy those dependencies. You can often find\nbuild-time or runtime dependencies described in the software's\ndocumentation.\n\nThe following list provides configuration items of note based on how\nyour software is built:\n\n-  *Autotools:* If your source files have a ``configure.ac`` file, then\n   your software is built using Autotools. If this is the case, you just\n   need to modify the configuration.\n\n   When using Autotools, your recipe needs to inherit the\n   :ref:`ref-classes-autotools` class and it does not have to\n   contain a :ref:`ref-tasks-configure` task. However, you might still want to\n   make some adjustments. For example, you can set :term:`EXTRA_OECONF` or\n   :term:`PACKAGECONFIG_CONFARGS` to pass any needed configure options that\n   are specific to the recipe.\n\n-  *CMake:* If your source files have a ``CMakeLists.txt`` file, then\n   your software is built using CMake. If this is the case, you just\n   need to modify the configuration.\n\n   When you use CMake, your recipe needs to inherit the\n   :ref:`ref-classes-cmake` class and it does not have to contain a\n   :ref:`ref-tasks-configure` task. You can make some adjustments by setting\n   :term:`EXTRA_OECMAKE` to pass any needed configure options that are\n   specific to the recipe.\n\n   .. note::\n\n      If you need to install one or more custom CMake toolchain files\n      that are supplied by the application you are building, install the\n      files to ``${D}${datadir}/cmake/Modules`` during :ref:`ref-tasks-install`.\n\n-  *Other:* If your source files do not have a ``configure.ac`` or\n   ``CMakeLists.txt`` file, then your software is built using some\n   method other than Autotools or CMake. If this is the case, you\n   normally need to provide a\n   :ref:`ref-tasks-configure` task\n   in your recipe unless, of course, there is nothing to configure.\n\n   Even if your software is not being built by Autotools or CMake, you\n   still might not need to deal with any configuration issues. You need\n   to determine if configuration is even a required step. You might need\n   to modify a Makefile or some configuration file used for the build to\n   specify necessary build options. Or, perhaps you might need to run a\n   provided, custom configure script with the appropriate options.\n\n   For the case involving a custom configure script, you would run\n   ``./configure --help`` and look for the options you need to set.\n\nOnce configuration succeeds, it is always good practice to look at the\n``log.do_configure`` file to ensure that the appropriate options have\nbeen enabled and no additional build-time dependencies need to be added\nto :term:`DEPENDS`. For example, if the configure script reports that it\nfound something not mentioned in :term:`DEPENDS`, or that it did not find\nsomething that it needed for some desired optional functionality, then\nyou would need to add those to :term:`DEPENDS`. Looking at the log might\nalso reveal items being checked for, enabled, or both that you do not\nwant, or items not being found that are in :term:`DEPENDS`, in which case\nyou would need to look at passing extra options to the configure script\nas needed. For reference information on configure options specific to\nthe software you are building, you can consult the output of the\n``./configure --help`` command within ``${S}`` or consult the software's\nupstream documentation.\n\nUsing Headers to Interface with Devices\n=======================================\n\nIf your recipe builds an application that needs to communicate with some\ndevice or needs an API into a custom kernel, you will need to provide\nappropriate header files. Under no circumstances should you ever modify\nthe existing\n``meta/recipes-kernel/linux-libc-headers/linux-libc-headers.inc`` file.\nThese headers are used to build ``libc`` and must not be compromised\nwith custom or machine-specific header information. If you customize\n``libc`` through modified headers all other applications that use\n``libc`` thus become affected.\n\n.. note::\n\n   Never copy and customize the ``libc`` header file (i.e.\n   ``meta/recipes-kernel/linux-libc-headers/linux-libc-headers.inc``).\n\nThe correct way to interface to a device or custom kernel is to use a\nseparate package that provides the additional headers for the driver or\nother unique interfaces. When doing so, your application also becomes\n"}
{"text": "\n\nWriting a New Recipe\nresponsible for creating a dependency on that specific provider.\n\nConsider the following:\n\n-  Never modify ``linux-libc-headers.inc``. Consider that file to be\n   part of the ``libc`` system, and not something you use to access the\n   kernel directly. You should access ``libc`` through specific ``libc``\n   calls.\n\n-  Applications that must talk directly to devices should either provide\n   necessary headers themselves, or establish a dependency on a special\n   headers package that is specific to that driver.\n\nFor example, suppose you want to modify an existing header that adds I/O\ncontrol or network support. If the modifications are used by a small\nnumber programs, providing a unique version of a header is easy and has\nlittle impact. When doing so, bear in mind the guidelines in the\nprevious list.\n\n.. note::\n\n   If for some reason your changes need to modify the behavior of the ``libc``,\n   and subsequently all other applications on the system, use a ``.bbappend``\n   to modify the ``linux-kernel-headers.inc`` file. However, take care to not\n   make the changes machine specific.\n\nConsider a case where your kernel is older and you need an older\n``libc`` ABI. The headers installed by your recipe should still be a\nstandard mainline kernel, not your own custom one.\n\nWhen you use custom kernel headers you need to get them from\n:term:`STAGING_KERNEL_DIR`,\nwhich is the directory with kernel headers that are required to build\nout-of-tree modules. Your recipe will also need the following::\n\n   do_configure[depends] += \"virtual/kernel:do_shared_workdir\"\n\nCompilation\n===========\n\nDuring a build, the :ref:`ref-tasks-compile` task happens after source is fetched,\nunpacked, and configured. If the recipe passes through :ref:`ref-tasks-compile`\nsuccessfully, nothing needs to be done.\n\nHowever, if the compile step fails, you need to diagnose the failure.\nHere are some common issues that cause failures.\n\n.. note::\n\n   For cases where improper paths are detected for configuration files\n   or for when libraries/headers cannot be found, be sure you are using\n   the more robust ``pkg-config``. See the note in section\n   \":ref:`dev-manual/new-recipe:Configuring the Recipe`\" for additional information.\n\n-  *Parallel build failures:* These failures manifest themselves as\n   intermittent errors, or errors reporting that a file or directory\n   that should be created by some other part of the build process could\n   not be found. This type of failure can occur even if, upon\n   inspection, the file or directory does exist after the build has\n   failed, because that part of the build process happened in the wrong\n   order.\n\n   To fix the problem, you need to either satisfy the missing dependency\n   in the Makefile or whatever script produced the Makefile, or (as a\n   workaround) set :term:`PARALLEL_MAKE` to an empty string::\n\n      PARALLEL_MAKE = \"\"\n\n   For information on parallel Makefile issues, see the\n   \":ref:`dev-manual/debugging:debugging parallel make races`\" section.\n\n-  *Improper host path usage:* This failure applies to recipes building\n   for the target or \":ref:`ref-classes-nativesdk`\" only. The\n   failure occurs when the compilation process uses improper headers,\n   libraries, or other files from the host system when cross-compiling for\n   the target.\n\n   To fix the problem, examine the ``log.do_compile`` file to identify\n   the host paths being used (e.g. ``/usr/include``, ``/usr/lib``, and\n   so forth) and then either add configure options, apply a patch, or do\n   both.\n\n-  *Failure to find required libraries/headers:* If a build-time\n   dependency is missing because it has not been declared in\n   :term:`DEPENDS`, or because the\n   dependency exists but the path used by the build process to find the\n   file is incorrect and the configure step did not detect it, the\n   compilation process could fail. For either of these failures, the\n   compilation process notes that files could not be found. In these\n   cases, you need to go back and add additional options to the\n   configure script as well as possibly add additional build-time\n   dependencies to :term:`DEPENDS`.\n\n   Occasionally, it is necessary to apply a patch to the source to\n   ensure the correct paths are used. If you need to specify paths to\n   find files staged into the sysroot from other recipes, use the\n   variables that the OpenEmbedded build system provides (e.g.\n   :term:`STAGING_BINDIR`, :term:`STAGING_INCDIR`, :term:`STAGING_DATADIR`, and so\n   forth).\n\n"}
{"text": "\n\nWriting a New Recipe\nInstalling\n==========\n\nDuring :ref:`ref-tasks-install`, the task copies the built files along with their\nhierarchy to locations that would mirror their locations on the target\ndevice. The installation process copies files from the\n``${``\\ :term:`S`\\ ``}``,\n``${``\\ :term:`B`\\ ``}``, and\n``${``\\ :term:`WORKDIR`\\ ``}``\ndirectories to the ``${``\\ :term:`D`\\ ``}``\ndirectory to create the structure as it should appear on the target\nsystem.\n\nHow your software is built affects what you must do to be sure your\nsoftware is installed correctly. The following list describes what you\nmust do for installation depending on the type of build system used by\nthe software being built:\n\n-  *Autotools and CMake:* If the software your recipe is building uses\n   Autotools or CMake, the OpenEmbedded build system understands how to\n   install the software. Consequently, you do not have to have a\n   :ref:`ref-tasks-install` task as part of your recipe. You just need to make\n   sure the install portion of the build completes with no issues.\n   However, if you wish to install additional files not already being\n   installed by ``make install``, you should do this using a\n   ``do_install:append`` function using the install command as described\n   in the \"Manual\" bulleted item later in this list.\n\n-  *Other (using* ``make install``\\ *)*: You need to define a :ref:`ref-tasks-install`\n   function in your recipe. The function should call\n   ``oe_runmake install`` and will likely need to pass in the\n   destination directory as well. How you pass that path is dependent on\n   how the ``Makefile`` being run is written (e.g. ``DESTDIR=${D}``,\n   ``PREFIX=${D}``, ``INSTALLROOT=${D}``, and so forth).\n\n   For an example recipe using ``make install``, see the\n   \":ref:`dev-manual/new-recipe:building a makefile-based package`\" section.\n\n-  *Manual:* You need to define a :ref:`ref-tasks-install` function in your\n   recipe. The function must first use ``install -d`` to create the\n   directories under\n   ``${``\\ :term:`D`\\ ``}``. Once the\n   directories exist, your function can use ``install`` to manually\n   install the built software into the directories.\n\n   You can find more information on ``install`` at\n   https://www.gnu.org/software/coreutils/manual/html_node/install-invocation.html.\n\nFor the scenarios that do not use Autotools or CMake, you need to track\nthe installation and diagnose and fix any issues until everything\ninstalls correctly. You need to look in the default location of\n``${D}``, which is ``${WORKDIR}/image``, to be sure your files have been\ninstalled correctly.\n\n.. note::\n\n   -  During the installation process, you might need to modify some of\n      the installed files to suit the target layout. For example, you\n      might need to replace hard-coded paths in an initscript with\n      values of variables provided by the build system, such as\n      replacing ``/usr/bin/`` with ``${bindir}``. If you do perform such\n      modifications during :ref:`ref-tasks-install`, be sure to modify the\n      destination file after copying rather than before copying.\n      Modifying after copying ensures that the build system can\n      re-execute :ref:`ref-tasks-install` if needed.\n\n   -  ``oe_runmake install``, which can be run directly or can be run\n      indirectly by the :ref:`ref-classes-autotools` and\n      :ref:`ref-classes-cmake` classes, runs ``make install`` in parallel.\n      Sometimes, a Makefile can have missing dependencies between targets that\n      can result in race conditions. If you experience intermittent failures\n      during :ref:`ref-tasks-install`, you might be able to work around them by\n      disabling parallel Makefile installs by adding the following to the\n      recipe::\n\n         PARALLEL_MAKEINST = \"\"\n\n      See :term:`PARALLEL_MAKEINST` for additional information.\n\n   -  If you need to install one or more custom CMake toolchain files\n      that are supplied by the application you are building, install the\n      files to ``${D}${datadir}/cmake/Modules`` during\n      :ref:`ref-tasks-install`.\n\nEnabling System Services\n========================\n\nIf you want to install a service, which is a process that usually starts\non boot and runs in the background, then you must include some\nadditional definitions in your recipe.\n\nIf you are adding services and the service initialization script or the\nservice file itself is not installed, you must provide for that\ninstallation in your recipe using a ``do_install:append`` function. If\nyour recipe already has a :ref:`ref-tasks-install` function, update the function\nnear its end rather than adding an additional ``do_install:append``\nfunction.\n\nWhen you create the installation for your services, you need to\naccomplish what is normally done by ``make install``. In other words,\n"}
{"text": "\n\nWriting a New Recipe\nmake sure your installation arranges the output similar to how it is\narranged on the target system.\n\nThe OpenEmbedded build system provides support for starting services two\ndifferent ways:\n\n-  *SysVinit:* SysVinit is a system and service manager that manages the\n   init system used to control the very basic functions of your system.\n   The init program is the first program started by the Linux kernel\n   when the system boots. Init then controls the startup, running and\n   shutdown of all other programs.\n\n   To enable a service using SysVinit, your recipe needs to inherit the\n   :ref:`ref-classes-update-rc.d` class. The class helps\n   facilitate safely installing the package on the target.\n\n   You will need to set the\n   :term:`INITSCRIPT_PACKAGES`,\n   :term:`INITSCRIPT_NAME`,\n   and\n   :term:`INITSCRIPT_PARAMS`\n   variables within your recipe.\n\n-  *systemd:* System Management Daemon (systemd) was designed to replace\n   SysVinit and to provide enhanced management of services. For more\n   information on systemd, see the systemd homepage at\n   https://freedesktop.org/wiki/Software/systemd/.\n\n   To enable a service using systemd, your recipe needs to inherit the\n   :ref:`ref-classes-systemd` class. See the ``systemd.bbclass`` file\n   located in your :term:`Source Directory` section for more information.\n\nPackaging\n=========\n\nSuccessful packaging is a combination of automated processes performed\nby the OpenEmbedded build system and some specific steps you need to\ntake. The following list describes the process:\n\n-  *Splitting Files*: The :ref:`ref-tasks-package` task splits the files produced\n   by the recipe into logical components. Even software that produces a\n   single binary might still have debug symbols, documentation, and\n   other logical components that should be split out. The :ref:`ref-tasks-package`\n   task ensures that files are split up and packaged correctly.\n\n-  *Running QA Checks*: The :ref:`ref-classes-insane` class adds a\n   step to the package generation process so that output quality\n   assurance checks are generated by the OpenEmbedded build system. This\n   step performs a range of checks to be sure the build's output is free\n   of common problems that show up during runtime. For information on\n   these checks, see the :ref:`ref-classes-insane` class and\n   the \":ref:`ref-manual/qa-checks:qa error and warning messages`\"\n   chapter in the Yocto Project Reference Manual.\n\n-  *Hand-Checking Your Packages*: After you build your software, you\n   need to be sure your packages are correct. Examine the\n   ``${``\\ :term:`WORKDIR`\\ ``}/packages-split``\n   directory and make sure files are where you expect them to be. If you\n   discover problems, you can set\n   :term:`PACKAGES`,\n   :term:`FILES`,\n   ``do_install(:append)``, and so forth as needed.\n\n-  *Splitting an Application into Multiple Packages*: If you need to\n   split an application into several packages, see the\n   \":ref:`dev-manual/new-recipe:splitting an application into multiple packages`\"\n   section for an example.\n\n-  *Installing a Post-Installation Script*: For an example showing how\n   to install a post-installation script, see the\n   \":ref:`dev-manual/new-recipe:post-installation scripts`\" section.\n\n-  *Marking Package Architecture*: Depending on what your recipe is\n   building and how it is configured, it might be important to mark the\n   packages produced as being specific to a particular machine, or to\n   mark them as not being specific to a particular machine or\n   architecture at all.\n\n   By default, packages apply to any machine with the same architecture\n   as the target machine. When a recipe produces packages that are\n   machine-specific (e.g. the\n   :term:`MACHINE` value is passed\n   into the configure script or a patch is applied only for a particular\n   machine), you should mark them as such by adding the following to the\n   recipe::\n\n      PACKAGE_ARCH = \"${MACHINE_ARCH}\"\n\n   On the other hand, if the recipe produces packages that do not\n   contain anything specific to the target machine or architecture at\n   all (e.g. recipes that simply package script files or configuration\n   files), you should use the :ref:`ref-classes-allarch` class to\n   do this for you by adding this to your recipe::\n\n      inherit allarch\n\n   Ensuring that the package architecture is correct is not critical\n   while you are doing the first few builds of your recipe. However, it\n   is important in order to ensure that your recipe rebuilds (or does\n   not rebuild) appropriately in response to changes in configuration,\n"}
{"text": "\n\nWriting a New Recipe\n   and to ensure that you get the appropriate packages installed on the\n   target machine, particularly if you run separate builds for more than\n   one target machine.\n\nSharing Files Between Recipes\n=============================\n\nRecipes often need to use files provided by other recipes on the build\nhost. For example, an application linking to a common library needs\naccess to the library itself and its associated headers. The way this\naccess is accomplished is by populating a sysroot with files. Each\nrecipe has two sysroots in its work directory, one for target files\n(``recipe-sysroot``) and one for files that are native to the build host\n(``recipe-sysroot-native``).\n\n.. note::\n\n   You could find the term \"staging\" used within the Yocto project\n   regarding files populating sysroots (e.g. the :term:`STAGING_DIR`\n   variable).\n\nRecipes should never populate the sysroot directly (i.e. write files\ninto sysroot). Instead, files should be installed into standard\nlocations during the\n:ref:`ref-tasks-install` task within\nthe ``${``\\ :term:`D`\\ ``}`` directory. The\nreason for this limitation is that almost all files that populate the\nsysroot are cataloged in manifests in order to ensure the files can be\nremoved later when a recipe is either modified or removed. Thus, the\nsysroot is able to remain free from stale files.\n\nA subset of the files installed by the :ref:`ref-tasks-install` task are\nused by the :ref:`ref-tasks-populate_sysroot` task as defined by the\n:term:`SYSROOT_DIRS` variable to automatically populate the sysroot. It\nis possible to modify the list of directories that populate the sysroot.\nThe following example shows how you could add the ``/opt`` directory to\nthe list of directories within a recipe::\n\n   SYSROOT_DIRS += \"/opt\"\n\n.. note::\n\n   The `/sysroot-only` is to be used by recipes that generate artifacts\n   that are not included in the target filesystem, allowing them to share\n   these artifacts without needing to use the :term:`DEPLOY_DIR`.\n\nFor a more complete description of the :ref:`ref-tasks-populate_sysroot`\ntask and its associated functions, see the\n:ref:`staging <ref-classes-staging>` class.\n\nUsing Virtual Providers\n=======================\n\nPrior to a build, if you know that several different recipes provide the\nsame functionality, you can use a virtual provider (i.e. ``virtual/*``)\nas a placeholder for the actual provider. The actual provider is\ndetermined at build-time.\n\nA common scenario where a virtual provider is used would be for the kernel\nrecipe. Suppose you have three kernel recipes whose :term:`PN` values map to\n``kernel-big``, ``kernel-mid``, and ``kernel-small``. Furthermore, each of\nthese recipes in some way uses a :term:`PROVIDES` statement that essentially\nidentifies itself as being able to provide ``virtual/kernel``. Here is one way\nthrough the :ref:`ref-classes-kernel` class::\n\n   PROVIDES += \"virtual/kernel\"\n\nAny recipe that inherits the :ref:`ref-classes-kernel` class is\ngoing to utilize a :term:`PROVIDES` statement that identifies that recipe as\nbeing able to provide the ``virtual/kernel`` item.\n\nNow comes the time to actually build an image and you need a kernel\nrecipe, but which one? You can configure your build to call out the\nkernel recipe you want by using the :term:`PREFERRED_PROVIDER` variable. As\nan example, consider the :yocto_git:`x86-base.inc\n</poky/tree/meta/conf/machine/include/x86/x86-base.inc>` include file, which is a\nmachine (i.e. :term:`MACHINE`) configuration file. This include file is the\nreason all x86-based machines use the ``linux-yocto`` kernel. Here are the\nrelevant lines from the include file::\n\n   PREFERRED_PROVIDER_virtual/kernel ??= \"linux-yocto\"\n   PREFERRED_VERSION_linux-yocto ??= \"4.15%\"\n\nWhen you use a virtual provider, you do not have to \"hard code\" a recipe\nname as a build dependency. You can use the\n:term:`DEPENDS` variable to state the\nbuild is dependent on ``virtual/kernel`` for example::\n\n   DEPENDS = \"virtual/kernel\"\n\nDuring the build, the OpenEmbedded build system picks\nthe correct recipe needed for the ``virtual/kernel`` dependency based on\nthe :term:`PREFERRED_PROVIDER` variable. If you want to use the small kernel\nmentioned at the beginning of this section, configure your build as\nfollows::\n\n   PREFERRED_PROVIDER_virtual/kernel ??= \"kernel-small\"\n\n.. note::\n\n"}
{"text": "\n\nWriting a New Recipe\n   Any recipe that :term:`PROVIDES` a ``virtual/*`` item that is ultimately not\n   selected through :term:`PREFERRED_PROVIDER` does not get built. Preventing these\n   recipes from building is usually the desired behavior since this mechanism's\n   purpose is to select between mutually exclusive alternative providers.\n\nThe following lists specific examples of virtual providers:\n\n-  ``virtual/kernel``: Provides the name of the kernel recipe to use\n   when building a kernel image.\n\n-  ``virtual/bootloader``: Provides the name of the bootloader to use\n   when building an image.\n\n-  ``virtual/libgbm``: Provides ``gbm.pc``.\n\n-  ``virtual/egl``: Provides ``egl.pc`` and possibly ``wayland-egl.pc``.\n\n-  ``virtual/libgl``: Provides ``gl.pc`` (i.e. libGL).\n\n-  ``virtual/libgles1``: Provides ``glesv1_cm.pc`` (i.e. libGLESv1_CM).\n\n-  ``virtual/libgles2``: Provides ``glesv2.pc`` (i.e. libGLESv2).\n\n.. note::\n\n   Virtual providers only apply to build time dependencies specified with\n   :term:`PROVIDES` and :term:`DEPENDS`. They do not apply to runtime\n   dependencies specified with :term:`RPROVIDES` and :term:`RDEPENDS`.\n\nProperly Versioning Pre-Release Recipes\n=======================================\n\nSometimes the name of a recipe can lead to versioning problems when the\nrecipe is upgraded to a final release. For example, consider the\n``irssi_0.8.16-rc1.bb`` recipe file in the list of example recipes in\nthe \":ref:`dev-manual/new-recipe:storing and naming the recipe`\" section.\nThis recipe is at a release candidate stage (i.e. \"rc1\"). When the recipe is\nreleased, the recipe filename becomes ``irssi_0.8.16.bb``. The version\nchange from ``0.8.16-rc1`` to ``0.8.16`` is seen as a decrease by the\nbuild system and package managers, so the resulting packages will not\ncorrectly trigger an upgrade.\n\nIn order to ensure the versions compare properly, the recommended\nconvention is to use a tilde (``~``) character as follows::\n\n  PV = 0.8.16~rc1\n\nThis way ``0.8.16~rc1`` sorts before ``0.8.16``. See the\n\":ref:`contributor-guide/recipe-style-guide:version policy`\" section in the\nYocto Project and OpenEmbedded Contributor Guide for more details about\nversioning code corresponding to a pre-release or to a specific Git commit.\n\nPost-Installation Scripts\n=========================\n\nPost-installation scripts run immediately after installing a package on\nthe target or during image creation when a package is included in an\nimage. To add a post-installation script to a package, add a\n``pkg_postinst:``\\ `PACKAGENAME`\\ ``()`` function to the recipe file\n(``.bb``) and replace `PACKAGENAME` with the name of the package you want\nto attach to the ``postinst`` script. To apply the post-installation\nscript to the main package for the recipe, which is usually what is\nrequired, specify\n``${``\\ :term:`PN`\\ ``}`` in place of\nPACKAGENAME.\n\nA post-installation function has the following structure::\n\n   pkg_postinst:PACKAGENAME() {\n       # Commands to carry out\n   }\n\nThe script defined in the post-installation function is called when the\nroot filesystem is created. If the script succeeds, the package is\nmarked as installed.\n\n.. note::\n\n   Any RPM post-installation script that runs on the target should\n   return a 0 exit code. RPM does not allow non-zero exit codes for\n   these scripts, and the RPM package manager will cause the package to\n   fail installation on the target.\n\nSometimes it is necessary for the execution of a post-installation\nscript to be delayed until the first boot. For example, the script might\nneed to be executed on the device itself. To delay script execution\nuntil boot time, you must explicitly mark post installs to defer to the\ntarget. You can use ``pkg_postinst_ontarget()`` or call\n``postinst_intercept delay_to_first_boot`` from ``pkg_postinst()``. Any\nfailure of a ``pkg_postinst()`` script (including exit 1) triggers an\nerror during the\n:ref:`ref-tasks-rootfs` task.\n\nIf you have recipes that use ``pkg_postinst`` function and they require\nthe use of non-standard native tools that have dependencies during\nroot filesystem construction, you need to use the\n:term:`PACKAGE_WRITE_DEPS`\nvariable in your recipe to list these tools. If you do not use this\nvariable, the tools might be missing and execution of the\npost-installation script is deferred until first boot. Deferring the\n"}
{"text": "\n\nWriting a New Recipe\nscript to the first boot is undesirable and impossible for read-only\nroot filesystems.\n\n.. note::\n\n   There is equivalent support for pre-install, pre-uninstall, and post-uninstall\n   scripts by way of ``pkg_preinst``, ``pkg_prerm``, and ``pkg_postrm``,\n   respectively. These scrips work in exactly the same way as does\n   ``pkg_postinst`` with the exception that they run at different times. Also,\n   because of when they run, they are not applicable to being run at image\n   creation time like ``pkg_postinst``.\n\nTesting\n=======\n\nThe final step for completing your recipe is to be sure that the\nsoftware you built runs correctly. To accomplish runtime testing, add\nthe build's output packages to your image and test them on the target.\n\nFor information on how to customize your image by adding specific\npackages, see \":ref:`dev-manual/customizing-images:customizing images`\" section.\n\nExamples\n========\n\nTo help summarize how to write a recipe, this section provides some\nrecipe examples given various scenarios:\n\n-  `Building a single .c file package`_\n\n-  `Building a Makefile-based package`_\n\n-  `Building an Autotooled package`_\n\n-  `Building a Meson package`_\n\n-  `Splitting an application into multiple packages`_\n\n-  `Packaging externally produced binaries`_\n\nBuilding a Single .c File Package\n---------------------------------\n\nBuilding an application from a single file that is stored locally (e.g. under\n``files``) requires a recipe that has the file listed in the :term:`SRC_URI`\nvariable. Additionally, you need to manually write the :ref:`ref-tasks-compile`\nand :ref:`ref-tasks-install` tasks. The :term:`S` variable defines the\ndirectory containing the source code, which is set to :term:`WORKDIR` in this\ncase --- the directory BitBake uses for the build::\n\n   SUMMARY = \"Simple helloworld application\"\n   SECTION = \"examples\"\n   LICENSE = \"MIT\"\n   LIC_FILES_CHKSUM = \"file://${COMMON_LICENSE_DIR}/MIT;md5=0835ade698e0bcf8506ecda2f7b4f302\"\n\n   SRC_URI = \"file://helloworld.c\"\n\n   S = \"${WORKDIR}\"\n\n   do_compile() {\n       ${CC} ${LDFLAGS} helloworld.c -o helloworld\n   }\n\n   do_install() {\n       install -d ${D}${bindir}\n       install -m 0755 helloworld ${D}${bindir}\n   }\n\nBy default, the ``helloworld``, ``helloworld-dbg``, and ``helloworld-dev`` packages\nare built. For information on how to customize the packaging process, see the\n\":ref:`dev-manual/new-recipe:splitting an application into multiple packages`\"\nsection.\n\nBuilding a Makefile-Based Package\n---------------------------------\n\nApplications built with GNU ``make`` require a recipe that has the source archive\nlisted in :term:`SRC_URI`. You do not need to add a :ref:`ref-tasks-compile`\nstep since by default BitBake starts the ``make`` command to compile the\napplication. If you need additional ``make`` options, you should store them in\nthe :term:`EXTRA_OEMAKE` or :term:`PACKAGECONFIG_CONFARGS` variables. BitBake\npasses these options into the GNU ``make`` invocation. Note that a\n:ref:`ref-tasks-install` task is still required. Otherwise, BitBake runs an\nempty :ref:`ref-tasks-install` task by default.\n\nSome applications might require extra parameters to be passed to the\ncompiler. For example, the application might need an additional header\npath. You can accomplish this by adding to the :term:`CFLAGS` variable. The\nfollowing example shows this::\n\n   CFLAGS:prepend = \"-I ${S}/include \"\n\nIn the following example, ``lz4`` is a makefile-based package::\n\n   SUMMARY = \"Extremely Fast Compression algorithm\"\n   DESCRIPTION = \"LZ4 is a very fast lossless compression algorithm, providing compression speed at 400 MB/s per core, scalable with multi-cores CPU. It also features an extremely fast decoder, with speed in multiple GB/s per core, typically reaching RAM speed limits on multi-core systems.\"\n   HOMEPAGE = \"https://github.com/lz4/lz4\"\n\n   LICENSE = \"BSD-2-Clause | GPL-2.0-only\"\n   LIC_FILES_CHKSUM = \"file://lib/LICENSE;md5=ebc2ea4814a64de7708f1571904b32cc \\\n"}
{"text": "\n\nWriting a New Recipe\n                       file://programs/COPYING;md5=b234ee4d69f5fce4486a80fdaf4a4263 \\\n                       file://LICENSE;md5=d57c0d21cb917fb4e0af2454aa48b956 \\\n                       \"\n\n   PE = \"1\"\n\n   SRCREV = \"d44371841a2f1728a3f36839fd4b7e872d0927d3\"\n\n   SRC_URI = \"git://github.com/lz4/lz4.git;branch=release;protocol=https \\\n              file://CVE-2021-3520.patch \\\n              \"\n   UPSTREAM_CHECK_GITTAGREGEX = \"v(?P<pver>.*)\"\n\n   S = \"${WORKDIR}/git\"\n\n   CVE_STATUS[CVE-2014-4715] = \"fixed-version: Fixed in r118, which is larger than the current version\"\n\n   EXTRA_OEMAKE = \"PREFIX=${prefix} CC='${CC}' CFLAGS='${CFLAGS}' DESTDIR=${D} LIBDIR=${libdir} INCLUDEDIR=${includedir} BUILD_STATIC=no\"\n\n   do_install() {\n           oe_runmake install\n   }\n\n   BBCLASSEXTEND = \"native nativesdk\"\n\nBuilding an Autotooled Package\n------------------------------\n\nApplications built with the Autotools such as ``autoconf`` and ``automake``\nrequire a recipe that has a source archive listed in :term:`SRC_URI` and also\ninherit the :ref:`ref-classes-autotools` class, which contains the definitions\nof all the steps needed to build an Autotool-based application. The result of\nthe build is automatically packaged. And, if the application uses NLS for\nlocalization, packages with local information are generated (one package per\nlanguage). Following is one example: (``hello_2.3.bb``)::\n\n   SUMMARY = \"GNU Helloworld application\"\n   SECTION = \"examples\"\n   LICENSE = \"GPL-2.0-or-later\"\n   LIC_FILES_CHKSUM = \"file://COPYING;md5=751419260aa954499f7abaabaa882bbe\"\n\n   SRC_URI = \"${GNU_MIRROR}/hello/hello-${PV}.tar.gz\"\n\n   inherit autotools gettext\n\nThe variable :term:`LIC_FILES_CHKSUM` is used to track source license changes\nas described in the \":ref:`dev-manual/licenses:tracking license changes`\"\nsection in the Yocto Project Overview and Concepts Manual. You can quickly\ncreate Autotool-based recipes in a manner similar to the previous example.\n\n.. _ref-building-meson-package:\n\nBuilding a Meson Package\n------------------------\n\nApplications built with the `Meson build system <https://mesonbuild.com/>`__\njust need a recipe that has sources described in :term:`SRC_URI` and inherits\nthe :ref:`ref-classes-meson` class.\n\nThe :oe_git:`ipcalc recipe </meta-openembedded/tree/meta-networking/recipes-support/ipcalc>`\nis a simple example of an application without dependencies::\n\n   SUMMARY = \"Tool to assist in network address calculations for IPv4 and IPv6.\"\n   HOMEPAGE = \"https://gitlab.com/ipcalc/ipcalc\"\n\n   SECTION = \"net\"\n\n   LICENSE = \"GPL-2.0-only\"\n   LIC_FILES_CHKSUM = \"file://COPYING;md5=b234ee4d69f5fce4486a80fdaf4a4263\"\n\n   SRC_URI = \"git://gitlab.com/ipcalc/ipcalc.git;protocol=https;branch=master\"\n   SRCREV = \"4c4261a47f355946ee74013d4f5d0494487cc2d6\"\n\n   S = \"${WORKDIR}/git\"\n\n   inherit meson\n\nApplications with dependencies are likely to inherit the\n:ref:`ref-classes-pkgconfig` class, as ``pkg-config`` is the default method\nused by Meson to find dependencies and compile applications against them.\n\nSplitting an Application into Multiple Packages\n-----------------------------------------------\n\nYou can use the variables :term:`PACKAGES` and :term:`FILES` to split an\napplication into multiple packages.\n\nFollowing is an example that uses the ``libxpm`` recipe. By default,\nthis recipe generates a single package that contains the library along\nwith a few binaries. You can modify the recipe to split the binaries\ninto separate packages::\n\n   require xorg-lib-common.inc\n\n   SUMMARY = \"Xpm: X Pixmap extension library\"\n   LICENSE = \"MIT\"\n   LIC_FILES_CHKSUM = \"file://COPYING;md5=51f4270b012ecd4ab1a164f5f4ed6cf7\"\n   DEPENDS += \"libxext libsm libxt\"\n   PE = \"1\"\n\n"}
{"text": "\n\nWriting a New Recipe\n   XORG_PN = \"libXpm\"\n\n   PACKAGES =+ \"sxpm cxpm\"\n   FILES:cxpm = \"${bindir}/cxpm\"\n   FILES:sxpm = \"${bindir}/sxpm\"\n\nIn the previous example, we want to ship the ``sxpm`` and ``cxpm``\nbinaries in separate packages. Since ``bindir`` would be packaged into\nthe main :term:`PN` package by default, we prepend the :term:`PACKAGES` variable\nso additional package names are added to the start of list. This results\nin the extra ``FILES:*`` variables then containing information that\ndefine which files and directories go into which packages. Files\nincluded by earlier packages are skipped by latter packages. Thus, the\nmain :term:`PN` package does not include the above listed files.\n\nPackaging Externally Produced Binaries\n--------------------------------------\n\nSometimes, you need to add pre-compiled binaries to an image. For\nexample, suppose that there are binaries for proprietary code,\ncreated by a particular division of a company. Your part of the company\nneeds to use those binaries as part of an image that you are building\nusing the OpenEmbedded build system. Since you only have the binaries\nand not the source code, you cannot use a typical recipe that expects to\nfetch the source specified in\n:term:`SRC_URI` and then compile it.\n\nOne method is to package the binaries and then install them as part of\nthe image. Generally, it is not a good idea to package binaries since,\namong other things, it can hinder the ability to reproduce builds and\ncould lead to compatibility problems with ABI in the future. However,\nsometimes you have no choice.\n\nThe easiest solution is to create a recipe that uses the\n:ref:`ref-classes-bin-package` class and to be sure that you are using default\nlocations for build artifacts.  In most cases, the\n:ref:`ref-classes-bin-package` class handles \"skipping\" the configure and\ncompile steps as well as sets things up to grab packages from the appropriate\narea. In particular, this class sets ``noexec`` on both the\n:ref:`ref-tasks-configure` and :ref:`ref-tasks-compile` tasks, sets\n``FILES:${PN}`` to \"/\" so that it picks up all files, and sets up a\n:ref:`ref-tasks-install` task, which effectively copies all files from ``${S}``\nto ``${D}``. The :ref:`ref-classes-bin-package` class works well when the files\nextracted into ``${S}`` are already laid out in the way they should be laid out\non the target. For more information on these variables, see the :term:`FILES`,\n:term:`PN`, :term:`S`, and :term:`D` variables in the Yocto Project Reference\nManual's variable glossary.\n\n.. note::\n\n   -  Using :term:`DEPENDS` is a good\n      idea even for components distributed in binary form, and is often\n      necessary for shared libraries. For a shared library, listing the\n      library dependencies in :term:`DEPENDS` makes sure that the libraries\n      are available in the staging sysroot when other recipes link\n      against the library, which might be necessary for successful\n      linking.\n\n   -  Using :term:`DEPENDS` also allows runtime dependencies between\n      packages to be added automatically. See the\n      \":ref:`overview-manual/concepts:automatically added runtime dependencies`\"\n      section in the Yocto Project Overview and Concepts Manual for more\n      information.\n\nIf you cannot use the :ref:`ref-classes-bin-package` class, you need to be sure you are\ndoing the following:\n\n-  Create a recipe where the\n   :ref:`ref-tasks-configure` and\n   :ref:`ref-tasks-compile` tasks do\n   nothing: It is usually sufficient to just not define these tasks in\n   the recipe, because the default implementations do nothing unless a\n   Makefile is found in\n   ``${``\\ :term:`S`\\ ``}``.\n\n   If ``${S}`` might contain a Makefile, or if you inherit some class\n   that replaces :ref:`ref-tasks-configure` and :ref:`ref-tasks-compile` with custom\n   versions, then you can use the\n   ``[``\\ :ref:`noexec <bitbake-user-manual/bitbake-user-manual-metadata:variable flags>`\\ ``]``\n   flag to turn the tasks into no-ops, as follows::\n\n      do_configure[noexec] = \"1\"\n      do_compile[noexec] = \"1\"\n\n   Unlike :ref:`bitbake-user-manual/bitbake-user-manual-metadata:deleting a task`,\n   using the flag preserves the dependency chain from the :ref:`ref-tasks-fetch`,\n   :ref:`ref-tasks-unpack`, and :ref:`ref-tasks-patch` tasks to the\n   :ref:`ref-tasks-install` task.\n\n-  Make sure your :ref:`ref-tasks-install` task installs the binaries\n   appropriately.\n\n-  Ensure that you set up :term:`FILES`\n   (usually\n   ``FILES:${``\\ :term:`PN`\\ ``}``) to\n   point to the files you have installed, which of course depends on\n   where you have installed them and whether those files are in\n   different locations than the defaults.\n\nFollowing Recipe Style Guidelines\n"}
{"text": "\n\nWriting a New Recipe\n=================================\n\nWhen writing recipes, it is good to conform to existing style guidelines.\nSee the \":doc:`../contributor-guide/recipe-style-guide`\" in the Yocto Project\nand OpenEmbedded Contributor Guide for reference.\n\nIt is common for existing recipes to deviate a bit from this style.\nHowever, aiming for at least a consistent style is a good idea. Some\npractices, such as omitting spaces around ``=`` operators in assignments\nor ordering recipe components in an erratic way, are widely seen as poor\nstyle.\n\nRecipe Syntax\n=============\n\nUnderstanding recipe file syntax is important for writing recipes. The\nfollowing list overviews the basic items that make up a BitBake recipe\nfile. For more complete BitBake syntax descriptions, see the\n\":doc:`bitbake:bitbake-user-manual/bitbake-user-manual-metadata`\"\nchapter of the BitBake User Manual.\n\n-  *Variable Assignments and Manipulations:* Variable assignments allow\n   a value to be assigned to a variable. The assignment can be static\n   text or might include the contents of other variables. In addition to\n   the assignment, appending and prepending operations are also\n   supported.\n\n   The following example shows some of the ways you can use variables in\n   recipes::\n\n      S = \"${WORKDIR}/postfix-${PV}\"\n      CFLAGS += \"-DNO_ASM\"\n      CFLAGS:append = \" --enable-important-feature\"\n\n-  *Functions:* Functions provide a series of actions to be performed.\n   You usually use functions to override the default implementation of a\n   task function or to complement a default function (i.e. append or\n   prepend to an existing function). Standard functions use ``sh`` shell\n   syntax, although access to OpenEmbedded variables and internal\n   methods are also available.\n\n   Here is an example function from the ``sed`` recipe::\n\n      do_install () {\n          autotools_do_install\n          install -d ${D}${base_bindir}\n          mv ${D}${bindir}/sed ${D}${base_bindir}/sed\n          rmdir ${D}${bindir}/\n      }\n\n   It is\n   also possible to implement new functions that are called between\n   existing tasks as long as the new functions are not replacing or\n   complementing the default functions. You can implement functions in\n   Python instead of shell. Both of these options are not seen in the\n   majority of recipes.\n\n-  *Keywords:* BitBake recipes use only a few keywords. You use keywords\n   to include common functions (``inherit``), load parts of a recipe\n   from other files (``include`` and ``require``) and export variables\n   to the environment (``export``).\n\n   The following example shows the use of some of these keywords::\n\n      export POSTCONF = \"${STAGING_BINDIR}/postconf\"\n      inherit autoconf\n      require otherfile.inc\n\n-  *Comments (#):* Any lines that begin with the hash character (``#``)\n   are treated as comment lines and are ignored::\n\n      # This is a comment\n\nThis next list summarizes the most important and most commonly used\nparts of the recipe syntax. For more information on these parts of the\nsyntax, you can reference the\n\":doc:`bitbake:bitbake-user-manual/bitbake-user-manual-metadata`\" chapter\nin the BitBake User Manual.\n\n-  *Line Continuation (\\\\):* Use the backward slash (``\\``) character to\n   split a statement over multiple lines. Place the slash character at\n   the end of the line that is to be continued on the next line::\n\n       VAR = \"A really long \\\n              line\"\n\n   .. note::\n\n      You cannot have any characters including spaces or tabs after the\n      slash character.\n\n-  *Using Variables (${VARNAME}):* Use the ``${VARNAME}`` syntax to\n   access the contents of a variable::\n\n      SRC_URI = \"${SOURCEFORGE_MIRROR}/libpng/zlib-${PV}.tar.gz\"\n\n   .. note::\n\n      It is important to understand that the value of a variable\n      expressed in this form does not get substituted automatically. The\n"}
{"text": "\n\nWriting a New Recipe\n      expansion of these expressions happens on-demand later (e.g.\n      usually when a function that makes reference to the variable\n      executes). This behavior ensures that the values are most\n      appropriate for the context in which they are finally used. On the\n      rare occasion that you do need the variable expression to be\n      expanded immediately, you can use the\n      :=\n      operator instead of\n      =\n      when you make the assignment, but this is not generally needed.\n\n-  *Quote All Assignments (\"value\"):* Use double quotes around values in\n   all variable assignments (e.g. ``\"value\"``). Following is an example::\n\n      VAR1 = \"${OTHERVAR}\"\n      VAR2 = \"The version is ${PV}\"\n\n-  *Conditional Assignment (?=):* Conditional assignment is used to\n   assign a value to a variable, but only when the variable is currently\n   unset. Use the question mark followed by the equal sign (``?=``) to\n   make a \"soft\" assignment used for conditional assignment. Typically,\n   \"soft\" assignments are used in the ``local.conf`` file for variables\n   that are allowed to come through from the external environment.\n\n   Here is an example where ``VAR1`` is set to \"New value\" if it is\n   currently empty. However, if ``VAR1`` has already been set, it\n   remains unchanged::\n\n      VAR1 ?= \"New value\"\n\n   In this next example, ``VAR1`` is left with the value \"Original value\"::\n\n      VAR1 = \"Original value\"\n      VAR1 ?= \"New value\"\n\n-  *Appending (+=):* Use the plus character followed by the equals sign\n   (``+=``) to append values to existing variables.\n\n   .. note::\n\n      This operator adds a space between the existing content of the\n      variable and the new content.\n\n   Here is an example::\n\n      SRC_URI += \"file://fix-makefile.patch\"\n\n-  *Prepending (=+):* Use the equals sign followed by the plus character\n   (``=+``) to prepend values to existing variables.\n\n   .. note::\n\n      This operator adds a space between the new content and the\n      existing content of the variable.\n\n   Here is an example::\n\n      VAR =+ \"Starts\"\n\n-  *Appending (:append):* Use the ``:append`` operator to append values\n   to existing variables. This operator does not add any additional\n   space. Also, the operator is applied after all the ``+=``, and ``=+``\n   operators have been applied and after all ``=`` assignments have\n   occurred. This means that if ``:append`` is used in a recipe, it can\n   only be overridden by another layer using the special ``:remove``\n   operator, which in turn will prevent further layers from adding it back.\n\n   The following example shows the space being explicitly added to the\n   start to ensure the appended value is not merged with the existing\n   value::\n\n      CFLAGS:append = \" --enable-important-feature\"\n\n   You can also use\n   the ``:append`` operator with overrides, which results in the actions\n   only being performed for the specified target or machine::\n\n      CFLAGS:append:sh4 = \" --enable-important-sh4-specific-feature\"\n\n-  *Prepending (:prepend):* Use the ``:prepend`` operator to prepend\n   values to existing variables. This operator does not add any\n   additional space. Also, the operator is applied after all the ``+=``,\n   and ``=+`` operators have been applied and after all ``=``\n   assignments have occurred.\n\n   The following example shows the space being explicitly added to the\n   end to ensure the prepended value is not merged with the existing\n   value::\n\n      CFLAGS:prepend = \"-I${S}/myincludes \"\n\n   You can also use the\n   ``:prepend`` operator with overrides, which results in the actions\n   only being performed for the specified target or machine::\n\n      CFLAGS:prepend:sh4 = \"-I${S}/myincludes \"\n\n-  *Overrides:* You can use overrides to set a value conditionally,\n   typically based on how the recipe is being built. For example, to set\n   the :term:`KBRANCH` variable's\n"}
{"text": "\n\nWriting a New Recipe\n   value to \"standard/base\" for any target\n   :term:`MACHINE`, except for\n   qemuarm where it should be set to \"standard/arm-versatile-926ejs\",\n   you would do the following::\n\n      KBRANCH = \"standard/base\"\n      KBRANCH:qemuarm = \"standard/arm-versatile-926ejs\"\n\n   Overrides are also used to separate\n   alternate values of a variable in other situations. For example, when\n   setting variables such as\n   :term:`FILES` and\n   :term:`RDEPENDS` that are\n   specific to individual packages produced by a recipe, you should\n   always use an override that specifies the name of the package.\n\n-  *Indentation:* Use spaces for indentation rather than tabs. For\n   shell functions, both currently work. However, it is a policy\n   decision of the Yocto Project to use tabs in shell functions. Realize\n   that some layers have a policy to use spaces for all indentation.\n\n-  *Using Python for Complex Operations:* For more advanced processing,\n   it is possible to use Python code during variable assignments (e.g.\n   search and replacement on a variable).\n\n   You indicate Python code using the ``${@python_code}`` syntax for the\n   variable assignment::\n\n      SRC_URI = \"ftp://ftp.info-zip.org/pub/infozip/src/zip${@d.getVar('PV',1).replace('.', '')}.tgz\n\n-  *Shell Function Syntax:* Write shell functions as if you were writing\n   a shell script when you describe a list of actions to take. You\n   should ensure that your script works with a generic ``sh`` and that\n   it does not require any ``bash`` or other shell-specific\n   functionality. The same considerations apply to various system\n   utilities (e.g. ``sed``, ``grep``, ``awk``, and so forth) that you\n   might wish to use. If in doubt, you should check with multiple\n   implementations --- including those from BusyBox.\n\n"}
{"text": "\n\nUnderstanding and Creating Layers\n\n\nUnderstanding and Creating Layers\n*********************************\n\nThe OpenEmbedded build system supports organizing\n:term:`Metadata` into multiple layers.\nLayers allow you to isolate different types of customizations from each\nother. For introductory information on the Yocto Project Layer Model,\nsee the\n\":ref:`overview-manual/yp-intro:the yocto project layer model`\"\nsection in the Yocto Project Overview and Concepts Manual.\n\nCreating Your Own Layer\n=======================\n\n.. note::\n\n   It is very easy to create your own layers to use with the OpenEmbedded\n   build system, as the Yocto Project ships with tools that speed up creating\n   layers. This section describes the steps you perform by hand to create\n   layers so that you can better understand them. For information about the\n   layer-creation tools, see the\n   \":ref:`bsp-guide/bsp:creating a new bsp layer using the \\`\\`bitbake-layers\\`\\` script`\"\n   section in the Yocto Project Board Support Package (BSP) Developer's\n   Guide and the \":ref:`dev-manual/layers:creating a general layer using the \\`\\`bitbake-layers\\`\\` script`\"\n   section further down in this manual.\n\nFollow these general steps to create your layer without using tools:\n\n#. *Check Existing Layers:* Before creating a new layer, you should be\n   sure someone has not already created a layer containing the Metadata\n   you need. You can see the :oe_layerindex:`OpenEmbedded Metadata Index <>`\n   for a list of layers from the OpenEmbedded community that can be used in\n   the Yocto Project. You could find a layer that is identical or close\n   to what you need.\n\n#. *Create a Directory:* Create the directory for your layer. When you\n   create the layer, be sure to create the directory in an area not\n   associated with the Yocto Project :term:`Source Directory`\n   (e.g. the cloned ``poky`` repository).\n\n   While not strictly required, prepend the name of the directory with\n   the string \"meta-\". For example::\n\n      meta-mylayer\n      meta-GUI_xyz\n      meta-mymachine\n\n   With rare exceptions, a layer's name follows this form::\n\n      meta-root_name\n\n   Following this layer naming convention can save\n   you trouble later when tools, components, or variables \"assume\" your\n   layer name begins with \"meta-\". A notable example is in configuration\n   files as shown in the following step where layer names without the\n   \"meta-\" string are appended to several variables used in the\n   configuration.\n\n#. *Create a Layer Configuration File:* Inside your new layer folder,\n   you need to create a ``conf/layer.conf`` file. It is easiest to take\n   an existing layer configuration file and copy that to your layer's\n   ``conf`` directory and then modify the file as needed.\n\n   The ``meta-yocto-bsp/conf/layer.conf`` file in the Yocto Project\n   :yocto_git:`Source Repositories </poky/tree/meta-yocto-bsp/conf>`\n   demonstrates the required syntax. For your layer, you need to replace\n   \"yoctobsp\" with a unique identifier for your layer (e.g. \"machinexyz\"\n   for a layer named \"meta-machinexyz\")::\n\n      # We have a conf and classes directory, add to BBPATH\n      BBPATH .= \":${LAYERDIR}\"\n\n      # We have recipes-* directories, add to BBFILES\n      BBFILES += \"${LAYERDIR}/recipes-*/*/*.bb \\\n                  ${LAYERDIR}/recipes-*/*/*.bbappend\"\n\n      BBFILE_COLLECTIONS += \"yoctobsp\"\n      BBFILE_PATTERN_yoctobsp = \"^${LAYERDIR}/\"\n      BBFILE_PRIORITY_yoctobsp = \"5\"\n      LAYERVERSION_yoctobsp = \"4\"\n      LAYERSERIES_COMPAT_yoctobsp = \"dunfell\"\n\n   Following is an explanation of the layer configuration file:\n\n   -  :term:`BBPATH`: Adds the layer's\n      root directory to BitBake's search path. Through the use of the\n      :term:`BBPATH` variable, BitBake locates class files (``.bbclass``),\n      configuration files, and files that are included with ``include``\n      and ``require`` statements. For these cases, BitBake uses the\n      first file that matches the name found in :term:`BBPATH`. This is\n      similar to the way the ``PATH`` variable is used for binaries. It\n      is recommended, therefore, that you use unique class and\n      configuration filenames in your custom layer.\n\n   -  :term:`BBFILES`: Defines the\n      location for all recipes in the layer.\n\n   -  :term:`BBFILE_COLLECTIONS`:\n"}
{"text": "\n\nUnderstanding and Creating Layers\n      Establishes the current layer through a unique identifier that is\n      used throughout the OpenEmbedded build system to refer to the\n      layer. In this example, the identifier \"yoctobsp\" is the\n      representation for the container layer named \"meta-yocto-bsp\".\n\n   -  :term:`BBFILE_PATTERN`:\n      Expands immediately during parsing to provide the directory of the\n      layer.\n\n   -  :term:`BBFILE_PRIORITY`:\n      Establishes a priority to use for recipes in the layer when the\n      OpenEmbedded build finds recipes of the same name in different\n      layers.\n\n   -  :term:`LAYERVERSION`:\n      Establishes a version number for the layer. You can use this\n      version number to specify this exact version of the layer as a\n      dependency when using the\n      :term:`LAYERDEPENDS`\n      variable.\n\n   -  :term:`LAYERDEPENDS`:\n      Lists all layers on which this layer depends (if any).\n\n   -  :term:`LAYERSERIES_COMPAT`:\n      Lists the :yocto_wiki:`Yocto Project </Releases>`\n      releases for which the current version is compatible. This\n      variable is a good way to indicate if your particular layer is\n      current.\n\n\n   .. note::\n\n      A layer does not have to contain only recipes ``.bb`` or append files\n      ``.bbappend``. Generally, developers create layers using\n      ``bitbake-layers create-layer``.\n      See \":ref:`dev-manual/layers:creating a general layer using the \\`\\`bitbake-layers\\`\\` script`\",\n      explaining how the ``layer.conf`` file is created from a template located in\n      ``meta/lib/bblayers/templates/layer.conf``.\n      In fact, none of the variables set in ``layer.conf`` are mandatory,\n      except when :term:`BBFILE_COLLECTIONS` is present. In this case\n      :term:`LAYERSERIES_COMPAT` and :term:`BBFILE_PATTERN` have to be\n      defined too.\n\n#. *Add Content:* Depending on the type of layer, add the content. If\n   the layer adds support for a machine, add the machine configuration\n   in a ``conf/machine/`` file within the layer. If the layer adds\n   distro policy, add the distro configuration in a ``conf/distro/``\n   file within the layer. If the layer introduces new recipes, put the\n   recipes you need in ``recipes-*`` subdirectories within the layer.\n\n   .. note::\n\n      For an explanation of layer hierarchy that is compliant with the\n      Yocto Project, see the \":ref:`bsp-guide/bsp:example filesystem layout`\"\n      section in the Yocto Project Board Support Package (BSP) Developer's Guide.\n\n#. *Optionally Test for Compatibility:* If you want permission to use\n   the Yocto Project Compatibility logo with your layer or application\n   that uses your layer, perform the steps to apply for compatibility.\n   See the\n   \":ref:`dev-manual/layers:making sure your layer is compatible with yocto project`\"\n   section for more information.\n\nFollowing Best Practices When Creating Layers\n=============================================\n\nTo create layers that are easier to maintain and that will not impact\nbuilds for other machines, you should consider the information in the\nfollowing list:\n\n-  *Avoid \"Overlaying\" Entire Recipes from Other Layers in Your\n   Configuration:* In other words, do not copy an entire recipe into\n   your layer and then modify it. Rather, use an append file\n   (``.bbappend``) to override only those parts of the original recipe\n   you need to modify.\n\n-  *Avoid Duplicating Include Files:* Use append files (``.bbappend``)\n   for each recipe that uses an include file. Or, if you are introducing\n   a new recipe that requires the included file, use the path relative\n   to the original layer directory to refer to the file. For example,\n   use ``require recipes-core/``\\ `package`\\ ``/``\\ `file`\\ ``.inc`` instead\n   of ``require`` `file`\\ ``.inc``. If you're finding you have to overlay\n   the include file, it could indicate a deficiency in the include file\n   in the layer to which it originally belongs. If this is the case, you\n   should try to address that deficiency instead of overlaying the\n   include file. For example, you could address this by getting the\n   maintainer of the include file to add a variable or variables to make\n   it easy to override the parts needing to be overridden.\n\n-  *Structure Your Layers:* Proper use of overrides within append files\n   and placement of machine-specific files within your layer can ensure\n   that a build is not using the wrong Metadata and negatively impacting\n   a build for a different machine. Following are some examples:\n\n   -  *Modify Variables to Support a Different Machine:* Suppose you\n      have a layer named ``meta-one`` that adds support for building\n      machine \"one\". To do so, you use an append file named\n      ``base-files.bbappend`` and create a dependency on \"foo\" by\n      altering the :term:`DEPENDS`\n"}
{"text": "\n\nUnderstanding and Creating Layers\n      variable::\n\n         DEPENDS = \"foo\"\n\n      The dependency is created during any\n      build that includes the layer ``meta-one``. However, you might not\n      want this dependency for all machines. For example, suppose you\n      are building for machine \"two\" but your ``bblayers.conf`` file has\n      the ``meta-one`` layer included. During the build, the\n      ``base-files`` for machine \"two\" will also have the dependency on\n      ``foo``.\n\n      To make sure your changes apply only when building machine \"one\",\n      use a machine override with the :term:`DEPENDS` statement::\n\n         DEPENDS:one = \"foo\"\n\n      You should follow the same strategy when using ``:append``\n      and ``:prepend`` operations::\n\n         DEPENDS:append:one = \" foo\"\n         DEPENDS:prepend:one = \"foo \"\n\n      As an actual example, here's a\n      snippet from the generic kernel include file ``linux-yocto.inc``,\n      wherein the kernel compile and link options are adjusted in the\n      case of a subset of the supported architectures::\n\n         DEPENDS:append:aarch64 = \" libgcc\"\n         KERNEL_CC:append:aarch64 = \" ${TOOLCHAIN_OPTIONS}\"\n         KERNEL_LD:append:aarch64 = \" ${TOOLCHAIN_OPTIONS}\"\n\n         DEPENDS:append:nios2 = \" libgcc\"\n         KERNEL_CC:append:nios2 = \" ${TOOLCHAIN_OPTIONS}\"\n         KERNEL_LD:append:nios2 = \" ${TOOLCHAIN_OPTIONS}\"\n\n         DEPENDS:append:arc = \" libgcc\"\n         KERNEL_CC:append:arc = \" ${TOOLCHAIN_OPTIONS}\"\n         KERNEL_LD:append:arc = \" ${TOOLCHAIN_OPTIONS}\"\n\n         KERNEL_FEATURES:append:qemuall=\" features/debug/printk.scc\"\n\n   -  *Place Machine-Specific Files in Machine-Specific Locations:* When\n      you have a base recipe, such as ``base-files.bb``, that contains a\n      :term:`SRC_URI` statement to a\n      file, you can use an append file to cause the build to use your\n      own version of the file. For example, an append file in your layer\n      at ``meta-one/recipes-core/base-files/base-files.bbappend`` could\n      extend :term:`FILESPATH` using :term:`FILESEXTRAPATHS` as follows::\n\n         FILESEXTRAPATHS:prepend := \"${THISDIR}/${BPN}:\"\n\n      The build for machine \"one\" will pick up your machine-specific file as\n      long as you have the file in\n      ``meta-one/recipes-core/base-files/base-files/``. However, if you\n      are building for a different machine and the ``bblayers.conf``\n      file includes the ``meta-one`` layer and the location of your\n      machine-specific file is the first location where that file is\n      found according to :term:`FILESPATH`, builds for all machines will\n      also use that machine-specific file.\n\n      You can make sure that a machine-specific file is used for a\n      particular machine by putting the file in a subdirectory specific\n      to the machine. For example, rather than placing the file in\n      ``meta-one/recipes-core/base-files/base-files/`` as shown above,\n      put it in ``meta-one/recipes-core/base-files/base-files/one/``.\n      Not only does this make sure the file is used only when building\n      for machine \"one\", but the build process locates the file more\n      quickly.\n\n      In summary, you need to place all files referenced from\n      :term:`SRC_URI` in a machine-specific subdirectory within the layer in\n      order to restrict those files to machine-specific builds.\n\n-  *Perform Steps to Apply for Yocto Project Compatibility:* If you want\n   permission to use the Yocto Project Compatibility logo with your\n   layer or application that uses your layer, perform the steps to apply\n   for compatibility. See the\n   \":ref:`dev-manual/layers:making sure your layer is compatible with yocto project`\"\n   section for more information.\n\n-  *Follow the Layer Naming Convention:* Store custom layers in a Git\n   repository that use the ``meta-layer_name`` format.\n\n-  *Group Your Layers Locally:* Clone your repository alongside other\n   cloned ``meta`` directories from the :term:`Source Directory`.\n\nMaking Sure Your Layer is Compatible With Yocto Project\n=======================================================\n\nWhen you create a layer used with the Yocto Project, it is advantageous\nto make sure that the layer interacts well with existing Yocto Project\nlayers (i.e. the layer is compatible with the Yocto Project). Ensuring\ncompatibility makes the layer easy to be consumed by others in the Yocto\nProject community and could allow you permission to use the Yocto\nProject Compatible Logo.\n\n.. note::\n\n   Only Yocto Project member organizations are permitted to use the\n"}
{"text": "\n\nUnderstanding and Creating Layers\n   Yocto Project Compatible Logo. The logo is not available for general\n   use. For information on how to become a Yocto Project member\n   organization, see the :yocto_home:`Yocto Project Website <>`.\n\nThe Yocto Project Compatibility Program consists of a layer application\nprocess that requests permission to use the Yocto Project Compatibility\nLogo for your layer and application. The process consists of two parts:\n\n#. Successfully passing a script (``yocto-check-layer``) that when run\n   against your layer, tests it against constraints based on experiences\n   of how layers have worked in the real world and where pitfalls have\n   been found. Getting a \"PASS\" result from the script is required for\n   successful compatibility registration.\n\n#. Completion of an application acceptance form, which you can find at\n   :yocto_home:`/compatible-registration/`.\n\nTo be granted permission to use the logo, you need to satisfy the\nfollowing:\n\n-  Be able to check the box indicating that you got a \"PASS\" when\n   running the script against your layer.\n\n-  Answer \"Yes\" to the questions on the form or have an acceptable\n   explanation for any questions answered \"No\".\n\n-  Be a Yocto Project Member Organization.\n\nThe remainder of this section presents information on the registration\nform and on the ``yocto-check-layer`` script.\n\nYocto Project Compatible Program Application\n--------------------------------------------\n\nUse the form to apply for your layer's approval. Upon successful\napplication, you can use the Yocto Project Compatibility Logo with your\nlayer and the application that uses your layer.\n\nTo access the form, use this link:\n:yocto_home:`/compatible-registration`.\nFollow the instructions on the form to complete your application.\n\nThe application consists of the following sections:\n\n-  *Contact Information:* Provide your contact information as the fields\n   require. Along with your information, provide the released versions\n   of the Yocto Project for which your layer is compatible.\n\n-  *Acceptance Criteria:* Provide \"Yes\" or \"No\" answers for each of the\n   items in the checklist. There is space at the bottom of the form for\n   any explanations for items for which you answered \"No\".\n\n-  *Recommendations:* Provide answers for the questions regarding Linux\n   kernel use and build success.\n\n``yocto-check-layer`` Script\n----------------------------\n\nThe ``yocto-check-layer`` script provides you a way to assess how\ncompatible your layer is with the Yocto Project. You should run this\nscript prior to using the form to apply for compatibility as described\nin the previous section. You need to achieve a \"PASS\" result in order to\nhave your application form successfully processed.\n\nThe script divides tests into three areas: COMMON, BSP, and DISTRO. For\nexample, given a distribution layer (DISTRO), the layer must pass both\nthe COMMON and DISTRO related tests. Furthermore, if your layer is a BSP\nlayer, the layer must pass the COMMON and BSP set of tests.\n\nTo execute the script, enter the following commands from your build\ndirectory::\n\n   $ source oe-init-build-env\n   $ yocto-check-layer your_layer_directory\n\nBe sure to provide the actual directory for your\nlayer as part of the command.\n\nEntering the command causes the script to determine the type of layer\nand then to execute a set of specific tests against the layer. The\nfollowing list overviews the test:\n\n-  ``common.test_readme``: Tests if a ``README`` file exists in the\n   layer and the file is not empty.\n\n-  ``common.test_parse``: Tests to make sure that BitBake can parse the\n   files without error (i.e. ``bitbake -p``).\n\n-  ``common.test_show_environment``: Tests that the global or per-recipe\n   environment is in order without errors (i.e. ``bitbake -e``).\n\n-  ``common.test_world``: Verifies that ``bitbake world`` works.\n\n-  ``common.test_signatures``: Tests to be sure that BSP and DISTRO\n   layers do not come with recipes that change signatures.\n\n-  ``common.test_layerseries_compat``: Verifies layer compatibility is\n   set properly.\n\n-  ``bsp.test_bsp_defines_machines``: Tests if a BSP layer has machine\n"}
{"text": "\n\nUnderstanding and Creating Layers\n   configurations.\n\n-  ``bsp.test_bsp_no_set_machine``: Tests to ensure a BSP layer does not\n   set the machine when the layer is added.\n\n-  ``bsp.test_machine_world``: Verifies that ``bitbake world`` works\n   regardless of which machine is selected.\n\n-  ``bsp.test_machine_signatures``: Verifies that building for a\n   particular machine affects only the signature of tasks specific to\n   that machine.\n\n-  ``distro.test_distro_defines_distros``: Tests if a DISTRO layer has\n   distro configurations.\n\n-  ``distro.test_distro_no_set_distros``: Tests to ensure a DISTRO layer\n   does not set the distribution when the layer is added.\n\nEnabling Your Layer\n===================\n\nBefore the OpenEmbedded build system can use your new layer, you need to\nenable it. To enable your layer, simply add your layer's path to the\n:term:`BBLAYERS` variable in your ``conf/bblayers.conf`` file, which is\nfound in the :term:`Build Directory`. The following example shows how to\nenable your new ``meta-mylayer`` layer (note how your new layer exists\noutside of the official ``poky`` repository which you would have checked\nout earlier)::\n\n   # POKY_BBLAYERS_CONF_VERSION is increased each time build/conf/bblayers.conf\n   # changes incompatibly\n   POKY_BBLAYERS_CONF_VERSION = \"2\"\n   BBPATH = \"${TOPDIR}\"\n   BBFILES ?= \"\"\n   BBLAYERS ?= \" \\\n       /home/user/poky/meta \\\n       /home/user/poky/meta-poky \\\n       /home/user/poky/meta-yocto-bsp \\\n       /home/user/mystuff/meta-mylayer \\\n       \"\n\nBitBake parses each ``conf/layer.conf`` file from the top down as\nspecified in the :term:`BBLAYERS` variable within the ``conf/bblayers.conf``\nfile. During the processing of each ``conf/layer.conf`` file, BitBake\nadds the recipes, classes and configurations contained within the\nparticular layer to the source directory.\n\nAppending Other Layers Metadata With Your Layer\n===============================================\n\nA recipe that appends Metadata to another recipe is called a BitBake\nappend file. A BitBake append file uses the ``.bbappend`` file type\nsuffix, while the corresponding recipe to which Metadata is being\nappended uses the ``.bb`` file type suffix.\n\nYou can use a ``.bbappend`` file in your layer to make additions or\nchanges to the content of another layer's recipe without having to copy\nthe other layer's recipe into your layer. Your ``.bbappend`` file\nresides in your layer, while the main ``.bb`` recipe file to which you\nare appending Metadata resides in a different layer.\n\nBeing able to append information to an existing recipe not only avoids\nduplication, but also automatically applies recipe changes from a\ndifferent layer into your layer. If you were copying recipes, you would\nhave to manually merge changes as they occur.\n\nWhen you create an append file, you must use the same root name as the\ncorresponding recipe file. For example, the append file\n``someapp_3.1.bbappend`` must apply to ``someapp_3.1.bb``. This\nmeans the original recipe and append filenames are version\nnumber-specific. If the corresponding recipe is renamed to update to a\nnewer version, you must also rename and possibly update the\ncorresponding ``.bbappend`` as well. During the build process, BitBake\ndisplays an error on starting if it detects a ``.bbappend`` file that\ndoes not have a corresponding recipe with a matching name. See the\n:term:`BB_DANGLINGAPPENDS_WARNONLY`\nvariable for information on how to handle this error.\n\nOverlaying a File Using Your Layer\n----------------------------------\n\nAs an example, consider the main formfactor recipe and a corresponding\nformfactor append file both from the :term:`Source Directory`.\nHere is the main\nformfactor recipe, which is named ``formfactor_0.0.bb`` and located in\nthe \"meta\" layer at ``meta/recipes-bsp/formfactor``::\n\n   SUMMARY = \"Device formfactor information\"\n   DESCRIPTION = \"A formfactor configuration file provides information about the \\\n   target hardware for which the image is being built and information that the \\\n   build system cannot obtain from other sources such as the kernel.\"\n   SECTION = \"base\"\n   LICENSE = \"MIT\"\n   LIC_FILES_CHKSUM = \"file://${COREBASE}/meta/COPYING.MIT;md5=3da9cfbcb788c80a0384361b4de20420\"\n   PR = \"r45\"\n\n   SRC_URI = \"file://config file://machconfig\"\n   S = \"${WORKDIR}\"\n\n   PACKAGE_ARCH = \"${MACHINE_ARCH}\"\n"}
{"text": "\n\nUnderstanding and Creating Layers\n   INHIBIT_DEFAULT_DEPS = \"1\"\n\n   do_install() {\n\t   # Install file only if it has contents\n           install -d ${D}${sysconfdir}/formfactor/\n           install -m 0644 ${S}/config ${D}${sysconfdir}/formfactor/\n\t   if [ -s \"${S}/machconfig\" ]; then\n\t           install -m 0644 ${S}/machconfig ${D}${sysconfdir}/formfactor/\n\t   fi\n   }\n\nIn the main recipe, note the :term:`SRC_URI`\nvariable, which tells the OpenEmbedded build system where to find files\nduring the build.\n\nFollowing is the append file, which is named ``formfactor_0.0.bbappend``\nand is from the Raspberry Pi BSP Layer named ``meta-raspberrypi``. The\nfile is in the layer at ``recipes-bsp/formfactor``::\n\n   FILESEXTRAPATHS:prepend := \"${THISDIR}/${PN}:\"\n\nBy default, the build system uses the\n:term:`FILESPATH` variable to\nlocate files. This append file extends the locations by setting the\n:term:`FILESEXTRAPATHS`\nvariable. Setting this variable in the ``.bbappend`` file is the most\nreliable and recommended method for adding directories to the search\npath used by the build system to find files.\n\nThe statement in this example extends the directories to include\n``${``\\ :term:`THISDIR`\\ ``}/${``\\ :term:`PN`\\ ``}``,\nwhich resolves to a directory named ``formfactor`` in the same directory\nin which the append file resides (i.e.\n``meta-raspberrypi/recipes-bsp/formfactor``. This implies that you must\nhave the supporting directory structure set up that will contain any\nfiles or patches you will be including from the layer.\n\nUsing the immediate expansion assignment operator ``:=`` is important\nbecause of the reference to :term:`THISDIR`. The trailing colon character is\nimportant as it ensures that items in the list remain colon-separated.\n\n.. note::\n\n   BitBake automatically defines the :term:`THISDIR` variable. You should\n   never set this variable yourself. Using \":prepend\" as part of the\n   :term:`FILESEXTRAPATHS` ensures your path will be searched prior to other\n   paths in the final list.\n\n   Also, not all append files add extra files. Many append files simply\n   allow to add build options (e.g. ``systemd``). For these cases, your\n   append file would not even use the :term:`FILESEXTRAPATHS` statement.\n\nThe end result of this ``.bbappend`` file is that on a Raspberry Pi, where\n``rpi`` will exist in the list of :term:`OVERRIDES`, the file\n``meta-raspberrypi/recipes-bsp/formfactor/formfactor/rpi/machconfig`` will be\nused during :ref:`ref-tasks-fetch` and the test for a non-zero file size in\n:ref:`ref-tasks-install` will return true, and the file will be installed.\n\nInstalling Additional Files Using Your Layer\n--------------------------------------------\n\nAs another example, consider the main ``xserver-xf86-config`` recipe and a\ncorresponding ``xserver-xf86-config`` append file both from the :term:`Source\nDirectory`.  Here is the main ``xserver-xf86-config`` recipe, which is named\n``xserver-xf86-config_0.1.bb`` and located in the \"meta\" layer at\n``meta/recipes-graphics/xorg-xserver``::\n\n   SUMMARY = \"X.Org X server configuration file\"\n   HOMEPAGE = \"http://www.x.org\"\n   SECTION = \"x11/base\"\n   LICENSE = \"MIT\"\n   LIC_FILES_CHKSUM = \"file://${COREBASE}/meta/COPYING.MIT;md5=3da9cfbcb788c80a0384361b4de20420\"\n   PR = \"r33\"\n\n   SRC_URI = \"file://xorg.conf\"\n\n   S = \"${WORKDIR}\"\n\n   CONFFILES:${PN} = \"${sysconfdir}/X11/xorg.conf\"\n\n   PACKAGE_ARCH = \"${MACHINE_ARCH}\"\n   ALLOW_EMPTY:${PN} = \"1\"\n\n   do_install () {\n\tif test -s ${WORKDIR}/xorg.conf; then\n\t\tinstall -d ${D}/${sysconfdir}/X11\n\t\tinstall -m 0644 ${WORKDIR}/xorg.conf ${D}/${sysconfdir}/X11/\n\tfi\n   }\n\nFollowing is the append file, which is named ``xserver-xf86-config_%.bbappend``\nand is from the Raspberry Pi BSP Layer named ``meta-raspberrypi``. The\nfile is in the layer at ``recipes-graphics/xorg-xserver``::\n\n   FILESEXTRAPATHS:prepend := \"${THISDIR}/${PN}:\"\n\n   SRC_URI:append:rpi = \" \\\n       file://xorg.conf.d/98-pitft.conf \\\n       file://xorg.conf.d/99-calibration.conf \\\n   \"\n"}
{"text": "\n\nUnderstanding and Creating Layers\n   do_install:append:rpi () {\n       PITFT=\"${@bb.utils.contains(\"MACHINE_FEATURES\", \"pitft\", \"1\", \"0\", d)}\"\n       if [ \"${PITFT}\" = \"1\" ]; then\n           install -d ${D}/${sysconfdir}/X11/xorg.conf.d/\n           install -m 0644 ${WORKDIR}/xorg.conf.d/98-pitft.conf ${D}/${sysconfdir}/X11/xorg.conf.d/\n           install -m 0644 ${WORKDIR}/xorg.conf.d/99-calibration.conf ${D}/${sysconfdir}/X11/xorg.conf.d/\n       fi\n   }\n\n   FILES:${PN}:append:rpi = \" ${sysconfdir}/X11/xorg.conf.d/*\"\n\nBuilding off of the previous example, we once again are setting the\n:term:`FILESEXTRAPATHS` variable.  In this case we are also using\n:term:`SRC_URI` to list additional source files to use when ``rpi`` is found in\nthe list of :term:`OVERRIDES`.  The :ref:`ref-tasks-install` task will then perform a\ncheck for an additional :term:`MACHINE_FEATURES` that if set will cause these\nadditional files to be installed.  These additional files are listed in\n:term:`FILES` so that they will be packaged.\n\nPrioritizing Your Layer\n=======================\n\nEach layer is assigned a priority value. Priority values control which\nlayer takes precedence if there are recipe files with the same name in\nmultiple layers. For these cases, the recipe file from the layer with a\nhigher priority number takes precedence. Priority values also affect the\norder in which multiple ``.bbappend`` files for the same recipe are\napplied. You can either specify the priority manually, or allow the\nbuild system to calculate it based on the layer's dependencies.\n\nTo specify the layer's priority manually, use the\n:term:`BBFILE_PRIORITY`\nvariable and append the layer's root name::\n\n   BBFILE_PRIORITY_mylayer = \"1\"\n\n.. note::\n\n   It is possible for a recipe with a lower version number\n   :term:`PV` in a layer that has a higher\n   priority to take precedence.\n\n   Also, the layer priority does not currently affect the precedence\n   order of ``.conf`` or ``.bbclass`` files. Future versions of BitBake\n   might address this.\n\nManaging Layers\n===============\n\nYou can use the BitBake layer management tool ``bitbake-layers`` to\nprovide a view into the structure of recipes across a multi-layer\nproject. Being able to generate output that reports on configured layers\nwith their paths and priorities and on ``.bbappend`` files and their\napplicable recipes can help to reveal potential problems.\n\nFor help on the BitBake layer management tool, use the following\ncommand::\n\n   $ bitbake-layers --help\n\nThe following list describes the available commands:\n\n-  ``help:`` Displays general help or help on a specified command.\n\n-  ``show-layers:`` Shows the current configured layers.\n\n-  ``show-overlayed:`` Lists overlayed recipes. A recipe is overlayed\n   when a recipe with the same name exists in another layer that has a\n   higher layer priority.\n\n-  ``show-recipes:`` Lists available recipes and the layers that\n   provide them.\n\n-  ``show-appends:`` Lists ``.bbappend`` files and the recipe files to\n   which they apply.\n\n-  ``show-cross-depends:`` Lists dependency relationships between\n   recipes that cross layer boundaries.\n\n-  ``add-layer:`` Adds a layer to ``bblayers.conf``.\n\n-  ``remove-layer:`` Removes a layer from ``bblayers.conf``\n\n-  ``flatten:`` Flattens the layer configuration into a separate\n   output directory. Flattening your layer configuration builds a\n   \"flattened\" directory that contains the contents of all layers, with\n   any overlayed recipes removed and any ``.bbappend`` files appended to\n   the corresponding recipes. You might have to perform some manual\n   cleanup of the flattened layer as follows:\n\n   -  Non-recipe files (such as patches) are overwritten. The flatten\n      command shows a warning for these files.\n\n   -  Anything beyond the normal layer setup has been added to the\n      ``layer.conf`` file. Only the lowest priority layer's\n      ``layer.conf`` is used.\n\n   -  Overridden and appended items from ``.bbappend`` files need to be\n      cleaned up. The contents of each ``.bbappend`` end up in the\n      flattened recipe. However, if there are appended or changed\n"}
{"text": "\n\nUnderstanding and Creating Layers\n      variable values, you need to tidy these up yourself. Consider the\n      following example. Here, the ``bitbake-layers`` command adds the\n      line ``#### bbappended ...`` so that you know where the following\n      lines originate::\n\n         ...\n         DESCRIPTION = \"A useful utility\"\n         ...\n         EXTRA_OECONF = \"--enable-something\"\n         ...\n\n         #### bbappended from meta-anotherlayer ####\n\n         DESCRIPTION = \"Customized utility\"\n         EXTRA_OECONF += \"--enable-somethingelse\"\n\n\n      Ideally, you would tidy up these utilities as follows::\n\n         ...\n         DESCRIPTION = \"Customized utility\"\n         ...\n         EXTRA_OECONF = \"--enable-something --enable-somethingelse\"\n         ...\n\n-  ``layerindex-fetch``: Fetches a layer from a layer index, along\n   with its dependent layers, and adds the layers to the\n   ``conf/bblayers.conf`` file.\n\n-  ``layerindex-show-depends``: Finds layer dependencies from the\n   layer index.\n\n-  ``save-build-conf``: Saves the currently active build configuration\n   (``conf/local.conf``, ``conf/bblayers.conf``) as a template into a layer.\n   This template can later be used for setting up builds via :term:``TEMPLATECONF``.\n   For information about saving and using configuration templates, see\n   \":ref:`dev-manual/custom-template-configuration-directory:creating a custom template configuration directory`\".\n\n-  ``create-layer``: Creates a basic layer.\n\n-  ``create-layers-setup``: Writes out a configuration file and/or a script that\n   can replicate the directory structure and revisions of the layers in a current build.\n   For more information, see \":ref:`dev-manual/layers:saving and restoring the layers setup`\".\n\nCreating a General Layer Using the ``bitbake-layers`` Script\n============================================================\n\nThe ``bitbake-layers`` script with the ``create-layer`` subcommand\nsimplifies creating a new general layer.\n\n.. note::\n\n   -  For information on BSP layers, see the \":ref:`bsp-guide/bsp:bsp layers`\"\n      section in the Yocto\n      Project Board Specific (BSP) Developer's Guide.\n\n   -  In order to use a layer with the OpenEmbedded build system, you\n      need to add the layer to your ``bblayers.conf`` configuration\n      file. See the \":ref:`dev-manual/layers:adding a layer using the \\`\\`bitbake-layers\\`\\` script`\"\n      section for more information.\n\nThe default mode of the script's operation with this subcommand is to\ncreate a layer with the following:\n\n-  A layer priority of 6.\n\n-  A ``conf`` subdirectory that contains a ``layer.conf`` file.\n\n-  A ``recipes-example`` subdirectory that contains a further\n   subdirectory named ``example``, which contains an ``example.bb``\n   recipe file.\n\n-  A ``COPYING.MIT``, which is the license statement for the layer. The\n   script assumes you want to use the MIT license, which is typical for\n   most layers, for the contents of the layer itself.\n\n-  A ``README`` file, which is a file describing the contents of your\n   new layer.\n\nIn its simplest form, you can use the following command form to create a\nlayer. The command creates a layer whose name corresponds to\n\"your_layer_name\" in the current directory::\n\n   $ bitbake-layers create-layer your_layer_name\n\nAs an example, the following command creates a layer named ``meta-scottrif``\nin your home directory::\n\n   $ cd /usr/home\n   $ bitbake-layers create-layer meta-scottrif\n   NOTE: Starting bitbake server...\n   Add your new layer with 'bitbake-layers add-layer meta-scottrif'\n\nIf you want to set the priority of the layer to other than the default\nvalue of \"6\", you can either use the ``--priority`` option or you\ncan edit the\n:term:`BBFILE_PRIORITY` value\nin the ``conf/layer.conf`` after the script creates it. Furthermore, if\nyou want to give the example recipe file some name other than the\ndefault, you can use the ``--example-recipe-name`` option.\n"}
{"text": "\n\nUnderstanding and Creating Layers\n\nThe easiest way to see how the ``bitbake-layers create-layer`` command\nworks is to experiment with the script. You can also read the usage\ninformation by entering the following::\n\n   $ bitbake-layers create-layer --help\n   NOTE: Starting bitbake server...\n   usage: bitbake-layers create-layer [-h] [--priority PRIORITY]\n                                      [--example-recipe-name EXAMPLERECIPE]\n                                      layerdir\n\n   Create a basic layer\n\n   positional arguments:\n     layerdir              Layer directory to create\n\n   optional arguments:\n     -h, --help            show this help message and exit\n     --priority PRIORITY, -p PRIORITY\n                           Layer directory to create\n     --example-recipe-name EXAMPLERECIPE, -e EXAMPLERECIPE\n                           Filename of the example recipe\n\nAdding a Layer Using the ``bitbake-layers`` Script\n==================================================\n\nOnce you create your general layer, you must add it to your\n``bblayers.conf`` file. Adding the layer to this configuration file\nmakes the OpenEmbedded build system aware of your layer so that it can\nsearch it for metadata.\n\nAdd your layer by using the ``bitbake-layers add-layer`` command::\n\n   $ bitbake-layers add-layer your_layer_name\n\nHere is an example that adds a\nlayer named ``meta-scottrif`` to the configuration file. Following the\ncommand that adds the layer is another ``bitbake-layers`` command that\nshows the layers that are in your ``bblayers.conf`` file::\n\n   $ bitbake-layers add-layer meta-scottrif\n   NOTE: Starting bitbake server...\n   Parsing recipes: 100% |##########################################################| Time: 0:00:49\n   Parsing of 1441 .bb files complete (0 cached, 1441 parsed). 2055 targets, 56 skipped, 0 masked, 0 errors.\n   $ bitbake-layers show-layers\n   NOTE: Starting bitbake server...\n   layer                 path                                      priority\n   ==========================================================================\n   meta                  /home/scottrif/poky/meta                  5\n   meta-poky             /home/scottrif/poky/meta-poky             5\n   meta-yocto-bsp        /home/scottrif/poky/meta-yocto-bsp        5\n   workspace             /home/scottrif/poky/build/workspace       99\n   meta-scottrif         /home/scottrif/poky/build/meta-scottrif   6\n\n\nAdding the layer to this file\nenables the build system to locate the layer during the build.\n\n.. note::\n\n   During a build, the OpenEmbedded build system looks in the layers\n   from the top of the list down to the bottom in that order.\n\nSaving and restoring the layers setup\n=====================================\n\nOnce you have a working build with the correct set of layers, it is beneficial\nto capture the layer setup --- what they are, which repositories they come from\nand which SCM revisions they're at --- into a configuration file, so that this\nsetup can be easily replicated later, perhaps on a different machine. Here's\nhow to do this::\n\n   $ bitbake-layers create-layers-setup /srv/work/alex/meta-alex/\n   NOTE: Starting bitbake server...\n   NOTE: Created /srv/work/alex/meta-alex/setup-layers.json\n   NOTE: Created /srv/work/alex/meta-alex/setup-layers\n\nThe tool needs a single argument which tells where to place the output, consisting\nof a json formatted layer configuration, and a ``setup-layers`` script that can use that configuration\nto restore the layers in a different location, or on a different host machine. The argument\ncan point to a custom layer (which is then deemed a \"bootstrap\" layer that needs to be\nchecked out first), or into a completely independent location.\n\nThe replication of the layers is performed by running the ``setup-layers`` script provided\nabove:\n\n#. Clone the bootstrap layer or some other repository to obtain\n   the json config and the setup script that can use it.\n\n#. Run the script directly with no options::\n\n      alex@Zen2:/srv/work/alex/my-build$ meta-alex/setup-layers\n      Note: not checking out source meta-alex, use --force-bootstraplayer-checkout to override.\n\n      Setting up source meta-intel, revision 15.0-hardknott-3.3-310-g0a96edae, branch master\n      Running 'git init -q /srv/work/alex/my-build/meta-intel'\n      Running 'git remote remove origin > /dev/null 2>&1; git remote add origin git://git.yoctoproject.org/meta-intel' in /srv/work/alex/my-build/meta-intel\n      Running 'git fetch -q origin || true' in /srv/work/alex/my-build/meta-intel\n      Running 'git checkout -q 0a96edae609a3f48befac36af82cf1eed6786b4a' in /srv/work/alex/my-build/meta-intel\n\n"}
{"text": "\n\nUnderstanding and Creating Layers\n      Setting up source poky, revision 4.1_M1-372-g55483d28f2, branch akanavin/setup-layers\n      Running 'git init -q /srv/work/alex/my-build/poky'\n      Running 'git remote remove origin > /dev/null 2>&1; git remote add origin git://git.yoctoproject.org/poky' in /srv/work/alex/my-build/poky\n      Running 'git fetch -q origin || true' in /srv/work/alex/my-build/poky\n      Running 'git remote remove poky-contrib > /dev/null 2>&1; git remote add poky-contrib ssh://git@push.yoctoproject.org/poky-contrib' in /srv/work/alex/my-build/poky\n      Running 'git fetch -q poky-contrib || true' in /srv/work/alex/my-build/poky\n      Running 'git checkout -q 11db0390b02acac1324e0f827beb0e2e3d0d1d63' in /srv/work/alex/my-build/poky\n\n.. note::\n   This will work to update an existing checkout as well.\n\n.. note::\n   The script is self-sufficient and requires only python3\n   and git on the build machine.\n\n.. note::\n   Both the ``create-layers-setup`` and the ``setup-layers`` provided several additional options\n   that customize their behavior - you are welcome to study them via ``--help`` command line parameter.\n\n"}
{"text": "\n\n\n\n******************************************\nThe Yocto Project Development Tasks Manual\n******************************************\n\nWelcome\n=======\n\nWelcome to the Yocto Project Development Tasks Manual. This manual\nprovides relevant procedures necessary for developing in the Yocto\nProject environment (i.e. developing embedded Linux images and\nuser-space applications that run on targeted devices). This manual groups\nrelated procedures into higher-level sections. Procedures can consist of\nhigh-level steps or low-level steps depending on the topic.\n\nThis manual provides the following:\n\n-  Procedures that help you get going with the Yocto Project; for\n   example, procedures that show you how to set up a build host and work\n   with the Yocto Project source repositories.\n\n-  Procedures that show you how to submit changes to the Yocto Project.\n   Changes can be improvements, new features, or bug fixes.\n\n-  Procedures related to \"everyday\" tasks you perform while developing\n   images and applications using the Yocto Project, such as\n   creating a new layer, customizing an image, writing a new recipe,\n   and so forth.\n\nThis manual does not provide the following:\n\n-  Redundant step-by-step instructions: For example, the\n   :doc:`/sdk-manual/index` manual contains detailed\n   instructions on how to install an SDK, which is used to develop\n   applications for target hardware.\n\n-  Reference or conceptual material: This type of material resides in an\n   appropriate reference manual. As an example, system variables are\n   documented in the :doc:`/ref-manual/index`.\n\n-  Detailed public information not specific to the Yocto Project: For\n   example, exhaustive information on how to use the Git version\n   control system is better covered with Internet searches and official Git\n   documentation than through the Yocto Project documentation.\n\nOther Information\n=================\n\nBecause this manual presents information for many different topics,\nsupplemental information is recommended for full comprehension. For\nintroductory information on the Yocto Project, see the\n:yocto_home:`Yocto Project Website <>`. If you want to build an image with no\nknowledge of Yocto Project as a way of quickly testing it out, see the\n:doc:`/brief-yoctoprojectqs/index` document.\n\nFor a comprehensive list of links and other documentation, see the\n\":ref:`ref-manual/resources:links and related documentation`\"\nsection in the Yocto Project Reference Manual.\n"}
{"text": "\n\nMaintaining Build Output Quality\n\n\nMaintaining Build Output Quality\n********************************\n\nMany factors can influence the quality of a build. For example, if you\nupgrade a recipe to use a new version of an upstream software package or\nyou experiment with some new configuration options, subtle changes can\noccur that you might not detect until later. Consider the case where\nyour recipe is using a newer version of an upstream package. In this\ncase, a new version of a piece of software might introduce an optional\ndependency on another library, which is auto-detected. If that library\nhas already been built when the software is building, the software will\nlink to the built library and that library will be pulled into your\nimage along with the new software even if you did not want the library.\n\nThe :ref:`ref-classes-buildhistory` class helps you maintain the quality of\nyour build output. You can use the class to highlight unexpected and possibly\nunwanted changes in the build output. When you enable build history, it records\ninformation about the contents of each package and image and then commits that\ninformation to a local Git repository where you can examine the information.\n\nThe remainder of this section describes the following:\n\n-  :ref:`How you can enable and disable build history <dev-manual/build-quality:enabling and disabling build history>`\n\n-  :ref:`How to understand what the build history contains <dev-manual/build-quality:understanding what the build history contains>`\n\n-  :ref:`How to limit the information used for build history <dev-manual/build-quality:using build history to gather image information only>`\n\n-  :ref:`How to examine the build history from both a command-line and web interface <dev-manual/build-quality:examining build history information>`\n\nEnabling and Disabling Build History\n====================================\n\nBuild history is disabled by default. To enable it, add the following\n:term:`INHERIT` statement and set the :term:`BUILDHISTORY_COMMIT` variable to\n\"1\" at the end of your ``conf/local.conf`` file found in the\n:term:`Build Directory`::\n\n   INHERIT += \"buildhistory\"\n   BUILDHISTORY_COMMIT = \"1\"\n\nEnabling build history as\npreviously described causes the OpenEmbedded build system to collect\nbuild output information and commit it as a single commit to a local\n:ref:`overview-manual/development-environment:git` repository.\n\n.. note::\n\n   Enabling build history increases your build times slightly,\n   particularly for images, and increases the amount of disk space used\n   during the build.\n\nYou can disable build history by removing the previous statements from\nyour ``conf/local.conf`` file.\n\nUnderstanding What the Build History Contains\n=============================================\n\nBuild history information is kept in ``${``\\ :term:`TOPDIR`\\ ``}/buildhistory``\nin the :term:`Build Directory` as defined by the :term:`BUILDHISTORY_DIR`\nvariable. Here is an example abbreviated listing:\n\n.. image:: figures/buildhistory.png\n   :align: center\n   :width: 50%\n\nAt the top level, there is a ``metadata-revs`` file that lists the\nrevisions of the repositories for the enabled layers when the build was\nproduced. The rest of the data splits into separate ``packages``,\n``images`` and ``sdk`` directories, the contents of which are described\nas follows.\n\nBuild History Package Information\n---------------------------------\n\nThe history for each package contains a text file that has name-value\npairs with information about the package. For example,\n``buildhistory/packages/i586-poky-linux/busybox/busybox/latest``\ncontains the following:\n\n.. code-block:: none\n\n   PV = 1.22.1\n   PR = r32\n   RPROVIDES =\n   RDEPENDS = glibc (>= 2.20) update-alternatives-opkg\n   RRECOMMENDS = busybox-syslog busybox-udhcpc update-rc.d\n   PKGSIZE = 540168\n   FILES = /usr/bin/* /usr/sbin/* /usr/lib/busybox/* /usr/lib/lib*.so.* \\\n      /etc /com /var /bin/* /sbin/* /lib/*.so.* /lib/udev/rules.d \\\n      /usr/lib/udev/rules.d /usr/share/busybox /usr/lib/busybox/* \\\n      /usr/share/pixmaps /usr/share/applications /usr/share/idl \\\n      /usr/share/omf /usr/share/sounds /usr/lib/bonobo/servers\n   FILELIST = /bin/busybox /bin/busybox.nosuid /bin/busybox.suid /bin/sh \\\n      /etc/busybox.links.nosuid /etc/busybox.links.suid\n\nMost of these\nname-value pairs correspond to variables used to produce the package.\n"}
{"text": "\n\nMaintaining Build Output Quality\nThe exceptions are ``FILELIST``, which is the actual list of files in\nthe package, and ``PKGSIZE``, which is the total size of files in the\npackage in bytes.\n\nThere is also a file that corresponds to the recipe from which the package\ncame (e.g. ``buildhistory/packages/i586-poky-linux/busybox/latest``):\n\n.. code-block:: none\n\n   PV = 1.22.1\n   PR = r32\n   DEPENDS = initscripts kern-tools-native update-rc.d-native \\\n      virtual/i586-poky-linux-compilerlibs virtual/i586-poky-linux-gcc \\\n      virtual/libc virtual/update-alternatives\n   PACKAGES = busybox-ptest busybox-httpd busybox-udhcpd busybox-udhcpc \\\n      busybox-syslog busybox-mdev busybox-hwclock busybox-dbg \\\n      busybox-staticdev busybox-dev busybox-doc busybox-locale busybox\n\nFinally, for those recipes fetched from a version control system (e.g.,\nGit), there is a file that lists source revisions that are specified in\nthe recipe and the actual revisions used during the build. Listed\nand actual revisions might differ when\n:term:`SRCREV` is set to\n${:term:`AUTOREV`}. Here is an\nexample assuming\n``buildhistory/packages/qemux86-poky-linux/linux-yocto/latest_srcrev``)::\n\n   # SRCREV_machine = \"38cd560d5022ed2dbd1ab0dca9642e47c98a0aa1\"\n   SRCREV_machine = \"38cd560d5022ed2dbd1ab0dca9642e47c98a0aa1\"\n   # SRCREV_meta = \"a227f20eff056e511d504b2e490f3774ab260d6f\"\n   SRCREV_meta =\"a227f20eff056e511d504b2e490f3774ab260d6f\"\n\nYou can use the\n``buildhistory-collect-srcrevs`` command with the ``-a`` option to\ncollect the stored :term:`SRCREV` values from build history and report them\nin a format suitable for use in global configuration (e.g.,\n``local.conf`` or a distro include file) to override floating\n:term:`AUTOREV` values to a fixed set of revisions. Here is some example\noutput from this command::\n\n   $ buildhistory-collect-srcrevs -a\n   # all-poky-linux\n   SRCREV:pn-ca-certificates = \"07de54fdcc5806bde549e1edf60738c6bccf50e8\"\n   SRCREV:pn-update-rc.d = \"8636cf478d426b568c1be11dbd9346f67e03adac\"\n   # core2-64-poky-linux\n   SRCREV:pn-binutils = \"87d4632d36323091e731eb07b8aa65f90293da66\"\n   SRCREV:pn-btrfs-tools = \"8ad326b2f28c044cb6ed9016d7c3285e23b673c8\"\n   SRCREV_bzip2-tests:pn-bzip2 = \"f9061c030a25de5b6829e1abf373057309c734c0\"\n   SRCREV:pn-e2fsprogs = \"02540dedd3ddc52c6ae8aaa8a95ce75c3f8be1c0\"\n   SRCREV:pn-file = \"504206e53a89fd6eed71aeaf878aa3512418eab1\"\n   SRCREV_glibc:pn-glibc = \"24962427071fa532c3c48c918e9d64d719cc8a6c\"\n   SRCREV:pn-gnome-desktop-testing = \"e346cd4ed2e2102c9b195b614f3c642d23f5f6e7\"\n   SRCREV:pn-init-system-helpers = \"dbd9197569c0935029acd5c9b02b84c68fd937ee\"\n   SRCREV:pn-kmod = \"b6ecfc916a17eab8f93be5b09f4e4f845aabd3d1\"\n   SRCREV:pn-libnsl2 = \"82245c0c58add79a8e34ab0917358217a70e5100\"\n   SRCREV:pn-libseccomp = \"57357d2741a3b3d3e8425889a6b79a130e0fa2f3\"\n   SRCREV:pn-libxcrypt = \"50cf2b6dd4fdf04309445f2eec8de7051d953abf\"\n   SRCREV:pn-ncurses = \"51d0fd9cc3edb975f04224f29f777f8f448e8ced\"\n   SRCREV:pn-procps = \"19a508ea121c0c4ac6d0224575a036de745eaaf8\"\n   SRCREV:pn-psmisc = \"5fab6b7ab385080f1db725d6803136ec1841a15f\"\n   SRCREV:pn-ptest-runner = \"bcb82804daa8f725b6add259dcef2067e61a75aa\"\n   SRCREV:pn-shared-mime-info = \"18e558fa1c8b90b86757ade09a4ba4d6a6cf8f70\"\n   SRCREV:pn-zstd = \"e47e674cd09583ff0503f0f6defd6d23d8b718d3\"\n   # qemux86_64-poky-linux\n   SRCREV_machine:pn-linux-yocto = \"20301aeb1a64164b72bc72af58802b315e025c9c\"\n   SRCREV_meta:pn-linux-yocto = \"2d38a472b21ae343707c8bd64ac68a9eaca066a0\"\n   # x86_64-linux\n   SRCREV:pn-binutils-cross-x86_64 = \"87d4632d36323091e731eb07b8aa65f90293da66\"\n   SRCREV_glibc:pn-cross-localedef-native = \"24962427071fa532c3c48c918e9d64d719cc8a6c\"\n   SRCREV_localedef:pn-cross-localedef-native = \"794da69788cbf9bf57b59a852f9f11307663fa87\"\n   SRCREV:pn-debianutils-native = \"de14223e5bffe15e374a441302c528ffc1cbed57\"\n   SRCREV:pn-libmodulemd-native = \"ee80309bc766d781a144e6879419b29f444d94eb\"\n   SRCREV:pn-virglrenderer-native = \"363915595e05fb252e70d6514be2f0c0b5ca312b\"\n   SRCREV:pn-zstd-native = \"e47e674cd09583ff0503f0f6defd6d23d8b718d3\"\n\n.. note::\n\n   Here are some notes on using the ``buildhistory-collect-srcrevs`` command:\n\n   -  By default, only values where the :term:`SRCREV` was not hardcoded\n      (usually when :term:`AUTOREV` is used) are reported. Use the ``-a``\n      option to see all :term:`SRCREV` values.\n\n   -  The output statements might not have any effect if overrides are\n      applied elsewhere in the build system configuration. Use the\n      ``-f`` option to add the ``forcevariable`` override to each output\n      line if you need to work around this restriction.\n\n   -  The script does apply special handling when building for multiple\n      machines. However, the script does place a comment before each set\n      of values that specifies which triplet to which they belong as\n      previously shown (e.g., ``i586-poky-linux``).\n\nBuild History Image Information\n-------------------------------\n\nThe files produced for each image are as follows:\n\n-  ``image-files:`` A directory containing selected files from the root\n   filesystem. The files are defined by\n"}
{"text": "\n\nMaintaining Build Output Quality\n   :term:`BUILDHISTORY_IMAGE_FILES`.\n\n-  ``build-id.txt:`` Human-readable information about the build\n   configuration and metadata source revisions. This file contains the\n   full build header as printed by BitBake.\n\n-  ``*.dot:`` Dependency graphs for the image that are compatible with\n   ``graphviz``.\n\n-  ``files-in-image.txt:`` A list of files in the image with\n   permissions, owner, group, size, and symlink information.\n\n-  ``image-info.txt:`` A text file containing name-value pairs with\n   information about the image. See the following listing example for\n   more information.\n\n-  ``installed-package-names.txt:`` A list of installed packages by name\n   only.\n\n-  ``installed-package-sizes.txt:`` A list of installed packages ordered\n   by size.\n\n-  ``installed-packages.txt:`` A list of installed packages with full\n   package filenames.\n\n.. note::\n\n   Installed package information is able to be gathered and produced\n   even if package management is disabled for the final image.\n\nHere is an example of ``image-info.txt``:\n\n.. code-block:: none\n\n   DISTRO = poky\n   DISTRO_VERSION = 3.4+snapshot-a0245d7be08f3d24ea1875e9f8872aa6bbff93be\n   USER_CLASSES = buildstats\n   IMAGE_CLASSES = qemuboot qemuboot license_image\n   IMAGE_FEATURES = debug-tweaks\n   IMAGE_LINGUAS =\n   IMAGE_INSTALL = packagegroup-core-boot speex speexdsp\n   BAD_RECOMMENDATIONS =\n   NO_RECOMMENDATIONS =\n   PACKAGE_EXCLUDE =\n   ROOTFS_POSTPROCESS_COMMAND = write_package_manifest; license_create_manifest; cve_check_write_rootfs_manifest;   ssh_allow_empty_password;  ssh_allow_root_login;  postinst_enable_logging;  rootfs_update_timestamp;   write_image_test_data;   empty_var_volatile;   sort_passwd; rootfs_reproducible;\n   IMAGE_POSTPROCESS_COMMAND =  buildhistory_get_imageinfo ;\n   IMAGESIZE = 9265\n\nOther than ``IMAGESIZE``,\nwhich is the total size of the files in the image in Kbytes, the\nname-value pairs are variables that may have influenced the content of\nthe image. This information is often useful when you are trying to\ndetermine why a change in the package or file listings has occurred.\n\nUsing Build History to Gather Image Information Only\n----------------------------------------------------\n\nAs you can see, build history produces image information, including\ndependency graphs, so you can see why something was pulled into the\nimage. If you are just interested in this information and not interested\nin collecting specific package or SDK information, you can enable\nwriting only image information without any history by adding the\nfollowing to your ``conf/local.conf`` file found in the\n:term:`Build Directory`::\n\n   INHERIT += \"buildhistory\"\n   BUILDHISTORY_COMMIT = \"0\"\n   BUILDHISTORY_FEATURES = \"image\"\n\nHere, you set the\n:term:`BUILDHISTORY_FEATURES`\nvariable to use the image feature only.\n\nBuild History SDK Information\n-----------------------------\n\nBuild history collects similar information on the contents of SDKs (e.g.\n``bitbake -c populate_sdk imagename``) as compared to information it\ncollects for images. Furthermore, this information differs depending on\nwhether an extensible or standard SDK is being produced.\n\nThe following list shows the files produced for SDKs:\n\n-  ``files-in-sdk.txt:`` A list of files in the SDK with permissions,\n   owner, group, size, and symlink information. This list includes both\n   the host and target parts of the SDK.\n\n-  ``sdk-info.txt:`` A text file containing name-value pairs with\n   information about the SDK. See the following listing example for more\n   information.\n\n-  ``sstate-task-sizes.txt:`` A text file containing name-value pairs\n   with information about task group sizes (e.g. :ref:`ref-tasks-populate_sysroot`\n   tasks have a total size). The ``sstate-task-sizes.txt`` file exists\n   only when an extensible SDK is created.\n\n-  ``sstate-package-sizes.txt:`` A text file containing name-value pairs\n   with information for the shared-state packages and sizes in the SDK.\n   The ``sstate-package-sizes.txt`` file exists only when an extensible\n   SDK is created.\n"}
{"text": "\n\nMaintaining Build Output Quality\n\n-  ``sdk-files:`` A folder that contains copies of the files mentioned\n   in ``BUILDHISTORY_SDK_FILES`` if the files are present in the output.\n   Additionally, the default value of ``BUILDHISTORY_SDK_FILES`` is\n   specific to the extensible SDK although you can set it differently if\n   you would like to pull in specific files from the standard SDK.\n\n   The default files are ``conf/local.conf``, ``conf/bblayers.conf``,\n   ``conf/auto.conf``, ``conf/locked-sigs.inc``, and\n   ``conf/devtool.conf``. Thus, for an extensible SDK, these files get\n   copied into the ``sdk-files`` directory.\n\n-  The following information appears under each of the ``host`` and\n   ``target`` directories for the portions of the SDK that run on the\n   host and on the target, respectively:\n\n   .. note::\n\n      The following files for the most part are empty when producing an\n      extensible SDK because this type of SDK is not constructed from\n      packages as is the standard SDK.\n\n   -  ``depends.dot:`` Dependency graph for the SDK that is compatible\n      with ``graphviz``.\n\n   -  ``installed-package-names.txt:`` A list of installed packages by\n      name only.\n\n   -  ``installed-package-sizes.txt:`` A list of installed packages\n      ordered by size.\n\n   -  ``installed-packages.txt:`` A list of installed packages with full\n      package filenames.\n\nHere is an example of ``sdk-info.txt``:\n\n.. code-block:: none\n\n   DISTRO = poky\n   DISTRO_VERSION = 1.3+snapshot-20130327\n   SDK_NAME = poky-glibc-i686-arm\n   SDK_VERSION = 1.3+snapshot\n   SDKMACHINE =\n   SDKIMAGE_FEATURES = dev-pkgs dbg-pkgs\n   BAD_RECOMMENDATIONS =\n   SDKSIZE = 352712\n\nOther than ``SDKSIZE``, which is\nthe total size of the files in the SDK in Kbytes, the name-value pairs\nare variables that might have influenced the content of the SDK. This\ninformation is often useful when you are trying to determine why a\nchange in the package or file listings has occurred.\n\nExamining Build History Information\n-----------------------------------\n\nYou can examine build history output from the command line or from a web\ninterface.\n\nTo see any changes that have occurred (assuming you have\n:term:`BUILDHISTORY_COMMIT`= \"1\"),\nyou can simply use any Git command that allows you to view the history\nof a repository. Here is one method::\n\n   $ git log -p\n\nYou need to realize,\nhowever, that this method does show changes that are not significant\n(e.g. a package's size changing by a few bytes).\n\nThere is a command-line tool called ``buildhistory-diff``, though,\nthat queries the Git repository and prints just the differences that\nmight be significant in human-readable form. Here is an example::\n\n   $ poky/poky/scripts/buildhistory-diff . HEAD^\n   Changes to images/qemux86_64/glibc/core-image-minimal (files-in-image.txt):\n      /etc/anotherpkg.conf was added\n      /sbin/anotherpkg was added\n      * (installed-package-names.txt):\n      *   anotherpkg was added\n   Changes to images/qemux86_64/glibc/core-image-minimal (installed-package-names.txt):\n      anotherpkg was added\n   packages/qemux86_64-poky-linux/v86d: PACKAGES: added \"v86d-extras\"\n      * PR changed from \"r0\" to \"r1\"\n      * PV changed from \"0.1.10\" to \"0.1.12\"\n   packages/qemux86_64-poky-linux/v86d/v86d: PKGSIZE changed from 110579 to 144381 (+30%)\n      * PR changed from \"r0\" to \"r1\"\n      * PV changed from \"0.1.10\" to \"0.1.12\"\n\n.. note::\n\n   The ``buildhistory-diff`` tool requires the ``GitPython``\n   package. Be sure to install it using Pip3 as follows::\n\n         $ pip3 install GitPython --user\n\n\n   Alternatively, you can install ``python3-git`` using the appropriate\n   distribution package manager (e.g. ``apt``, ``dnf``, or ``zipper``).\n\n"}
{"text": "\n\nMaintaining Build Output Quality\nTo see changes to the build history using a web interface, follow the\ninstruction in the ``README`` file\n:yocto_git:`here </buildhistory-web/>`.\n\nHere is a sample screenshot of the interface:\n\n.. image:: figures/buildhistory-web.png\n   :width: 100%\n\n"}
{"text": "\n\nWorking with Pre-Built Libraries\n\n\nWorking with Pre-Built Libraries\n********************************\n\nIntroduction\n============\n\nSome library vendors do not release source code for their software but do\nrelease pre-built binaries. When shared libraries are built, they should\nbe versioned (see `this article\n<https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html>`__\nfor some background), but sometimes this is not done.\n\nTo summarize, a versioned library must meet two conditions:\n\n#.    The filename must have the version appended, for example: ``libfoo.so.1.2.3``.\n#.    The library must have the ELF tag ``SONAME`` set to the major version\n      of the library, for example: ``libfoo.so.1``. You can check this by\n      running ``readelf -d filename | grep SONAME``.\n\nThis section shows how to deal with both versioned and unversioned\npre-built libraries.\n\nVersioned Libraries\n===================\n\nIn this example we work with pre-built libraries for the FT4222H USB I/O chip.\nLibraries are built for several target architecture variants and packaged in\nan archive as follows::\n\n    build-arm-hisiv300\n     libft4222.so.1.4.4.44\n    build-arm-v5-sf\n     libft4222.so.1.4.4.44\n    build-arm-v6-hf\n     libft4222.so.1.4.4.44\n    build-arm-v7-hf\n     libft4222.so.1.4.4.44\n    build-arm-v8\n     libft4222.so.1.4.4.44\n    build-i386\n     libft4222.so.1.4.4.44\n    build-i486\n     libft4222.so.1.4.4.44\n    build-mips-eglibc-hf\n     libft4222.so.1.4.4.44\n    build-pentium\n     libft4222.so.1.4.4.44\n    build-x86_64\n     libft4222.so.1.4.4.44\n    examples\n     get-version.c\n     i2cm.c\n     spim.c\n     spis.c\n    ftd2xx.h\n    install4222.sh\n    libft4222.h\n    ReadMe.txt\n    WinTypes.h\n\nTo write a recipe to use such a library in your system:\n\n-  The vendor will probably have a proprietary licence, so set\n   :term:`LICENSE_FLAGS` in your recipe.\n-  The vendor provides a tarball containing libraries so set :term:`SRC_URI`\n   appropriately.\n-  Set :term:`COMPATIBLE_HOST` so that the recipe cannot be used with an\n   unsupported architecture. In the following example, we only support the 32\n   and 64 bit variants of the ``x86`` architecture.\n-  As the vendor provides versioned libraries, we can use ``oe_soinstall``\n   from :ref:`ref-classes-utils` to install the shared library and create\n   symbolic links. If the vendor does not do this, we need to follow the\n   non-versioned library guidelines in the next section.\n-  As the vendor likely used :term:`LDFLAGS` different from those in your Yocto\n   Project build, disable the corresponding checks by adding ``ldflags``\n   to :term:`INSANE_SKIP`.\n-  The vendor will typically ship release builds without debugging symbols.\n   Avoid errors by preventing the packaging task from stripping out the symbols\n   and adding them to a separate debug package. This is done by setting the\n   ``INHIBIT_`` flags shown below.\n\nThe complete recipe would look like this::\n\n   SUMMARY = \"FTDI FT4222H Library\"\n   SECTION = \"libs\"\n   LICENSE_FLAGS = \"ftdi\"\n   LICENSE = \"CLOSED\"\n\n   COMPATIBLE_HOST = \"(i.86|x86_64).*-linux\"\n\n   # Sources available in a .tgz file in .zip archive\n   # at https://ftdichip.com/wp-content/uploads/2021/01/libft4222-linux-1.4.4.44.zip\n   # Found on https://ftdichip.com/software-examples/ft4222h-software-examples/\n   # Since dealing with this particular type of archive is out of topic here,\n   # we use a local link.\n   SRC_URI = \"file://libft4222-linux-${PV}.tgz\"\n\n   S = \"${WORKDIR}\"\n"}
{"text": "\n\nWorking with Pre-Built Libraries\n\n   ARCH_DIR:x86-64 = \"build-x86_64\"\n   ARCH_DIR:i586 = \"build-i386\"\n   ARCH_DIR:i686 = \"build-i386\"\n\n   INSANE_SKIP:${PN} = \"ldflags\"\n   INHIBIT_PACKAGE_STRIP = \"1\"\n   INHIBIT_SYSROOT_STRIP = \"1\"\n   INHIBIT_PACKAGE_DEBUG_SPLIT = \"1\"\n\n   do_install () {\n           install -m 0755 -d ${D}${libdir}\n           oe_soinstall ${S}/${ARCH_DIR}/libft4222.so.${PV} ${D}${libdir}\n           install -d ${D}${includedir}\n           install -m 0755 ${S}/*.h ${D}${includedir}\n   }\n\nIf the precompiled binaries are not statically linked and have dependencies on\nother libraries, then by adding those libraries to :term:`DEPENDS`, the linking\ncan be examined and the appropriate :term:`RDEPENDS` automatically added.\n\nNon-Versioned Libraries\n=======================\n\nSome Background\n---------------\n\nLibraries in Linux systems are generally versioned so that it is possible\nto have multiple versions of the same library installed, which eases upgrades\nand support for older software. For example, suppose that in a versioned\nlibrary, an actual library is called ``libfoo.so.1.2``, a symbolic link named\n``libfoo.so.1`` points to ``libfoo.so.1.2``, and a symbolic link named\n``libfoo.so`` points to ``libfoo.so.1.2``. Given these conditions, when you\nlink a binary against a library, you typically provide the unversioned file\nname (i.e. ``-lfoo`` to the linker). However, the linker follows the symbolic\nlink and actually links against the versioned filename. The unversioned symbolic\nlink is only used at development time. Consequently, the library is packaged\nalong with the headers in the development package ``${PN}-dev`` along with the\nactual library and versioned symbolic links in ``${PN}``. Because versioned\nlibraries are far more common than unversioned libraries, the default packaging\nrules assume versioned libraries.\n\nYocto Library Packaging Overview\n--------------------------------\n\nIt follows that packaging an unversioned library requires a bit of work in the\nrecipe. By default, ``libfoo.so`` gets packaged into ``${PN}-dev``, which\ntriggers a QA warning that a non-symlink library is in a ``-dev`` package,\nand binaries in the same recipe link to the library in ``${PN}-dev``,\nwhich triggers more QA warnings. To solve this problem, you need to package the\nunversioned library into ``${PN}`` where it belongs. The following are the abridged\ndefault :term:`FILES` variables in ``bitbake.conf``::\n\n   SOLIBS = \".so.*\"\n   SOLIBSDEV = \".so\"\n   FILES:${PN} = \"... ${libdir}/lib*${SOLIBS} ...\"\n   FILES_SOLIBSDEV ?= \"... ${libdir}/lib*${SOLIBSDEV} ...\"\n   FILES:${PN}-dev = \"... ${FILES_SOLIBSDEV} ...\"\n\n:term:`SOLIBS` defines a pattern that matches real shared object libraries.\n:term:`SOLIBSDEV` matches the development form (unversioned symlink). These two\nvariables are then used in ``FILES:${PN}`` and ``FILES:${PN}-dev``, which puts\nthe real libraries into ``${PN}`` and the unversioned symbolic link into ``${PN}-dev``.\nTo package unversioned libraries, you need to modify the variables in the recipe\nas follows::\n\n   SOLIBS = \".so\"\n   FILES_SOLIBSDEV = \"\"\n\nThe modifications cause the ``.so`` file to be the real library\nand unset :term:`FILES_SOLIBSDEV` so that no libraries get packaged into\n``${PN}-dev``. The changes are required because unless :term:`PACKAGES` is changed,\n``${PN}-dev`` collects files before `${PN}`. ``${PN}-dev`` must not collect any of\nthe files you want in ``${PN}``.\n\nFinally, loadable modules, essentially unversioned libraries that are linked\nat runtime using ``dlopen()`` instead of at build time, should generally be\ninstalled in a private directory. However, if they are installed in ``${libdir}``,\nthen the modules can be treated as unversioned libraries.\n\nExample\n-------\n\nThe example below installs an unversioned x86-64 pre-built library named\n``libfoo.so``. The :term:`COMPATIBLE_HOST` variable limits recipes to the\nx86-64 architecture while the :term:`INSANE_SKIP`, :term:`INHIBIT_PACKAGE_STRIP`\nand :term:`INHIBIT_SYSROOT_STRIP` variables are all set as in the above\nversioned library example. The \"magic\" is setting the :term:`SOLIBS` and\n:term:`FILES_SOLIBSDEV` variables as explained above::\n\n   SUMMARY = \"libfoo sample recipe\"\n   SECTION = \"libs\"\n   LICENSE = \"CLOSED\"\n\n   SRC_URI = \"file://libfoo.so\"\n\n   COMPATIBLE_HOST = \"x86_64.*-linux\"\n\n   INSANE_SKIP:${PN} = \"ldflags\"\n   INHIBIT_PACKAGE_STRIP = \"1\"\n"}
{"text": "\n\nWorking with Pre-Built Libraries\n   INHIBIT_SYSROOT_STRIP = \"1\"\n   SOLIBS = \".so\"\n   FILES_SOLIBSDEV = \"\"\n\n   do_install () {\n           install -d ${D}${libdir}\n           install -m 0755 ${WORKDIR}/libfoo.so ${D}${libdir}\n   }\n\n"}
{"text": "\n\nCreating a Software Bill of Materials\n\n\nCreating a Software Bill of Materials\n*************************************\n\nOnce you are able to build an image for your project, once the licenses for\neach software component are all identified (see\n\":ref:`dev-manual/licenses:working with licenses`\") and once vulnerability\nfixes are applied (see \":ref:`dev-manual/vulnerabilities:checking\nfor vulnerabilities`\"), the OpenEmbedded build system can generate\na description of all the components you used, their licenses, their dependencies,\ntheir sources, the changes that were applied to them and the known\nvulnerabilities that were fixed.\n\nThis description is generated in the form of a *Software Bill of Materials*\n(:term:`SBOM`), using the :term:`SPDX` standard.\n\nWhen you release software, this is the most standard way to provide information\nabout the Software Supply Chain of your software image and SDK. The\n:term:`SBOM` tooling is often used to ensure open source license compliance by\nproviding the license texts used in the product which legal departments and end\nusers can read in standardized format.\n\n:term:`SBOM` information is also critical to performing vulnerability exposure\nassessments, as all the components used in the Software Supply Chain are listed.\n\nThe OpenEmbedded build system doesn't generate such information by default.\nTo make this happen, you must inherit the\n:ref:`ref-classes-create-spdx` class from a configuration file::\n\n   INHERIT += \"create-spdx\"\n\nYou then get :term:`SPDX` output in JSON format as an\n``IMAGE-MACHINE.spdx.json`` file in ``tmp/deploy/images/MACHINE/`` inside the\n:term:`Build Directory`.\n\nThis is a toplevel file accompanied by an ``IMAGE-MACHINE.spdx.index.json``\ncontaining an index of JSON :term:`SPDX` files for individual recipes, together\nwith an ``IMAGE-MACHINE.spdx.tar.zst`` compressed archive containing all such\nfiles.\n\nThe :ref:`ref-classes-create-spdx` class offers options to include\nmore information in the output :term:`SPDX` data, such as making the generated\nfiles more human readable (:term:`SPDX_PRETTY`), adding compressed archives of\nthe files in the generated target packages (:term:`SPDX_ARCHIVE_PACKAGED`),\nadding a description of the source files used to generate host tools and target\npackages (:term:`SPDX_INCLUDE_SOURCES`) and adding archives of these source\nfiles themselves (:term:`SPDX_ARCHIVE_SOURCES`).\n\nThough the toplevel :term:`SPDX` output is available in\n``tmp/deploy/images/MACHINE/`` inside the :term:`Build Directory`, ancillary\ngenerated files are available in ``tmp/deploy/spdx/MACHINE`` too, such as:\n\n-  The individual :term:`SPDX` JSON files in the ``IMAGE-MACHINE.spdx.tar.zst``\n   archive.\n\n-  Compressed archives of the files in the generated target packages,\n   in ``packages/packagename.tar.zst`` (when :term:`SPDX_ARCHIVE_PACKAGED`\n   is set).\n\n-  Compressed archives of the source files used to build the host tools\n   and the target packages in ``recipes/recipe-packagename.tar.zst``\n   (when :term:`SPDX_ARCHIVE_SOURCES` is set). Those are needed to fulfill\n   \"source code access\" license requirements.\n\nSee also the :term:`SPDX_CUSTOM_ANNOTATION_VARS` variable which allows\nto associate custom notes to a recipe.\n\nSee the `tools page <https://spdx.dev/resources/tools/>`__ on the :term:`SPDX`\nproject website for a list of tools to consume and transform the :term:`SPDX`\ndata generated by the OpenEmbedded build system.\n\nSee also Joshua Watt's\n`Automated SBoM generation with OpenEmbedded and the Yocto Project <https://youtu.be/Q5UQUM6zxVU>`__\npresentation at FOSDEM 2023.\n"}
{"text": "\n\nEfficiently Fetching Source Files During a Build\n\n\nEfficiently Fetching Source Files During a Build\n************************************************\n\nThe OpenEmbedded build system works with source files located through\nthe :term:`SRC_URI` variable. When\nyou build something using BitBake, a big part of the operation is\nlocating and downloading all the source tarballs. For images,\ndownloading all the source for various packages can take a significant\namount of time.\n\nThis section shows you how you can use mirrors to speed up fetching\nsource files and how you can pre-fetch files all of which leads to more\nefficient use of resources and time.\n\nSetting up Effective Mirrors\n============================\n\nA good deal that goes into a Yocto Project build is simply downloading\nall of the source tarballs. Maybe you have been working with another\nbuild system for which you have built up a\nsizable directory of source tarballs. Or, perhaps someone else has such\na directory for which you have read access. If so, you can save time by\nadding statements to your configuration file so that the build process\nchecks local directories first for existing tarballs before checking the\nInternet.\n\nHere is an efficient way to set it up in your ``local.conf`` file::\n\n   SOURCE_MIRROR_URL ?= \"file:///home/you/your-download-dir/\"\n   INHERIT += \"own-mirrors\"\n   BB_GENERATE_MIRROR_TARBALLS = \"1\"\n   # BB_NO_NETWORK = \"1\"\n\nIn the previous example, the\n:term:`BB_GENERATE_MIRROR_TARBALLS`\nvariable causes the OpenEmbedded build system to generate tarballs of\nthe Git repositories and store them in the\n:term:`DL_DIR` directory. Due to\nperformance reasons, generating and storing these tarballs is not the\nbuild system's default behavior.\n\nYou can also use the\n:term:`PREMIRRORS` variable. For\nan example, see the variable's glossary entry in the Yocto Project\nReference Manual.\n\nGetting Source Files and Suppressing the Build\n==============================================\n\nAnother technique you can use to ready yourself for a successive string\nof build operations, is to pre-fetch all the source files without\nactually starting a build. This technique lets you work through any\ndownload issues and ultimately gathers all the source files into your\ndownload directory :ref:`structure-build-downloads`,\nwhich is located with :term:`DL_DIR`.\n\nUse the following BitBake command form to fetch all the necessary\nsources without starting the build::\n\n   $ bitbake target --runall=fetch\n\nThis\nvariation of the BitBake command guarantees that you have all the\nsources for that BitBake target should you disconnect from the Internet\nand want to do the build later offline.\n\n"}
{"text": "\n\nUsing x32 psABI\n\n\nUsing x32 psABI\n***************\n\nx32 processor-specific Application Binary Interface (`x32\npsABI <https://software.intel.com/en-us/node/628948>`__) is a native\n32-bit processor-specific ABI for Intel 64 (x86-64) architectures. An\nABI defines the calling conventions between functions in a processing\nenvironment. The interface determines what registers are used and what\nthe sizes are for various C data types.\n\nSome processing environments prefer using 32-bit applications even when\nrunning on Intel 64-bit platforms. Consider the i386 psABI, which is a\nvery old 32-bit ABI for Intel 64-bit platforms. The i386 psABI does not\nprovide efficient use and access of the Intel 64-bit processor\nresources, leaving the system underutilized. Now consider the x86_64\npsABI. This ABI is newer and uses 64-bits for data sizes and program\npointers. The extra bits increase the footprint size of the programs,\nlibraries, and also increases the memory and file system size\nrequirements. Executing under the x32 psABI enables user programs to\nutilize CPU and system resources more efficiently while keeping the\nmemory footprint of the applications low. Extra bits are used for\nregisters but not for addressing mechanisms.\n\nThe Yocto Project supports the final specifications of x32 psABI as\nfollows:\n\n-  You can create packages and images in x32 psABI format on x86_64\n   architecture targets.\n\n-  You can successfully build recipes with the x32 toolchain.\n\n-  You can create and boot ``core-image-minimal`` and\n   ``core-image-sato`` images.\n\n-  There is RPM Package Manager (RPM) support for x32 binaries.\n\n-  There is support for large images.\n\nTo use the x32 psABI, you need to edit your ``conf/local.conf``\nconfiguration file as follows::\n\n   MACHINE = \"qemux86-64\"\n   DEFAULTTUNE = \"x86-64-x32\"\n   baselib = \"${@d.getVar('BASE_LIB:tune-' + (d.getVar('DEFAULTTUNE') \\\n       or 'INVALID')) or 'lib'}\"\n\nOnce you have set\nup your configuration file, use BitBake to build an image that supports\nthe x32 psABI. Here is an example::\n\n   $ bitbake core-image-sato\n\n"}
{"text": "\n\nUsing a Python Development Shell\n\n\nUsing a Python Development Shell\n********************************\n\nSimilar to working within a development shell as described in the\nprevious section, you can also spawn and work within an interactive\nPython development shell. When debugging certain commands or even when\njust editing packages, ``pydevshell`` can be a useful tool. When you\ninvoke the ``pydevshell`` task, all tasks up to and including\n:ref:`ref-tasks-patch` are run for the\nspecified target. Then a new terminal is opened. Additionally, key\nPython objects and code are available in the same way they are to\nBitBake tasks, in particular, the data store 'd'. So, commands such as\nthe following are useful when exploring the data store and running\nfunctions::\n\n   pydevshell> d.getVar(\"STAGING_DIR\")\n   '/media/build1/poky/build/tmp/sysroots'\n   pydevshell> d.getVar(\"STAGING_DIR\", False)\n   '${TMPDIR}/sysroots'\n   pydevshell> d.setVar(\"FOO\", \"bar\")\n   pydevshell> d.getVar(\"FOO\")\n   'bar'\n   pydevshell> d.delVar(\"FOO\")\n   pydevshell> d.getVar(\"FOO\")\n   pydevshell> bb.build.exec_func(\"do_unpack\", d)\n   pydevshell>\n\nSee the \":ref:`bitbake-user-manual/bitbake-user-manual-metadata:functions you can call from within python`\"\nsection in the BitBake User Manual for details about available functions.\n\nThe commands execute just as if the OpenEmbedded build\nsystem were executing them. Consequently, working this way can be\nhelpful when debugging a build or preparing software to be used with the\nOpenEmbedded build system.\n\nFollowing is an example that uses ``pydevshell`` on a target named\n``matchbox-desktop``::\n\n   $ bitbake matchbox-desktop -c pydevshell\n\nThis command spawns a terminal and places you in an interactive Python\ninterpreter within the OpenEmbedded build environment. The\n:term:`OE_TERMINAL` variable\ncontrols what type of shell is opened.\n\nWhen you are finished using ``pydevshell``, you can exit the shell\neither by using Ctrl+d or closing the terminal window.\n\n"}
{"text": "\n\nWorking With Libraries\n\n\nWorking With Libraries\n**********************\n\nLibraries are an integral part of your system. This section describes\nsome common practices you might find helpful when working with libraries\nto build your system:\n\n-  :ref:`How to include static library files\n   <dev-manual/libraries:including static library files>`\n\n-  :ref:`How to use the Multilib feature to combine multiple versions of\n   library files into a single image\n   <dev-manual/libraries:combining multiple versions of library files into one image>`\n\n-  :ref:`How to install multiple versions of the same library in parallel on\n   the same system\n   <dev-manual/libraries:installing multiple versions of the same library>`\n\nIncluding Static Library Files\n==============================\n\nIf you are building a library and the library offers static linking, you\ncan control which static library files (``*.a`` files) get included in\nthe built library.\n\nThe :term:`PACKAGES` and\n:term:`FILES:* <FILES>` variables in the\n``meta/conf/bitbake.conf`` configuration file define how files installed\nby the :ref:`ref-tasks-install` task are packaged. By default, the :term:`PACKAGES`\nvariable includes ``${PN}-staticdev``, which represents all static\nlibrary files.\n\n.. note::\n\n   Some previously released versions of the Yocto Project defined the\n   static library files through ``${PN}-dev``.\n\nFollowing is part of the BitBake configuration file, where you can see\nhow the static library files are defined::\n\n   PACKAGE_BEFORE_PN ?= \"\"\n   PACKAGES = \"${PN}-src ${PN}-dbg ${PN}-staticdev ${PN}-dev ${PN}-doc ${PN}-locale ${PACKAGE_BEFORE_PN} ${PN}\"\n   PACKAGES_DYNAMIC = \"^${PN}-locale-.*\"\n   FILES = \"\"\n\n   FILES:${PN} = \"${bindir}/* ${sbindir}/* ${libexecdir}/* ${libdir}/lib*${SOLIBS} \\\n               ${sysconfdir} ${sharedstatedir} ${localstatedir} \\\n               ${base_bindir}/* ${base_sbindir}/* \\\n               ${base_libdir}/*${SOLIBS} \\\n               ${base_prefix}/lib/udev ${prefix}/lib/udev \\\n               ${base_libdir}/udev ${libdir}/udev \\\n               ${datadir}/${BPN} ${libdir}/${BPN}/* \\\n               ${datadir}/pixmaps ${datadir}/applications \\\n               ${datadir}/idl ${datadir}/omf ${datadir}/sounds \\\n               ${libdir}/bonobo/servers\"\n\n   FILES:${PN}-bin = \"${bindir}/* ${sbindir}/*\"\n\n   FILES:${PN}-doc = \"${docdir} ${mandir} ${infodir} ${datadir}/gtk-doc \\\n               ${datadir}/gnome/help\"\n   SECTION:${PN}-doc = \"doc\"\n\n   FILES_SOLIBSDEV ?= \"${base_libdir}/lib*${SOLIBSDEV} ${libdir}/lib*${SOLIBSDEV}\"\n   FILES:${PN}-dev = \"${includedir} ${FILES_SOLIBSDEV} ${libdir}/*.la \\\n                   ${libdir}/*.o ${libdir}/pkgconfig ${datadir}/pkgconfig \\\n                   ${datadir}/aclocal ${base_libdir}/*.o \\\n                   ${libdir}/${BPN}/*.la ${base_libdir}/*.la \\\n                   ${libdir}/cmake ${datadir}/cmake\"\n   SECTION:${PN}-dev = \"devel\"\n   ALLOW_EMPTY:${PN}-dev = \"1\"\n   RDEPENDS:${PN}-dev = \"${PN} (= ${EXTENDPKGV})\"\n\n   FILES:${PN}-staticdev = \"${libdir}/*.a ${base_libdir}/*.a ${libdir}/${BPN}/*.a\"\n   SECTION:${PN}-staticdev = \"devel\"\n   RDEPENDS:${PN}-staticdev = \"${PN}-dev (= ${EXTENDPKGV})\"\n\nCombining Multiple Versions of Library Files into One Image\n===========================================================\n\nThe build system offers the ability to build libraries with different\ntarget optimizations or architecture formats and combine these together\ninto one system image. You can link different binaries in the image\nagainst the different libraries as needed for specific use cases. This\nfeature is called \"Multilib\".\n\nAn example would be where you have most of a system compiled in 32-bit\nmode using 32-bit libraries, but you have something large, like a\ndatabase engine, that needs to be a 64-bit application and uses 64-bit\nlibraries. Multilib allows you to get the best of both 32-bit and 64-bit\nlibraries.\n\nWhile the Multilib feature is most commonly used for 32 and 64-bit\ndifferences, the approach the build system uses facilitates different\ntarget optimizations. You could compile some binaries to use one set of\nlibraries and other binaries to use a different set of libraries. The\nlibraries could differ in architecture, compiler options, or other\noptimizations.\n\n"}
{"text": "\n\nWorking With Libraries\nThere are several examples in the ``meta-skeleton`` layer found in the\n:term:`Source Directory`:\n\n-  :oe_git:`conf/multilib-example.conf </openembedded-core/tree/meta-skeleton/conf/multilib-example.conf>`\n   configuration file.\n\n-  :oe_git:`conf/multilib-example2.conf </openembedded-core/tree/meta-skeleton/conf/multilib-example2.conf>`\n   configuration file.\n\n-  :oe_git:`recipes-multilib/images/core-image-multilib-example.bb </openembedded-core/tree/meta-skeleton/recipes-multilib/images/core-image-multilib-example.bb>`\n   recipe\n\nPreparing to Use Multilib\n-------------------------\n\nUser-specific requirements drive the Multilib feature. Consequently,\nthere is no one \"out-of-the-box\" configuration that would\nmeet your needs.\n\nIn order to enable Multilib, you first need to ensure your recipe is\nextended to support multiple libraries. Many standard recipes are\nalready extended and support multiple libraries. You can check in the\n``meta/conf/multilib.conf`` configuration file in the\n:term:`Source Directory` to see how this is\ndone using the\n:term:`BBCLASSEXTEND` variable.\nEventually, all recipes will be covered and this list will not be\nneeded.\n\nFor the most part, the :ref:`Multilib <ref-classes-multilib*>`\nclass extension works automatically to\nextend the package name from ``${PN}`` to ``${MLPREFIX}${PN}``, where\n:term:`MLPREFIX` is the particular multilib (e.g. \"lib32-\" or \"lib64-\").\nStandard variables such as\n:term:`DEPENDS`,\n:term:`RDEPENDS`,\n:term:`RPROVIDES`,\n:term:`RRECOMMENDS`,\n:term:`PACKAGES`, and\n:term:`PACKAGES_DYNAMIC` are\nautomatically extended by the system. If you are extending any manual\ncode in the recipe, you can use the ``${MLPREFIX}`` variable to ensure\nthose names are extended correctly.\n\nUsing Multilib\n--------------\n\nAfter you have set up the recipes, you need to define the actual\ncombination of multiple libraries you want to build. You accomplish this\nthrough your ``local.conf`` configuration file in the\n:term:`Build Directory`. An example configuration would be as follows::\n\n   MACHINE = \"qemux86-64\"\n   require conf/multilib.conf\n   MULTILIBS = \"multilib:lib32\"\n   DEFAULTTUNE:virtclass-multilib-lib32 = \"x86\"\n   IMAGE_INSTALL:append = \" lib32-glib-2.0\"\n\nThis example enables an additional library named\n``lib32`` alongside the normal target packages. When combining these\n\"lib32\" alternatives, the example uses \"x86\" for tuning. For information\non this particular tuning, see\n``meta/conf/machine/include/ia32/arch-ia32.inc``.\n\nThe example then includes ``lib32-glib-2.0`` in all the images, which\nillustrates one method of including a multiple library dependency. You\ncan use a normal image build to include this dependency, for example::\n\n   $ bitbake core-image-sato\n\nYou can also build Multilib packages\nspecifically with a command like this::\n\n   $ bitbake lib32-glib-2.0\n\nAdditional Implementation Details\n---------------------------------\n\nThere are generic implementation details as well as details that are specific to\npackage management systems. Following are implementation details\nthat exist regardless of the package management system:\n\n-  The typical convention used for the class extension code as used by\n   Multilib assumes that all package names specified in\n   :term:`PACKAGES` that contain\n   ``${PN}`` have ``${PN}`` at the start of the name. When that\n   convention is not followed and ``${PN}`` appears at the middle or the\n   end of a name, problems occur.\n\n-  The :term:`TARGET_VENDOR`\n   value under Multilib will be extended to \"-vendormlmultilib\" (e.g.\n   \"-pokymllib32\" for a \"lib32\" Multilib with Poky). The reason for this\n   slightly unwieldy contraction is that any \"-\" characters in the\n   vendor string presently break Autoconf's ``config.sub``, and other\n   separators are problematic for different reasons.\n\nHere are the implementation details for the RPM Package Management System:\n\n-  A unique architecture is defined for the Multilib packages, along\n   with creating a unique deploy folder under ``tmp/deploy/rpm`` in the\n"}
{"text": "\n\nWorking With Libraries\n   :term:`Build Directory`. For example, consider ``lib32`` in a\n   ``qemux86-64`` image. The possible architectures in the system are \"all\",\n   \"qemux86_64\", \"lib32:qemux86_64\", and \"lib32:x86\".\n\n-  The ``${MLPREFIX}`` variable is stripped from ``${PN}`` during RPM\n   packaging. The naming for a normal RPM package and a Multilib RPM\n   package in a ``qemux86-64`` system resolves to something similar to\n   ``bash-4.1-r2.x86_64.rpm`` and ``bash-4.1.r2.lib32_x86.rpm``,\n   respectively.\n\n-  When installing a Multilib image, the RPM backend first installs the\n   base image and then installs the Multilib libraries.\n\n-  The build system relies on RPM to resolve the identical files in the\n   two (or more) Multilib packages.\n\nHere are the implementation details for the IPK Package Management System:\n\n-  The ``${MLPREFIX}`` is not stripped from ``${PN}`` during IPK\n   packaging. The naming for a normal RPM package and a Multilib IPK\n   package in a ``qemux86-64`` system resolves to something like\n   ``bash_4.1-r2.x86_64.ipk`` and ``lib32-bash_4.1-rw:x86.ipk``,\n   respectively.\n\n-  The IPK deploy folder is not modified with ``${MLPREFIX}`` because\n   packages with and without the Multilib feature can exist in the same\n   folder due to the ``${PN}`` differences.\n\n-  IPK defines a sanity check for Multilib installation using certain\n   rules for file comparison, overridden, etc.\n\nInstalling Multiple Versions of the Same Library\n================================================\n\nThere are be situations where you need to install and use multiple versions\nof the same library on the same system at the same time. This\nalmost always happens when a library API changes and you have\nmultiple pieces of software that depend on the separate versions of the\nlibrary. To accommodate these situations, you can install multiple\nversions of the same library in parallel on the same system.\n\nThe process is straightforward as long as the libraries use proper\nversioning. With properly versioned libraries, all you need to do to\nindividually specify the libraries is create separate, appropriately\nnamed recipes where the :term:`PN` part of\nthe name includes a portion that differentiates each library version\n(e.g. the major part of the version number). Thus, instead of having a\nsingle recipe that loads one version of a library (e.g. ``clutter``),\nyou provide multiple recipes that result in different versions of the\nlibraries you want. As an example, the following two recipes would allow\nthe two separate versions of the ``clutter`` library to co-exist on the\nsame system:\n\n.. code-block:: none\n\n   clutter-1.6_1.6.20.bb\n   clutter-1.8_1.8.4.bb\n\nAdditionally, if\nyou have other recipes that depend on a given library, you need to use\nthe :term:`DEPENDS` variable to\ncreate the dependency. Continuing with the same example, if you want to\nhave a recipe depend on the 1.8 version of the ``clutter`` library, use\nthe following in your recipe::\n\n   DEPENDS = \"clutter-1.8\"\n\n"}
{"text": "\n\nMaking Images More Secure\n\n\nMaking Images More Secure\n*************************\n\nSecurity is of increasing concern for embedded devices. Consider the\nissues and problems discussed in just this sampling of work found across\nthe Internet:\n\n-  *\"*\\ `Security Risks of Embedded\n   Systems <https://www.schneier.com/blog/archives/2014/01/security_risks_9.html>`__\\ *\"*\n   by Bruce Schneier\n\n-  *\"*\\ `Internet Census\n   2012 <http://census2012.sourceforge.net/paper.html>`__\\ *\"* by Carna\n   Botnet\n\n-  *\"*\\ `Security Issues for Embedded\n   Devices <https://elinux.org/images/6/6f/Security-issues.pdf>`__\\ *\"*\n   by Jake Edge\n\nWhen securing your image is of concern, there are steps, tools, and\nvariables that you can consider to help you reach the security goals you\nneed for your particular device. Not all situations are identical when\nit comes to making an image secure. Consequently, this section provides\nsome guidance and suggestions for consideration when you want to make\nyour image more secure.\n\n.. note::\n\n   Because the security requirements and risks are different for every\n   type of device, this section cannot provide a complete reference on\n   securing your custom OS. It is strongly recommended that you also\n   consult other sources of information on embedded Linux system\n   hardening and on security.\n\nGeneral Considerations\n======================\n\nThere are general considerations that help you create more secure images.\nYou should consider the following suggestions to make your device\nmore secure:\n\n-  Scan additional code you are adding to the system (e.g. application\n   code) by using static analysis tools. Look for buffer overflows and\n   other potential security problems.\n\n-  Pay particular attention to the security for any web-based\n   administration interface.\n\n   Web interfaces typically need to perform administrative functions and\n   tend to need to run with elevated privileges. Thus, the consequences\n   resulting from the interface's security becoming compromised can be\n   serious. Look for common web vulnerabilities such as\n   cross-site-scripting (XSS), unvalidated inputs, and so forth.\n\n   As with system passwords, the default credentials for accessing a\n   web-based interface should not be the same across all devices. This\n   is particularly true if the interface is enabled by default as it can\n   be assumed that many end-users will not change the credentials.\n\n-  Ensure you can update the software on the device to mitigate\n   vulnerabilities discovered in the future. This consideration\n   especially applies when your device is network-enabled.\n\n-  Regularly scan and apply fixes for CVE security issues affecting\n   all software components in the product, see \":ref:`dev-manual/vulnerabilities:checking for vulnerabilities`\".\n\n-  Regularly update your version of Poky and OE-Core from their upstream\n   developers, e.g. to apply updates and security fixes from stable\n   and :term:`LTS` branches.\n\n-  Ensure you remove or disable debugging functionality before producing\n   the final image. For information on how to do this, see the\n   \":ref:`dev-manual/securing-images:considerations specific to the openembedded build system`\"\n   section.\n\n-  Ensure you have no network services listening that are not needed.\n\n-  Remove any software from the image that is not needed.\n\n-  Enable hardware support for secure boot functionality when your\n   device supports this functionality.\n\nSecurity Flags\n==============\n\nThe Yocto Project has security flags that you can enable that help make\nyour build output more secure. The security flags are in the\n``meta/conf/distro/include/security_flags.inc`` file in your\n:term:`Source Directory` (e.g. ``poky``).\n\n.. note::\n\n   Depending on the recipe, certain security flags are enabled and\n   disabled by default.\n\nUse the following line in your ``local.conf`` file or in your custom\ndistribution configuration file to enable the security compiler and\nlinker flags for your build::\n"}
{"text": "\n\nMaking Images More Secure\n\n   require conf/distro/include/security_flags.inc\n\nConsiderations Specific to the OpenEmbedded Build System\n========================================================\n\nYou can take some steps that are specific to the OpenEmbedded build\nsystem to make your images more secure:\n\n-  Ensure \"debug-tweaks\" is not one of your selected\n   :term:`IMAGE_FEATURES`.\n   When creating a new project, the default is to provide you with an\n   initial ``local.conf`` file that enables this feature using the\n   :term:`EXTRA_IMAGE_FEATURES`\n   variable with the line::\n\n      EXTRA_IMAGE_FEATURES = \"debug-tweaks\"\n\n   To disable that feature, simply comment out that line in your\n   ``local.conf`` file, or make sure :term:`IMAGE_FEATURES` does not contain\n   \"debug-tweaks\" before producing your final image. Among other things,\n   leaving this in place sets the root password as blank, which makes\n   logging in for debugging or inspection easy during development but\n   also means anyone can easily log in during production.\n\n-  It is possible to set a root password for the image and also to set\n   passwords for any extra users you might add (e.g. administrative or\n   service type users). When you set up passwords for multiple images or\n   users, you should not duplicate passwords.\n\n   To set up passwords, use the :ref:`ref-classes-extrausers` class, which\n   is the preferred method. For an example on how to set up both root and\n   user passwords, see the \":ref:`ref-classes-extrausers`\" section.\n\n   .. note::\n\n      When adding extra user accounts or setting a root password, be\n      cautious about setting the same password on every device. If you\n      do this, and the password you have set is exposed, then every\n      device is now potentially compromised. If you need this access but\n      want to ensure security, consider setting a different, random\n      password for each device. Typically, you do this as a separate\n      step after you deploy the image onto the device.\n\n-  Consider enabling a Mandatory Access Control (MAC) framework such as\n   SMACK or SELinux and tuning it appropriately for your device's usage.\n   You can find more information in the\n   :yocto_git:`meta-selinux </meta-selinux/>` layer.\n\nTools for Hardening Your Image\n==============================\n\nThe Yocto Project provides tools for making your image more secure. You\ncan find these tools in the ``meta-security`` layer of the\n:yocto_git:`Yocto Project Source Repositories <>`.\n\n"}
{"text": "\n\nAdding a New Machine\n\n\nAdding a New Machine\n********************\n\nAdding a new machine to the Yocto Project is a straightforward process.\nThis section describes how to add machines that are similar to those\nthat the Yocto Project already supports.\n\n.. note::\n\n   Although well within the capabilities of the Yocto Project, adding a\n   totally new architecture might require changes to ``gcc``/``glibc``\n   and to the site information, which is beyond the scope of this\n   manual.\n\nFor a complete example that shows how to add a new machine, see the\n\":ref:`bsp-guide/bsp:creating a new bsp layer using the \\`\\`bitbake-layers\\`\\` script`\"\nsection in the Yocto Project Board Support Package (BSP) Developer's\nGuide.\n\nAdding the Machine Configuration File\n=====================================\n\nTo add a new machine, you need to add a new machine configuration file\nto the layer's ``conf/machine`` directory. This configuration file\nprovides details about the device you are adding.\n\nThe OpenEmbedded build system uses the root name of the machine\nconfiguration file to reference the new machine. For example, given a\nmachine configuration file named ``crownbay.conf``, the build system\nrecognizes the machine as \"crownbay\".\n\nThe most important variables you must set in your machine configuration\nfile or include from a lower-level configuration file are as follows:\n\n-  :term:`TARGET_ARCH` (e.g. \"arm\")\n\n-  ``PREFERRED_PROVIDER_virtual/kernel``\n\n-  :term:`MACHINE_FEATURES` (e.g. \"screen wifi\")\n\nYou might also need these variables:\n\n-  :term:`SERIAL_CONSOLES` (e.g. \"115200;ttyS0 115200;ttyS1\")\n\n-  :term:`KERNEL_IMAGETYPE` (e.g. \"zImage\")\n\n-  :term:`IMAGE_FSTYPES` (e.g. \"tar.gz jffs2\")\n\nYou can find full details on these variables in the reference section.\nYou can leverage existing machine ``.conf`` files from\n``meta-yocto-bsp/conf/machine/``.\n\nAdding a Kernel for the Machine\n===============================\n\nThe OpenEmbedded build system needs to be able to build a kernel for the\nmachine. You need to either create a new kernel recipe for this machine,\nor extend an existing kernel recipe. You can find several kernel recipe\nexamples in the Source Directory at ``meta/recipes-kernel/linux`` that\nyou can use as references.\n\nIf you are creating a new kernel recipe, normal recipe-writing rules\napply for setting up a :term:`SRC_URI`. Thus, you need to specify any\nnecessary patches and set :term:`S` to point at the source code. You need to\ncreate a :ref:`ref-tasks-configure` task that configures the unpacked kernel with\na ``defconfig`` file. You can do this by using a ``make defconfig``\ncommand or, more commonly, by copying in a suitable ``defconfig`` file\nand then running ``make oldconfig``. By making use of ``inherit kernel``\nand potentially some of the ``linux-*.inc`` files, most other\nfunctionality is centralized and the defaults of the class normally work\nwell.\n\nIf you are extending an existing kernel recipe, it is usually a matter\nof adding a suitable ``defconfig`` file. The file needs to be added into\na location similar to ``defconfig`` files used for other machines in a\ngiven kernel recipe. A possible way to do this is by listing the file in\nthe :term:`SRC_URI` and adding the machine to the expression in\n:term:`COMPATIBLE_MACHINE`::\n\n   COMPATIBLE_MACHINE = '(qemux86|qemumips)'\n\nFor more information on ``defconfig`` files, see the\n\":ref:`kernel-dev/common:changing the configuration`\"\nsection in the Yocto Project Linux Kernel Development Manual.\n\nAdding a Formfactor Configuration File\n======================================\n\nA formfactor configuration file provides information about the target\nhardware for which the image is being built and information that the\nbuild system cannot obtain from other sources such as the kernel. Some\nexamples of information contained in a formfactor configuration file\ninclude framebuffer orientation, whether or not the system has a\nkeyboard, the positioning of the keyboard in relation to the screen, and\nthe screen resolution.\n\nThe build system uses reasonable defaults in most cases. However, if\ncustomization is necessary, you need to create a ``machconfig`` file in\n"}
{"text": "\n\nAdding a New Machine\nthe ``meta/recipes-bsp/formfactor/files`` directory. This directory\ncontains directories for specific machines such as ``qemuarm`` and\n``qemux86``. For information about the settings available and the\ndefaults, see the ``meta/recipes-bsp/formfactor/files/config`` file\nfound in the same area.\n\nFollowing is an example for \"qemuarm\" machine::\n\n   HAVE_TOUCHSCREEN=1\n   HAVE_KEYBOARD=1\n   DISPLAY_CAN_ROTATE=0\n   DISPLAY_ORIENTATION=0\n   #DISPLAY_WIDTH_PIXELS=640\n   #DISPLAY_HEIGHT_PIXELS=480\n   #DISPLAY_BPP=16\n   DISPLAY_DPI=150\n   DISPLAY_SUBPIXEL_ORDER=vrgb\n\n"}
{"text": "\n\nConserving Disk Space\n\n\nConserving Disk Space\n*********************\n\nConserving Disk Space During Builds\n===================================\n\nTo help conserve disk space during builds, you can add the following\nstatement to your project's ``local.conf`` configuration file found in\nthe :term:`Build Directory`::\n\n   INHERIT += \"rm_work\"\n\nAdding this statement deletes the work directory used for\nbuilding a recipe once the recipe is built. For more information on\n\"rm_work\", see the :ref:`ref-classes-rm-work` class in the\nYocto Project Reference Manual.\n\nWhen you inherit this class and build a ``core-image-sato`` image for a\n``qemux86-64`` machine from an Ubuntu 22.04 x86-64 system, you end up with a\nfinal disk usage of 22 Gbytes instead of &MIN_DISK_SPACE; Gbytes. However,\n&MIN_DISK_SPACE_RM_WORK; Gbytes of initial free disk space are still needed to\ncreate temporary files before they can be deleted.\n\nPurging Obsolete Shared State Cache Files\n=========================================\n\nAfter multiple build iterations, the Shared State (sstate) cache can contain\nmultiple cache files for a given package, consuming a substantial amount of\ndisk space. However, only the most recent ones are likely to be reused.\n\nThe following command is a quick way to purge all the cache files which\nhaven't been used for a least a specified number of days::\n\n   find build/sstate-cache -type f -mtime +$DAYS -delete\n\nThe above command relies on the fact that BitBake touches the sstate cache\nfiles as it accesses them, when it has write access to the cache.\n\nYou could use ``-atime`` instead of ``-mtime`` if the partition isn't mounted\nwith the ``noatime`` option for a read only cache.\n\nFor more advanced needs, OpenEmbedded-Core also offers a more elaborate\ncommand. It has the ability to purge all but the newest cache files on each\narchitecture, and also to remove files that it considers unreachable by\nexploring a set of build configurations. However, this command\nrequires a full build environment to be available and doesn't work well\ncovering multiple releases. It won't work either on limited environments\nsuch as BSD based NAS::\n\n   sstate-cache-management.sh --remove-duplicated --cache-dir=build/sstate-cache\n\nThis command will ask you to confirm the deletions it identifies.\nRun ``sstate-cache-management.sh`` for more details about this script.\n\n.. note::\n\n   As this command is much more cautious and selective, removing only cache files,\n   it will execute much slower than the simple ``find`` command described above.\n   Therefore, it may not be your best option to trim huge cache directories.\n"}
{"text": "\n\nDebugging Tools and Techniques\n\n\nDebugging Tools and Techniques\n******************************\n\nThe exact method for debugging build failures depends on the nature of\nthe problem and on the system's area from which the bug originates.\nStandard debugging practices such as comparison against the last known\nworking version with examination of the changes and the re-application\nof steps to identify the one causing the problem are valid for the Yocto\nProject just as they are for any other system. Even though it is\nimpossible to detail every possible potential failure, this section\nprovides some general tips to aid in debugging given a variety of\nsituations.\n\n.. note::\n\n   A useful feature for debugging is the error reporting tool.\n   Configuring the Yocto Project to use this tool causes the\n   OpenEmbedded build system to produce error reporting commands as part\n   of the console output. You can enter the commands after the build\n   completes to log error information into a common database, that can\n   help you figure out what might be going wrong. For information on how\n   to enable and use this feature, see the\n   \":ref:`dev-manual/error-reporting-tool:using the error reporting tool`\"\n   section.\n\nThe following list shows the debugging topics in the remainder of this\nsection:\n\n-  \":ref:`dev-manual/debugging:viewing logs from failed tasks`\" describes\n   how to find and view logs from tasks that failed during the build\n   process.\n\n-  \":ref:`dev-manual/debugging:viewing variable values`\" describes how to\n   use the BitBake ``-e`` option to examine variable values after a\n   recipe has been parsed.\n\n-  \":ref:`dev-manual/debugging:viewing package information with \\`\\`oe-pkgdata-util\\`\\``\"\n   describes how to use the ``oe-pkgdata-util`` utility to query\n   :term:`PKGDATA_DIR` and\n   display package-related information for built packages.\n\n-  \":ref:`dev-manual/debugging:viewing dependencies between recipes and tasks`\"\n   describes how to use the BitBake ``-g`` option to display recipe\n   dependency information used during the build.\n\n-  \":ref:`dev-manual/debugging:viewing task variable dependencies`\" describes\n   how to use the ``bitbake-dumpsig`` command in conjunction with key\n   subdirectories in the :term:`Build Directory` to determine variable\n   dependencies.\n\n-  \":ref:`dev-manual/debugging:running specific tasks`\" describes\n   how to use several BitBake options (e.g. ``-c``, ``-C``, and ``-f``)\n   to run specific tasks in the build chain. It can be useful to run\n   tasks \"out-of-order\" when trying isolate build issues.\n\n-  \":ref:`dev-manual/debugging:general BitBake problems`\" describes how\n   to use BitBake's ``-D`` debug output option to reveal more about what\n   BitBake is doing during the build.\n\n-  \":ref:`dev-manual/debugging:building with no dependencies`\"\n   describes how to use the BitBake ``-b`` option to build a recipe\n   while ignoring dependencies.\n\n-  \":ref:`dev-manual/debugging:recipe logging mechanisms`\"\n   describes how to use the many recipe logging functions to produce\n   debugging output and report errors and warnings.\n\n-  \":ref:`dev-manual/debugging:debugging parallel make races`\"\n   describes how to debug situations where the build consists of several\n   parts that are run simultaneously and when the output or result of\n   one part is not ready for use with a different part of the build that\n   depends on that output.\n\n-  \":ref:`dev-manual/debugging:debugging with the gnu project debugger (gdb) remotely`\"\n   describes how to use GDB to allow you to examine running programs, which can\n   help you fix problems.\n\n-  \":ref:`dev-manual/debugging:debugging with the gnu project debugger (gdb) on the target`\"\n   describes how to use GDB directly on target hardware for debugging.\n\n-  \":ref:`dev-manual/debugging:other debugging tips`\" describes\n   miscellaneous debugging tips that can be useful.\n\nViewing Logs from Failed Tasks\n==============================\n\nYou can find the log for a task in the file\n``${``\\ :term:`WORKDIR`\\ ``}/temp/log.do_``\\ `taskname`.\nFor example, the log for the\n:ref:`ref-tasks-compile` task of the\nQEMU minimal image for the x86 machine (``qemux86``) might be in\n``tmp/work/qemux86-poky-linux/core-image-minimal/1.0-r0/temp/log.do_compile``.\nTo see the commands :term:`BitBake` ran\nto generate a log, look at the corresponding ``run.do_``\\ `taskname` file\nin the same directory.\n\n``log.do_``\\ `taskname` and ``run.do_``\\ `taskname` are actually symbolic\nlinks to ``log.do_``\\ `taskname`\\ ``.``\\ `pid` and\n"}
{"text": "\n\nDebugging Tools and Techniques\n``log.run_``\\ `taskname`\\ ``.``\\ `pid`, where `pid` is the PID the task had\nwhen it ran. The symlinks always point to the files corresponding to the\nmost recent run.\n\nViewing Variable Values\n=======================\n\nSometimes you need to know the value of a variable as a result of\nBitBake's parsing step. This could be because some unexpected behavior\noccurred in your project. Perhaps an attempt to :ref:`modify a variable\n<bitbake-user-manual/bitbake-user-manual-metadata:modifying existing\nvariables>` did not work out as expected.\n\nBitBake's ``-e`` option is used to display variable values after\nparsing. The following command displays the variable values after the\nconfiguration files (i.e. ``local.conf``, ``bblayers.conf``,\n``bitbake.conf`` and so forth) have been parsed::\n\n   $ bitbake -e\n\nThe following command displays variable values after a specific recipe has\nbeen parsed. The variables include those from the configuration as well::\n\n   $ bitbake -e recipename\n\n.. note::\n\n   Each recipe has its own private set of variables (datastore).\n   Internally, after parsing the configuration, a copy of the resulting\n   datastore is made prior to parsing each recipe. This copying implies\n   that variables set in one recipe will not be visible to other\n   recipes.\n\n   Likewise, each task within a recipe gets a private datastore based on\n   the recipe datastore, which means that variables set within one task\n   will not be visible to other tasks.\n\nIn the output of ``bitbake -e``, each variable is preceded by a\ndescription of how the variable got its value, including temporary\nvalues that were later overridden. This description also includes\nvariable flags (varflags) set on the variable. The output can be very\nhelpful during debugging.\n\nVariables that are exported to the environment are preceded by\n``export`` in the output of ``bitbake -e``. See the following example::\n\n   export CC=\"i586-poky-linux-gcc -m32 -march=i586 --sysroot=/home/ulf/poky/build/tmp/sysroots/qemux86\"\n\nIn addition to variable values, the output of the ``bitbake -e`` and\n``bitbake -e``recipe commands includes the following information:\n\n-  The output starts with a tree listing all configuration files and\n   classes included globally, recursively listing the files they include\n   or inherit in turn. Much of the behavior of the OpenEmbedded build\n   system (including the behavior of the :ref:`ref-manual/tasks:normal recipe build tasks`) is\n   implemented in the :ref:`ref-classes-base` class and the\n   classes it inherits, rather than being built into BitBake itself.\n\n-  After the variable values, all functions appear in the output. For\n   shell functions, variables referenced within the function body are\n   expanded. If a function has been modified using overrides or using\n   override-style operators like ``:append`` and ``:prepend``, then the\n   final assembled function body appears in the output.\n\nViewing Package Information with ``oe-pkgdata-util``\n====================================================\n\nYou can use the ``oe-pkgdata-util`` command-line utility to query\n:term:`PKGDATA_DIR` and display\nvarious package-related information. When you use the utility, you must\nuse it to view information on packages that have already been built.\n\nFollowing are a few of the available ``oe-pkgdata-util`` subcommands.\n\n.. note::\n\n   You can use the standard \\* and ? globbing wildcards as part of\n   package names and paths.\n\n-  ``oe-pkgdata-util list-pkgs [pattern]``: Lists all packages\n   that have been built, optionally limiting the match to packages that\n   match pattern.\n\n-  ``oe-pkgdata-util list-pkg-filespackage...``: Lists the\n   files and directories contained in the given packages.\n\n   .. note::\n\n      A different way to view the contents of a package is to look at\n      the\n      ``${``\\ :term:`WORKDIR`\\ ``}/packages-split``\n      directory of the recipe that generates the package. This directory\n      is created by the\n      :ref:`ref-tasks-package` task\n      and has one subdirectory for each package the recipe generates,\n      which contains the files stored in that package.\n\n      If you want to inspect the ``${WORKDIR}/packages-split``\n      directory, make sure that :ref:`ref-classes-rm-work` is not\n      enabled when you build the recipe.\n"}
{"text": "\n\nDebugging Tools and Techniques\n\n-  ``oe-pkgdata-util find-pathpath...``: Lists the names of\n   the packages that contain the given paths. For example, the following\n   tells us that ``/usr/share/man/man1/make.1`` is contained in the\n   ``make-doc`` package::\n\n      $ oe-pkgdata-util find-path /usr/share/man/man1/make.1\n      make-doc: /usr/share/man/man1/make.1\n\n-  ``oe-pkgdata-util lookup-recipepackage...``: Lists the name\n   of the recipes that produce the given packages.\n\nFor more information on the ``oe-pkgdata-util`` command, use the help\nfacility::\n\n   $ oe-pkgdata-util --help\n   $ oe-pkgdata-util subcommand --help\n\nViewing Dependencies Between Recipes and Tasks\n==============================================\n\nSometimes it can be hard to see why BitBake wants to build other recipes\nbefore the one you have specified. Dependency information can help you\nunderstand why a recipe is built.\n\nTo generate dependency information for a recipe, run the following\ncommand::\n\n   $ bitbake -g recipename\n\nThis command writes the following files in the current directory:\n\n-  ``pn-buildlist``: A list of recipes/targets involved in building\n   `recipename`. \"Involved\" here means that at least one task from the\n   recipe needs to run when building `recipename` from scratch. Targets\n   that are in\n   :term:`ASSUME_PROVIDED`\n   are not listed.\n\n-  ``task-depends.dot``: A graph showing dependencies between tasks.\n\nThe graphs are in :wikipedia:`DOT <DOT_%28graph_description_language%29>`\nformat and can be converted to images (e.g. using the ``dot`` tool from\n`Graphviz <https://www.graphviz.org/>`__).\n\n.. note::\n\n   -  DOT files use a plain text format. The graphs generated using the\n      ``bitbake -g`` command are often so large as to be difficult to\n      read without special pruning (e.g. with BitBake's ``-I`` option)\n      and processing. Despite the form and size of the graphs, the\n      corresponding ``.dot`` files can still be possible to read and\n      provide useful information.\n\n      As an example, the ``task-depends.dot`` file contains lines such\n      as the following::\n\n         \"libxslt.do_configure\" -> \"libxml2.do_populate_sysroot\"\n\n      The above example line reveals that the\n      :ref:`ref-tasks-configure`\n      task in ``libxslt`` depends on the\n      :ref:`ref-tasks-populate_sysroot`\n      task in ``libxml2``, which is a normal\n      :term:`DEPENDS` dependency\n      between the two recipes.\n\n   -  For an example of how ``.dot`` files can be processed, see the\n      ``scripts/contrib/graph-tool`` Python script, which finds and\n      displays paths between graph nodes.\n\nYou can use a different method to view dependency information by using\nthe following command::\n\n   $ bitbake -g -u taskexp recipename\n\nThis command\ndisplays a GUI window from which you can view build-time and runtime\ndependencies for the recipes involved in building recipename.\n\nViewing Task Variable Dependencies\n==================================\n\nAs mentioned in the\n\":ref:`bitbake-user-manual/bitbake-user-manual-execution:checksums (signatures)`\"\nsection of the BitBake User Manual, BitBake tries to automatically determine\nwhat variables a task depends on so that it can rerun the task if any values of\nthe variables change. This determination is usually reliable. However, if you\ndo things like construct variable names at runtime, then you might have to\nmanually declare dependencies on those variables using ``vardeps`` as described\nin the \":ref:`bitbake-user-manual/bitbake-user-manual-metadata:variable flags`\"\nsection of the BitBake User Manual.\n\nIf you are unsure whether a variable dependency is being picked up\nautomatically for a given task, you can list the variable dependencies\nBitBake has determined by doing the following:\n\n#. Build the recipe containing the task::\n\n   $ bitbake recipename\n"}
{"text": "\n\nDebugging Tools and Techniques\n\n#. Inside the :term:`STAMPS_DIR`\n   directory, find the signature data (``sigdata``) file that\n   corresponds to the task. The ``sigdata`` files contain a pickled\n   Python database of all the metadata that went into creating the input\n   checksum for the task. As an example, for the\n   :ref:`ref-tasks-fetch` task of the\n   ``db`` recipe, the ``sigdata`` file might be found in the following\n   location::\n\n      ${BUILDDIR}/tmp/stamps/i586-poky-linux/db/6.0.30-r1.do_fetch.sigdata.7c048c18222b16ff0bcee2000ef648b1\n\n   For tasks that are accelerated through the shared state\n   (:ref:`sstate <overview-manual/concepts:shared state cache>`) cache, an\n   additional ``siginfo`` file is written into\n   :term:`SSTATE_DIR` along with\n   the cached task output. The ``siginfo`` files contain exactly the\n   same information as ``sigdata`` files.\n\n#. Run ``bitbake-dumpsig`` on the ``sigdata`` or ``siginfo`` file. Here\n   is an example::\n\n      $ bitbake-dumpsig ${BUILDDIR}/tmp/stamps/i586-poky-linux/db/6.0.30-r1.do_fetch.sigdata.7c048c18222b16ff0bcee2000ef648b1\n\n   In the output of the above command, you will find a line like the\n   following, which lists all the (inferred) variable dependencies for\n   the task. This list also includes indirect dependencies from\n   variables depending on other variables, recursively::\n\n      Task dependencies: ['PV', 'SRCREV', 'SRC_URI', 'SRC_URI[sha256sum]', 'base_do_fetch']\n\n   .. note::\n\n      Functions (e.g. ``base_do_fetch``) also count as variable dependencies.\n      These functions in turn depend on the variables they reference.\n\n   The output of ``bitbake-dumpsig`` also includes the value each\n   variable had, a list of dependencies for each variable, and\n   :term:`BB_BASEHASH_IGNORE_VARS`\n   information.\n\nThere is also a ``bitbake-diffsigs`` command for comparing two\n``siginfo`` or ``sigdata`` files. This command can be helpful when\ntrying to figure out what changed between two versions of a task. If you\ncall ``bitbake-diffsigs`` with just one file, the command behaves like\n``bitbake-dumpsig``.\n\nYou can also use BitBake to dump out the signature construction\ninformation without executing tasks by using either of the following\nBitBake command-line options::\n\n   dump-signatures=SIGNATURE_HANDLER\n   -S SIGNATURE_HANDLER\n\n\n.. note::\n\n   Two common values for `SIGNATURE_HANDLER` are \"none\" and \"printdiff\", which\n   dump only the signature or compare the dumped signature with the cached one,\n   respectively.\n\nUsing BitBake with either of these options causes BitBake to dump out\n``sigdata`` files in the ``stamps`` directory for every task it would\nhave executed instead of building the specified target package.\n\nViewing Metadata Used to Create the Input Signature of a Shared State Task\n==========================================================================\n\nSeeing what metadata went into creating the input signature of a shared\nstate (sstate) task can be a useful debugging aid. This information is\navailable in signature information (``siginfo``) files in\n:term:`SSTATE_DIR`. For\ninformation on how to view and interpret information in ``siginfo``\nfiles, see the\n\":ref:`dev-manual/debugging:viewing task variable dependencies`\" section.\n\nFor conceptual information on shared state, see the\n\":ref:`overview-manual/concepts:shared state`\"\nsection in the Yocto Project Overview and Concepts Manual.\n\nInvalidating Shared State to Force a Task to Run\n================================================\n\nThe OpenEmbedded build system uses\n:ref:`checksums <overview-manual/concepts:checksums (signatures)>` and\n:ref:`overview-manual/concepts:shared state` cache to avoid unnecessarily\nrebuilding tasks. Collectively, this scheme is known as \"shared state\ncode\".\n\nAs with all schemes, this one has some drawbacks. It is possible that\nyou could make implicit changes to your code that the checksum\ncalculations do not take into account. These implicit changes affect a\ntask's output but do not trigger the shared state code into rebuilding a\nrecipe. Consider an example during which a tool changes its output.\nAssume that the output of ``rpmdeps`` changes. The result of the change\nshould be that all the ``package`` and ``package_write_rpm`` shared\nstate cache items become invalid. However, because the change to the\noutput is external to the code and therefore implicit, the associated\nshared state cache items do not become invalidated. In this case, the\nbuild process uses the cached items rather than running the task again.\n"}
{"text": "\n\nDebugging Tools and Techniques\nObviously, these types of implicit changes can cause problems.\n\nTo avoid these problems during the build, you need to understand the\neffects of any changes you make. Realize that changes you make directly\nto a function are automatically factored into the checksum calculation.\nThus, these explicit changes invalidate the associated area of shared\nstate cache. However, you need to be aware of any implicit changes that\nare not obvious changes to the code and could affect the output of a\ngiven task.\n\nWhen you identify an implicit change, you can easily take steps to\ninvalidate the cache and force the tasks to run. The steps you can take\nare as simple as changing a function's comments in the source code. For\nexample, to invalidate package shared state files, change the comment\nstatements of\n:ref:`ref-tasks-package` or the\ncomments of one of the functions it calls. Even though the change is\npurely cosmetic, it causes the checksum to be recalculated and forces\nthe build system to run the task again.\n\n.. note::\n\n   For an example of a commit that makes a cosmetic change to invalidate\n   shared state, see this\n   :yocto_git:`commit </poky/commit/meta/classes/package.bbclass?id=737f8bbb4f27b4837047cb9b4fbfe01dfde36d54>`.\n\nRunning Specific Tasks\n======================\n\nAny given recipe consists of a set of tasks. The standard BitBake\nbehavior in most cases is: :ref:`ref-tasks-fetch`, :ref:`ref-tasks-unpack`, :ref:`ref-tasks-patch`,\n:ref:`ref-tasks-configure`, :ref:`ref-tasks-compile`, :ref:`ref-tasks-install`, :ref:`ref-tasks-package`,\n:ref:`do_package_write_* <ref-tasks-package_write_deb>`, and :ref:`ref-tasks-build`. The default task is\n:ref:`ref-tasks-build` and any tasks on which it depends build first. Some tasks,\nsuch as :ref:`ref-tasks-devshell`, are not part of the default build chain. If you\nwish to run a task that is not part of the default build chain, you can\nuse the ``-c`` option in BitBake. Here is an example::\n\n   $ bitbake matchbox-desktop -c devshell\n\nThe ``-c`` option respects task dependencies, which means that all other\ntasks (including tasks from other recipes) that the specified task\ndepends on will be run before the task. Even when you manually specify a\ntask to run with ``-c``, BitBake will only run the task if it considers\nit \"out of date\". See the\n\":ref:`overview-manual/concepts:stamp files and the rerunning of tasks`\"\nsection in the Yocto Project Overview and Concepts Manual for how\nBitBake determines whether a task is \"out of date\".\n\nIf you want to force an up-to-date task to be rerun (e.g. because you\nmade manual modifications to the recipe's\n:term:`WORKDIR` that you want to try\nout), then you can use the ``-f`` option.\n\n.. note::\n\n   The reason ``-f`` is never required when running the\n   :ref:`ref-tasks-devshell` task is because the\n   [\\ :ref:`nostamp <bitbake-user-manual/bitbake-user-manual-metadata:variable flags>`\\ ]\n   variable flag is already set for the task.\n\nThe following example shows one way you can use the ``-f`` option::\n\n   $ bitbake matchbox-desktop\n             .\n             .\n   make some changes to the source code in the work directory\n             .\n             .\n   $ bitbake matchbox-desktop -c compile -f\n   $ bitbake matchbox-desktop\n\nThis sequence first builds and then recompiles ``matchbox-desktop``. The\nlast command reruns all tasks (basically the packaging tasks) after the\ncompile. BitBake recognizes that the :ref:`ref-tasks-compile` task was rerun and\ntherefore understands that the other tasks also need to be run again.\n\nAnother, shorter way to rerun a task and all\n:ref:`ref-manual/tasks:normal recipe build tasks`\nthat depend on it is to use the ``-C`` option.\n\n.. note::\n\n   This option is upper-cased and is separate from the ``-c``\n   option, which is lower-cased.\n\nUsing this option invalidates the given task and then runs the\n:ref:`ref-tasks-build` task, which is\nthe default task if no task is given, and the tasks on which it depends.\nYou could replace the final two commands in the previous example with\nthe following single command::\n\n   $ bitbake matchbox-desktop -C compile\n\nInternally, the ``-f`` and ``-C`` options work by tainting (modifying)\nthe input checksum of the specified task. This tainting indirectly\ncauses the task and its dependent tasks to be rerun through the normal\ntask dependency mechanisms.\n\n.. note::\n"}
{"text": "\n\nDebugging Tools and Techniques\n\n   BitBake explicitly keeps track of which tasks have been tainted in\n   this fashion, and will print warnings such as the following for\n   builds involving such tasks:\n\n   .. code-block:: none\n\n      WARNING: /home/ulf/poky/meta/recipes-sato/matchbox-desktop/matchbox-desktop_2.1.bb.do_compile is tainted from a forced run\n\n\n   The purpose of the warning is to let you know that the work directory\n   and build output might not be in the clean state they would be in for\n   a \"normal\" build, depending on what actions you took. To get rid of\n   such warnings, you can remove the work directory and rebuild the\n   recipe, as follows::\n\n      $ bitbake matchbox-desktop -c clean\n      $ bitbake matchbox-desktop\n\n\nYou can view a list of tasks in a given package by running the\n:ref:`ref-tasks-listtasks` task as follows::\n\n   $ bitbake matchbox-desktop -c listtasks\n\nThe results appear as output to the console and are also in\nthe file ``${WORKDIR}/temp/log.do_listtasks``.\n\nGeneral BitBake Problems\n========================\n\nYou can see debug output from BitBake by using the ``-D`` option. The\ndebug output gives more information about what BitBake is doing and the\nreason behind it. Each ``-D`` option you use increases the logging\nlevel. The most common usage is ``-DDD``.\n\nThe output from ``bitbake -DDD -v targetname`` can reveal why BitBake\nchose a certain version of a package or why BitBake picked a certain\nprovider. This command could also help you in a situation where you\nthink BitBake did something unexpected.\n\nBuilding with No Dependencies\n=============================\n\nTo build a specific recipe (``.bb`` file), you can use the following\ncommand form::\n\n   $ bitbake -b somepath/somerecipe.bb\n\nThis command form does\nnot check for dependencies. Consequently, you should use it only when\nyou know existing dependencies have been met.\n\n.. note::\n\n   You can also specify fragments of the filename. In this case, BitBake\n   checks for a unique match.\n\nRecipe Logging Mechanisms\n=========================\n\nThe Yocto Project provides several logging functions for producing\ndebugging output and reporting errors and warnings. For Python\nfunctions, the following logging functions are available. All of these functions\nlog to ``${T}/log.do_``\\ `task`, and can also log to standard output\n(stdout) with the right settings:\n\n-  ``bb.plain(msg)``: Writes msg as is to the log while also\n   logging to stdout.\n\n-  ``bb.note(msg)``: Writes \"NOTE: msg\" to the log. Also logs to\n   stdout if BitBake is called with \"-v\".\n\n-  ``bb.debug(level, msg)``: Writes \"DEBUG: msg\" to the log. Also logs to\n   stdout if the log level is greater than or equal to level. See the\n   \":ref:`bitbake-user-manual/bitbake-user-manual-intro:usage and syntax`\"\n   option in the BitBake User Manual for more information.\n\n-  ``bb.warn(msg)``: Writes \"WARNING: msg\" to the log while also\n   logging to stdout.\n\n-  ``bb.error(msg)``: Writes \"ERROR: msg\" to the log while also\n   logging to standard out (stdout).\n\n   .. note::\n\n      Calling this function does not cause the task to fail.\n\n-  ``bb.fatal(msg)``: This logging function is similar to\n   ``bb.error(msg)`` but also causes the calling task to fail.\n\n   .. note::\n\n      ``bb.fatal()`` raises an exception, which means you do not need to put a\n      \"return\" statement after the function.\n\nThe same logging functions are also available in shell functions, under\nthe names ``bbplain``, ``bbnote``, ``bbdebug``, ``bbwarn``, ``bberror``,\nand ``bbfatal``. The :ref:`ref-classes-logging` class\nimplements these functions. See that class in the ``meta/classes``\n"}
{"text": "\n\nDebugging Tools and Techniques\nfolder of the :term:`Source Directory` for information.\n\nLogging With Python\n-------------------\n\nWhen creating recipes using Python and inserting code that handles build\nlogs, keep in mind the goal is to have informative logs while keeping\nthe console as \"silent\" as possible. Also, if you want status messages\nin the log, use the \"debug\" loglevel.\n\nFollowing is an example written in Python. The code handles logging for\na function that determines the number of tasks needed to be run. See the\n\":ref:`ref-tasks-listtasks`\"\nsection for additional information::\n\n   python do_listtasks() {\n       bb.debug(2, \"Starting to figure out the task list\")\n       if noteworthy_condition:\n           bb.note(\"There are 47 tasks to run\")\n       bb.debug(2, \"Got to point xyz\")\n       if warning_trigger:\n           bb.warn(\"Detected warning_trigger, this might be a problem later.\")\n       if recoverable_error:\n           bb.error(\"Hit recoverable_error, you really need to fix this!\")\n       if fatal_error:\n           bb.fatal(\"fatal_error detected, unable to print the task list\")\n       bb.plain(\"The tasks present are abc\")\n       bb.debug(2, \"Finished figuring out the tasklist\")\n   }\n\nLogging With Bash\n-----------------\n\nWhen creating recipes using Bash and inserting code that handles build\nlogs, you have the same goals --- informative with minimal console output.\nThe syntax you use for recipes written in Bash is similar to that of\nrecipes written in Python described in the previous section.\n\nFollowing is an example written in Bash. The code logs the progress of\nthe ``do_my_function`` function::\n\n   do_my_function() {\n       bbdebug 2 \"Running do_my_function\"\n       if [ exceptional_condition ]; then\n           bbnote \"Hit exceptional_condition\"\n       fi\n       bbdebug 2  \"Got to point xyz\"\n       if [ warning_trigger ]; then\n           bbwarn \"Detected warning_trigger, this might cause a problem later.\"\n       fi\n       if [ recoverable_error ]; then\n           bberror \"Hit recoverable_error, correcting\"\n       fi\n       if [ fatal_error ]; then\n           bbfatal \"fatal_error detected\"\n       fi\n       bbdebug 2 \"Completed do_my_function\"\n   }\n\n\nDebugging Parallel Make Races\n=============================\n\nA parallel ``make`` race occurs when the build consists of several parts\nthat are run simultaneously and a situation occurs when the output or\nresult of one part is not ready for use with a different part of the\nbuild that depends on that output. Parallel make races are annoying and\ncan sometimes be difficult to reproduce and fix. However, there are some simple\ntips and tricks that can help you debug and fix them. This section\npresents a real-world example of an error encountered on the Yocto\nProject autobuilder and the process used to fix it.\n\n.. note::\n\n   If you cannot properly fix a ``make`` race condition, you can work around it\n   by clearing either the :term:`PARALLEL_MAKE` or :term:`PARALLEL_MAKEINST`\n   variables.\n\nThe Failure\n-----------\n\nFor this example, assume that you are building an image that depends on\nthe \"neard\" package. And, during the build, BitBake runs into problems\nand creates the following output.\n\n.. note::\n\n   This example log file has longer lines artificially broken to make\n   the listing easier to read.\n\nIf you examine the output or the log file, you see the failure during\n``make``:\n\n.. code-block:: none\n\n   | DEBUG: SITE files ['endian-little', 'bit-32', 'ix86-common', 'common-linux', 'common-glibc', 'i586-linux', 'common']\n   | DEBUG: Executing shell function do_compile\n   | NOTE: make -j 16\n   | make --no-print-directory all-am\n   | /bin/mkdir -p include/near\n"}
{"text": "\n\nDebugging Tools and Techniques\n   | /bin/mkdir -p include/near\n   | /bin/mkdir -p include/near\n   | ln -s /home/pokybuild/yocto-autobuilder/nightly-x86/build/build/tmp/work/i586-poky-linux/neard/\n     0.14-r0/neard-0.14/include/types.h include/near/types.h\n   | ln -s /home/pokybuild/yocto-autobuilder/nightly-x86/build/build/tmp/work/i586-poky-linux/neard/\n     0.14-r0/neard-0.14/include/log.h include/near/log.h\n   | ln -s /home/pokybuild/yocto-autobuilder/nightly-x86/build/build/tmp/work/i586-poky-linux/neard/\n     0.14-r0/neard-0.14/include/plugin.h include/near/plugin.h\n   | /bin/mkdir -p include/near\n   | /bin/mkdir -p include/near\n   | /bin/mkdir -p include/near\n   | ln -s /home/pokybuild/yocto-autobuilder/nightly-x86/build/build/tmp/work/i586-poky-linux/neard/\n     0.14-r0/neard-0.14/include/tag.h include/near/tag.h\n   | /bin/mkdir -p include/near\n   | ln -s /home/pokybuild/yocto-autobuilder/nightly-x86/build/build/tmp/work/i586-poky-linux/neard/\n     0.14-r0/neard-0.14/include/adapter.h include/near/adapter.h\n   | /bin/mkdir -p include/near\n   | ln -s /home/pokybuild/yocto-autobuilder/nightly-x86/build/build/tmp/work/i586-poky-linux/neard/\n     0.14-r0/neard-0.14/include/ndef.h include/near/ndef.h\n   | ln -s /home/pokybuild/yocto-autobuilder/nightly-x86/build/build/tmp/work/i586-poky-linux/neard/\n     0.14-r0/neard-0.14/include/tlv.h include/near/tlv.h\n   | /bin/mkdir -p include/near\n   | /bin/mkdir -p include/near\n   | ln -s /home/pokybuild/yocto-autobuilder/nightly-x86/build/build/tmp/work/i586-poky-linux/neard/\n     0.14-r0/neard-0.14/include/setting.h include/near/setting.h\n   | /bin/mkdir -p include/near\n   | /bin/mkdir -p include/near\n   | /bin/mkdir -p include/near\n   | ln -s /home/pokybuild/yocto-autobuilder/nightly-x86/build/build/tmp/work/i586-poky-linux/neard/\n     0.14-r0/neard-0.14/include/device.h include/near/device.h\n   | ln -s /home/pokybuild/yocto-autobuilder/nightly-x86/build/build/tmp/work/i586-poky-linux/neard/\n     0.14-r0/neard-0.14/include/nfc_copy.h include/near/nfc_copy.h\n   | ln -s /home/pokybuild/yocto-autobuilder/nightly-x86/build/build/tmp/work/i586-poky-linux/neard/\n     0.14-r0/neard-0.14/include/snep.h include/near/snep.h\n   | ln -s /home/pokybuild/yocto-autobuilder/nightly-x86/build/build/tmp/work/i586-poky-linux/neard/\n     0.14-r0/neard-0.14/include/version.h include/near/version.h\n   | ln -s /home/pokybuild/yocto-autobuilder/nightly-x86/build/build/tmp/work/i586-poky-linux/neard/\n     0.14-r0/neard-0.14/include/dbus.h include/near/dbus.h\n   | ./src/genbuiltin nfctype1 nfctype2 nfctype3 nfctype4 p2p > src/builtin.h\n   | i586-poky-linux-gcc  -m32 -march=i586 --sysroot=/home/pokybuild/yocto-autobuilder/nightly-x86/\n     build/build/tmp/sysroots/qemux86 -DHAVE_CONFIG_H -I. -I./include -I./src -I./gdbus  -I/home/pokybuild/\n     yocto-autobuilder/nightly-x86/build/build/tmp/sysroots/qemux86/usr/include/glib-2.0\n     -I/home/pokybuild/yocto-autobuilder/nightly-x86/build/build/tmp/sysroots/qemux86/usr/\n     lib/glib-2.0/include  -I/home/pokybuild/yocto-autobuilder/nightly-x86/build/build/\n     tmp/sysroots/qemux86/usr/include/dbus-1.0 -I/home/pokybuild/yocto-autobuilder/\n     nightly-x86/build/build/tmp/sysroots/qemux86/usr/lib/dbus-1.0/include  -I/home/pokybuild/yocto-autobuilder/\n     nightly-x86/build/build/tmp/sysroots/qemux86/usr/include/libnl3\n     -DNEAR_PLUGIN_BUILTIN -DPLUGINDIR=\\\"\"/usr/lib/near/plugins\"\\\"\n     -DCONFIGDIR=\\\"\"/etc/neard\\\"\" -O2 -pipe -g -feliminate-unused-debug-types -c\n     -o tools/snep-send.o tools/snep-send.c\n   | In file included from tools/snep-send.c:16:0:\n   | tools/../src/near.h:41:23: fatal error: near/dbus.h: No such file or directory\n   |  #include <near/dbus.h>\n   |                        ^\n   | compilation terminated.\n   | make[1]: *** [tools/snep-send.o] Error 1\n   | make[1]: *** Waiting for unfinished jobs....\n   | make: *** [all] Error 2\n   | ERROR: oe_runmake failed\n\nReproducing the Error\n---------------------\n\nBecause race conditions are intermittent, they do not manifest\nthemselves every time you do the build. In fact, most times the build\nwill complete without problems even though the potential race condition\nexists. Thus, once the error surfaces, you need a way to reproduce it.\n\nIn this example, compiling the \"neard\" package is causing the problem.\nSo the first thing to do is build \"neard\" locally. Before you start the\nbuild, set the\n:term:`PARALLEL_MAKE` variable\nin your ``local.conf`` file to a high number (e.g. \"-j 20\"). Using a\nhigh value for :term:`PARALLEL_MAKE` increases the chances of the race\ncondition showing up::\n\n   $ bitbake neard\n\nOnce the local build for \"neard\" completes, start a ``devshell`` build::\n\n   $ bitbake neard -c devshell\n\nFor information on how to use a ``devshell``, see the\n\":ref:`dev-manual/development-shell:using a development shell`\" section.\n\nIn the ``devshell``, do the following::\n\n   $ make clean\n   $ make tools/snep-send.o\n\nThe ``devshell`` commands cause the failure to clearly\nbe visible. In this case, there is a missing dependency for the ``neard``\nMakefile target. Here is some abbreviated, sample output with the\nmissing dependency clearly visible at the end::\n\n   i586-poky-linux-gcc  -m32 -march=i586 --sysroot=/home/scott-lenovo/......\n      .\n      .\n      .\n   tools/snep-send.c\n"}
{"text": "\n\nDebugging Tools and Techniques\n   In file included from tools/snep-send.c:16:0:\n   tools/../src/near.h:41:23: fatal error: near/dbus.h: No such file or directory\n    #include <near/dbus.h>\n                     ^\n   compilation terminated.\n   make: *** [tools/snep-send.o] Error 1\n   $\n\n\nCreating a Patch for the Fix\n----------------------------\n\nBecause there is a missing dependency for the Makefile target, you need\nto patch the ``Makefile.am`` file, which is generated from\n``Makefile.in``. You can use Quilt to create the patch::\n\n   $ quilt new parallelmake.patch\n   Patch patches/parallelmake.patch is now on top\n   $ quilt add Makefile.am\n   File Makefile.am added to patch patches/parallelmake.patch\n\nFor more information on using Quilt, see the\n\":ref:`dev-manual/quilt:using quilt in your workflow`\" section.\n\nAt this point you need to make the edits to ``Makefile.am`` to add the\nmissing dependency. For our example, you have to add the following line\nto the file::\n\n   tools/snep-send.$(OBJEXT): include/near/dbus.h\n\nOnce you have edited the file, use the ``refresh`` command to create the\npatch::\n\n   $ quilt refresh\n   Refreshed patch patches/parallelmake.patch\n\nOnce the patch file is created, you need to add it back to the originating\nrecipe folder. Here is an example assuming a top-level\n:term:`Source Directory` named ``poky``::\n\n   $ cp patches/parallelmake.patch poky/meta/recipes-connectivity/neard/neard\n\nThe final thing you need to do to implement the fix in the build is to\nupdate the \"neard\" recipe (i.e. ``neard-0.14.bb``) so that the\n:term:`SRC_URI` statement includes\nthe patch file. The recipe file is in the folder above the patch. Here\nis what the edited :term:`SRC_URI` statement would look like::\n\n   SRC_URI = \"${KERNELORG_MIRROR}/linux/network/nfc/${BPN}-${PV}.tar.xz \\\n              file://neard.in \\\n              file://neard.service.in \\\n              file://parallelmake.patch \\\n             \"\n\nWith the patch complete and moved to the correct folder and the\n:term:`SRC_URI` statement updated, you can exit the ``devshell``::\n\n   $ exit\n\nTesting the Build\n-----------------\n\nWith everything in place, you can get back to trying the build again\nlocally::\n\n   $ bitbake neard\n\nThis build should succeed.\n\nNow you can open up a ``devshell`` again and repeat the clean and make\noperations as follows::\n\n   $ bitbake neard -c devshell\n   $ make clean\n   $ make tools/snep-send.o\n\nThe build should work without issue.\n\nAs with all solved problems, if they originated upstream, you need to\nsubmit the fix for the recipe in OE-Core and upstream so that the\nproblem is taken care of at its source. See the\n\":doc:`../contributor-guide/submit-changes`\" section for more information.\n\nDebugging With the GNU Project Debugger (GDB) Remotely\n======================================================\n\nGDB allows you to examine running programs, which in turn helps you to\nunderstand and fix problems. It also allows you to perform post-mortem\nstyle analysis of program crashes. GDB is available as a package within\nthe Yocto Project and is installed in SDK images by default. See the\n\":ref:`ref-manual/images:Images`\" chapter in the Yocto\nProject Reference Manual for a description of these images. You can find\ninformation on GDB at https://sourceware.org/gdb/.\n\n.. note::\n\n   For best results, install debug (``-dbg``) packages for the applications you\n   are going to debug. Doing so makes extra debug symbols available that give\n   you more meaningful output.\n\n"}
{"text": "\n\nDebugging Tools and Techniques\nSometimes, due to memory or disk space constraints, it is not possible\nto use GDB directly on the remote target to debug applications. These\nconstraints arise because GDB needs to load the debugging information\nand the binaries of the process being debugged. Additionally, GDB needs\nto perform many computations to locate information such as function\nnames, variable names and values, stack traces and so forth --- even\nbefore starting the debugging process. These extra computations place\nmore load on the target system and can alter the characteristics of the\nprogram being debugged.\n\nTo help get past the previously mentioned constraints, there are two\nmethods you can use: running a debuginfod server and using gdbserver.\n\nUsing the debuginfod server method\n----------------------------------\n\n``debuginfod`` from ``elfutils`` is a way to distribute ``debuginfo`` files.\nRunning a ``debuginfod`` server makes debug symbols readily available,\nwhich means you don't need to download debugging information\nand the binaries of the process being debugged. You can just fetch\ndebug symbols from the server.\n\nTo run a ``debuginfod`` server, you need to do the following:\n\n-  Ensure that ``debuginfod`` is present in :term:`DISTRO_FEATURES`\n   (it already is in ``OpenEmbedded-core`` defaults and ``poky`` reference distribution).\n   If not, set in your distro config file or in ``local.conf``::\n\n      DISTRO_FEATURES:append = \" debuginfod\"\n\n   This distro feature enables the server and client library in ``elfutils``,\n   and enables ``debuginfod`` support in clients (at the moment, ``gdb`` and ``binutils``).\n\n-  Run the following commands to launch the ``debuginfod`` server on the host::\n\n      $ oe-debuginfod\n\n-  To use ``debuginfod`` on the target, you need to know the ip:port where\n   ``debuginfod`` is listening on the host (port defaults to 8002), and export\n   that into the shell environment, for example in ``qemu``::\n\n      root@qemux86-64:~# export DEBUGINFOD_URLS=\"http://192.168.7.1:8002/\"\n\n-  Then debug info fetching should simply work when running the target ``gdb``,\n   ``readelf`` or ``objdump``, for example::\n\n      root@qemux86-64:~# gdb /bin/cat\n      ...\n      Reading symbols from /bin/cat...\n      Downloading separate debug info for /bin/cat...\n      Reading symbols from /home/root/.cache/debuginfod_client/923dc4780cfbc545850c616bffa884b6b5eaf322/debuginfo...\n\n-  It's also possible to use ``debuginfod-find`` to just query the server::\n\n      root@qemux86-64:~# debuginfod-find debuginfo /bin/ls\n      /home/root/.cache/debuginfod_client/356edc585f7f82d46f94fcb87a86a3fe2d2e60bd/debuginfo\n\n\nUsing the gdbserver method\n--------------------------\n\ngdbserver, which runs on the remote target and does not load any\ndebugging information from the debugged process. Instead, a GDB instance\nprocesses the debugging information that is run on a remote computer -\nthe host GDB. The host GDB then sends control commands to gdbserver to\nmake it stop or start the debugged program, as well as read or write\nmemory regions of that debugged program. All the debugging information\nloaded and processed as well as all the heavy debugging is done by the\nhost GDB. Offloading these processes gives the gdbserver running on the\ntarget a chance to remain small and fast.\n\nBecause the host GDB is responsible for loading the debugging\ninformation and for doing the necessary processing to make actual\ndebugging happen, you have to make sure the host can access the\nunstripped binaries complete with their debugging information and also\nbe sure the target is compiled with no optimizations. The host GDB must\nalso have local access to all the libraries used by the debugged\nprogram. Because gdbserver does not need any local debugging\ninformation, the binaries on the remote target can remain stripped.\nHowever, the binaries must also be compiled without optimization so they\nmatch the host's binaries.\n\nTo remain consistent with GDB documentation and terminology, the binary\nbeing debugged on the remote target machine is referred to as the\n\"inferior\" binary. For documentation on GDB see the `GDB\nsite <https://sourceware.org/gdb/documentation/>`__.\n\nThe following steps show you how to debug using the GNU project\ndebugger.\n\n#. *Configure your build system to construct the companion debug\n   filesystem:*\n\n   In your ``local.conf`` file, set the following::\n\n      IMAGE_GEN_DEBUGFS = \"1\"\n      IMAGE_FSTYPES_DEBUGFS = \"tar.bz2\"\n\n   These options cause the\n   OpenEmbedded build system to generate a special companion filesystem\n"}
{"text": "\n\nDebugging Tools and Techniques\n   fragment, which contains the matching source and debug symbols to\n   your deployable filesystem. The build system does this by looking at\n   what is in the deployed filesystem, and pulling the corresponding\n   ``-dbg`` packages.\n\n   The companion debug filesystem is not a complete filesystem, but only\n   contains the debug fragments. This filesystem must be combined with\n   the full filesystem for debugging. Subsequent steps in this procedure\n   show how to combine the partial filesystem with the full filesystem.\n\n#. *Configure the system to include gdbserver in the target filesystem:*\n\n   Make the following addition in your ``local.conf`` file::\n\n      EXTRA_IMAGE_FEATURES:append = \" tools-debug\"\n\n   The change makes\n   sure the ``gdbserver`` package is included.\n\n#. *Build the environment:*\n\n   Use the following command to construct the image and the companion\n   Debug Filesystem::\n\n      $ bitbake image\n\n   Build the cross GDB component and\n   make it available for debugging. Build the SDK that matches the\n   image. Building the SDK is best for a production build that can be\n   used later for debugging, especially during long term maintenance::\n\n      $ bitbake -c populate_sdk image\n\n   Alternatively, you can build the minimal toolchain components that\n   match the target. Doing so creates a smaller than typical SDK and\n   only contains a minimal set of components with which to build simple\n   test applications, as well as run the debugger::\n\n      $ bitbake meta-toolchain\n\n   A final method is to build Gdb itself within the build system::\n\n      $ bitbake gdb-cross-<architecture>\n\n   Doing so produces a temporary copy of\n   ``cross-gdb`` you can use for debugging during development. While\n   this is the quickest approach, the two previous methods in this step\n   are better when considering long-term maintenance strategies.\n\n   .. note::\n\n      If you run ``bitbake gdb-cross``, the OpenEmbedded build system suggests\n      the actual image (e.g. ``gdb-cross-i586``). The suggestion is usually the\n      actual name you want to use.\n\n#. *Set up the*``debugfs``\\ *:*\n\n   Run the following commands to set up the ``debugfs``::\n\n      $ mkdir debugfs\n      $ cd debugfs\n      $ tar xvfj build-dir/tmp/deploy/images/machine/image.rootfs.tar.bz2\n      $ tar xvfj build-dir/tmp/deploy/images/machine/image-dbg.rootfs.tar.bz2\n\n#. *Set up GDB:*\n\n   Install the SDK (if you built one) and then source the correct\n   environment file. Sourcing the environment file puts the SDK in your\n   ``PATH`` environment variable and sets ``$GDB`` to the SDK's debugger.\n\n   If you are using the build system, Gdb is located in\n   `build-dir`\\ ``/tmp/sysroots/``\\ `host`\\ ``/usr/bin/``\\ `architecture`\\ ``/``\\ `architecture`\\ ``-gdb``\n\n#. *Boot the target:*\n\n   For information on how to run QEMU, see the `QEMU\n   Documentation <https://wiki.qemu.org/Documentation/GettingStartedDevelopers>`__.\n\n   .. note::\n\n      Be sure to verify that your host can access the target via TCP.\n\n#. *Debug a program:*\n\n   Debugging a program involves running gdbserver on the target and then\n   running Gdb on the host. The example in this step debugs ``gzip``:\n\n   .. code-block:: shell\n\n      root@qemux86:~# gdbserver localhost:1234 /bin/gzip help\n\n   For\n   additional gdbserver options, see the `GDB Server\n   Documentation <https://www.gnu.org/software/gdb/documentation/>`__.\n\n   After running gdbserver on the target, you need to run Gdb on the\n   host and configure it and connect to the target. Use these commands::\n\n      $ cd directory-holding-the-debugfs-directory\n      $ arch-gdb\n"}
{"text": "\n\nDebugging Tools and Techniques\n      (gdb) set sysroot debugfs\n      (gdb) set substitute-path /usr/src/debug debugfs/usr/src/debug\n      (gdb) target remote IP-of-target:1234\n\n   At this\n   point, everything should automatically load (i.e. matching binaries,\n   symbols and headers).\n\n   .. note::\n\n      The Gdb ``set`` commands in the previous example can be placed into the\n      users ``~/.gdbinit`` file. Upon starting, Gdb automatically runs whatever\n      commands are in that file.\n\n#. *Deploying without a full image rebuild:*\n\n   In many cases, during development you want a quick method to deploy a\n   new binary to the target and debug it, without waiting for a full\n   image build.\n\n   One approach to solving this situation is to just build the component\n   you want to debug. Once you have built the component, copy the\n   executable directly to both the target and the host ``debugfs``.\n\n   If the binary is processed through the debug splitting in\n   OpenEmbedded, you should also copy the debug items (i.e. ``.debug``\n   contents and corresponding ``/usr/src/debug`` files) from the work\n   directory. Here is an example::\n\n      $ bitbake bash\n      $ bitbake -c devshell bash\n      $ cd ..\n      $ scp packages-split/bash/bin/bash target:/bin/bash\n      $ cp -a packages-split/bash-dbg/\\* path/debugfs\n\nDebugging with the GNU Project Debugger (GDB) on the Target\n===========================================================\n\nThe previous section addressed using GDB remotely for debugging\npurposes, which is the most usual case due to the inherent hardware\nlimitations on many embedded devices. However, debugging in the target\nhardware itself is also possible with more powerful devices. This\nsection describes what you need to do in order to support using GDB to\ndebug on the target hardware.\n\nTo support this kind of debugging, you need do the following:\n\n-  Ensure that GDB is on the target. You can do this by making\n   the following addition to your ``local.conf`` file::\n\n      EXTRA_IMAGE_FEATURES:append = \" tools-debug\"\n\n-  Ensure that debug symbols are present. You can do so by adding the\n   corresponding ``-dbg`` package to :term:`IMAGE_INSTALL`::\n\n      IMAGE_INSTALL:append = \" packagename-dbg\"\n\n   Alternatively, you can add the following to ``local.conf`` to include\n   all the debug symbols::\n\n      EXTRA_IMAGE_FEATURES:append = \" dbg-pkgs\"\n\n.. note::\n\n   To improve the debug information accuracy, you can reduce the level\n   of optimization used by the compiler. For example, when adding the\n   following line to your ``local.conf`` file, you will reduce optimization\n   from :term:`FULL_OPTIMIZATION` of \"-O2\" to :term:`DEBUG_OPTIMIZATION`\n   of \"-O -fno-omit-frame-pointer\"::\n\n           DEBUG_BUILD = \"1\"\n\n   Consider that this will reduce the application's performance and is\n   recommended only for debugging purposes.\n\nEnabling Minidebuginfo\n======================\n\nEnabling the :term:`DISTRO_FEATURES` minidebuginfo adds a compressed ELF section ``.gnu_debugdata``\nto all binary files, containing only function names, and thus increasing the size of the\nbinaries only by 5 to 10%. For comparison, full debug symbols can be 10 times as big as\na stripped binary, and it is thus not always possible to deploy full debug symbols.\nMinidebuginfo data allows, on the one side, to retrieve a call-stack using\nGDB (command backtrace) without deploying full debug symbols to the target. It also\nallows to retrieve a symbolicated call-stack when using ``systemd-coredump`` to manage\ncoredumps (commands ``coredumpctl list`` and ``coredumpctl info``).\n\nThis feature was created by Fedora, see https://fedoraproject.org/wiki/Features/MiniDebugInfo for\nmore details.\n\nOther Debugging Tips\n====================\n\nHere are some other tips that you might find useful:\n\n-  When adding new packages, it is worth watching for undesirable items\n   making their way into compiler command lines. For example, you do not\n   want references to local system files like ``/usr/lib/`` or\n   ``/usr/include/``.\n\n"}
{"text": "\n\nDebugging Tools and Techniques\n-  If you want to remove the ``psplash`` boot splashscreen, add\n   ``psplash=false`` to the kernel command line. Doing so prevents\n   ``psplash`` from loading and thus allows you to see the console. It\n   is also possible to switch out of the splashscreen by switching the\n   virtual console (e.g. Fn+Left or Fn+Right on a Zaurus).\n\n-  Removing :term:`TMPDIR` (usually ``tmp/``, within the\n   :term:`Build Directory`) can often fix temporary build issues. Removing\n   :term:`TMPDIR` is usually a relatively cheap operation, because task output\n   will be cached in :term:`SSTATE_DIR` (usually ``sstate-cache/``, which is\n   also in the :term:`Build Directory`).\n\n   .. note::\n\n      Removing :term:`TMPDIR` might be a workaround rather than a fix.\n      Consequently, trying to determine the underlying cause of an issue before\n      removing the directory is a good idea.\n\n-  Understanding how a feature is used in practice within existing\n   recipes can be very helpful. It is recommended that you configure\n   some method that allows you to quickly search through files.\n\n   Using GNU Grep, you can use the following shell function to\n   recursively search through common recipe-related files, skipping\n   binary files, ``.git`` directories, and the :term:`Build Directory`\n   (assuming its name starts with \"build\")::\n\n      g() {\n          grep -Ir \\\n               --exclude-dir=.git \\\n               --exclude-dir='build*' \\\n               --include='*.bb*' \\\n               --include='*.inc*' \\\n               --include='*.conf*' \\\n               --include='*.py*' \\\n               \"$@\"\n      }\n\n   Following are some usage examples::\n\n      $ g FOO # Search recursively for \"FOO\"\n      $ g -i foo # Search recursively for \"foo\", ignoring case\n      $ g -w FOO # Search recursively for \"FOO\" as a word, ignoring e.g. \"FOOBAR\"\n\n   If figuring\n   out how some feature works requires a lot of searching, it might\n   indicate that the documentation should be extended or improved. In\n   such cases, consider filing a documentation bug using the Yocto\n   Project implementation of\n   :yocto_bugs:`Bugzilla <>`. For information on\n   how to submit a bug against the Yocto Project, see the Yocto Project\n   Bugzilla :yocto_wiki:`wiki page </Bugzilla_Configuration_and_Bug_Tracking>`\n   and the \":doc:`../contributor-guide/report-defect`\" section.\n\n   .. note::\n\n      The manuals might not be the right place to document variables\n      that are purely internal and have a limited scope (e.g. internal\n      variables used to implement a single ``.bbclass`` file).\n\n"}
{"text": "\n\nPerforming Automated Runtime Testing\n\n\nPerforming Automated Runtime Testing\n************************************\n\nThe OpenEmbedded build system makes available a series of automated\ntests for images to verify runtime functionality. You can run these\ntests on either QEMU or actual target hardware. Tests are written in\nPython making use of the ``unittest`` module, and the majority of them\nrun commands on the target system over SSH. This section describes how\nyou set up the environment to use these tests, run available tests, and\nwrite and add your own tests.\n\nFor information on the test and QA infrastructure available within the\nYocto Project, see the \":ref:`ref-manual/release-process:testing and quality assurance`\"\nsection in the Yocto Project Reference Manual.\n\nEnabling Tests\n==============\n\nDepending on whether you are planning to run tests using QEMU or on the\nhardware, you have to take different steps to enable the tests. See the\nfollowing subsections for information on how to enable both types of\ntests.\n\nEnabling Runtime Tests on QEMU\n------------------------------\n\nIn order to run tests, you need to do the following:\n\n-  *Set up to avoid interaction with sudo for networking:* To\n   accomplish this, you must do one of the following:\n\n   -  Add ``NOPASSWD`` for your user in ``/etc/sudoers`` either for all\n      commands or just for ``runqemu-ifup``. You must provide the full\n      path as that can change if you are using multiple clones of the\n      source repository.\n\n      .. note::\n\n         On some distributions, you also need to comment out \"Defaults\n         requiretty\" in ``/etc/sudoers``.\n\n   -  Manually configure a tap interface for your system.\n\n   -  Run as root the script in ``scripts/runqemu-gen-tapdevs``, which\n      should generate a list of tap devices. This is the option\n      typically chosen for Autobuilder-type environments.\n\n      .. note::\n\n         -  Be sure to use an absolute path when calling this script\n            with sudo.\n\n         -  The package recipe ``qemu-helper-native`` is required to run\n            this script. Build the package using the following command::\n\n               $ bitbake qemu-helper-native\n\n-  *Set the DISPLAY variable:* You need to set this variable so that\n   you have an X server available (e.g. start ``vncserver`` for a\n   headless machine).\n\n-  *Be sure your host's firewall accepts incoming connections from\n   192.168.7.0/24:* Some of the tests (in particular DNF tests) start an\n   HTTP server on a random high number port, which is used to serve\n   files to the target. The DNF module serves\n   ``${WORKDIR}/oe-rootfs-repo`` so it can run DNF channel commands.\n   That means your host's firewall must accept incoming connections from\n   192.168.7.0/24, which is the default IP range used for tap devices by\n   ``runqemu``.\n\n-  *Be sure your host has the correct packages installed:* Depending\n   your host's distribution, you need to have the following packages\n   installed:\n\n   -  Ubuntu and Debian: ``sysstat`` and ``iproute2``\n\n   -  openSUSE: ``sysstat`` and ``iproute2``\n\n   -  Fedora: ``sysstat`` and ``iproute``\n\n   -  CentOS: ``sysstat`` and ``iproute``\n\nOnce you start running the tests, the following happens:\n\n#. A copy of the root filesystem is written to ``${WORKDIR}/testimage``.\n\n#. The image is booted under QEMU using the standard ``runqemu`` script.\n\n#. A default timeout of 500 seconds occurs to allow for the boot process\n   to reach the login prompt. You can change the timeout period by\n   setting\n   :term:`TEST_QEMUBOOT_TIMEOUT`\n   in the ``local.conf`` file.\n\n#. Once the boot process is reached and the login prompt appears, the\n   tests run. The full boot log is written to\n   ``${WORKDIR}/testimage/qemu_boot_log``.\n\n"}
{"text": "\n\nPerforming Automated Runtime Testing\n#. Each test module loads in the order found in :term:`TEST_SUITES`. You can\n   find the full output of the commands run over SSH in\n   ``${WORKDIR}/testimgage/ssh_target_log``.\n\n#. If no failures occur, the task running the tests ends successfully.\n   You can find the output from the ``unittest`` in the task log at\n   ``${WORKDIR}/temp/log.do_testimage``.\n\nEnabling Runtime Tests on Hardware\n----------------------------------\n\nThe OpenEmbedded build system can run tests on real hardware, and for\ncertain devices it can also deploy the image to be tested onto the\ndevice beforehand.\n\nFor automated deployment, a \"controller image\" is installed onto the\nhardware once as part of setup. Then, each time tests are to be run, the\nfollowing occurs:\n\n#. The controller image is booted into and used to write the image to be\n   tested to a second partition.\n\n#. The device is then rebooted using an external script that you need to\n   provide.\n\n#. The device boots into the image to be tested.\n\nWhen running tests (independent of whether the image has been deployed\nautomatically or not), the device is expected to be connected to a\nnetwork on a pre-determined IP address. You can either use static IP\naddresses written into the image, or set the image to use DHCP and have\nyour DHCP server on the test network assign a known IP address based on\nthe MAC address of the device.\n\nIn order to run tests on hardware, you need to set :term:`TEST_TARGET` to an\nappropriate value. For QEMU, you do not have to change anything, the\ndefault value is \"qemu\". For running tests on hardware, the following\noptions are available:\n\n-  *\"simpleremote\":* Choose \"simpleremote\" if you are going to run tests\n   on a target system that is already running the image to be tested and\n   is available on the network. You can use \"simpleremote\" in\n   conjunction with either real hardware or an image running within a\n   separately started QEMU or any other virtual machine manager.\n\n-  *\"SystemdbootTarget\":* Choose \"SystemdbootTarget\" if your hardware is\n   an EFI-based machine with ``systemd-boot`` as bootloader and\n   ``core-image-testmaster`` (or something similar) is installed. Also,\n   your hardware under test must be in a DHCP-enabled network that gives\n   it the same IP address for each reboot.\n\n   If you choose \"SystemdbootTarget\", there are additional requirements\n   and considerations. See the\n   \":ref:`dev-manual/runtime-testing:selecting systemdboottarget`\" section, which\n   follows, for more information.\n\n-  *\"BeagleBoneTarget\":* Choose \"BeagleBoneTarget\" if you are deploying\n   images and running tests on the BeagleBone \"Black\" or original\n   \"White\" hardware. For information on how to use these tests, see the\n   comments at the top of the BeagleBoneTarget\n   ``meta-yocto-bsp/lib/oeqa/controllers/beaglebonetarget.py`` file.\n\n-  *\"GrubTarget\":* Choose \"GrubTarget\" if you are deploying images and running\n   tests on any generic PC that boots using GRUB. For information on how\n   to use these tests, see the comments at the top of the GrubTarget\n   ``meta-yocto-bsp/lib/oeqa/controllers/grubtarget.py`` file.\n\n-  *\"your-target\":* Create your own custom target if you want to run\n   tests when you are deploying images and running tests on a custom\n   machine within your BSP layer. To do this, you need to add a Python\n   unit that defines the target class under ``lib/oeqa/controllers/``\n   within your layer. You must also provide an empty ``__init__.py``.\n   For examples, see files in ``meta-yocto-bsp/lib/oeqa/controllers/``.\n\nSelecting SystemdbootTarget\n---------------------------\n\nIf you did not set :term:`TEST_TARGET` to \"SystemdbootTarget\", then you do\nnot need any information in this section. You can skip down to the\n\":ref:`dev-manual/runtime-testing:running tests`\" section.\n\nIf you did set :term:`TEST_TARGET` to \"SystemdbootTarget\", you also need to\nperform a one-time setup of your controller image by doing the following:\n\n#. *Set EFI_PROVIDER:* Be sure that :term:`EFI_PROVIDER` is as follows::\n\n      EFI_PROVIDER = \"systemd-boot\"\n\n#. *Build the controller image:* Build the ``core-image-testmaster`` image.\n   The ``core-image-testmaster`` recipe is provided as an example for a\n   \"controller\" image and you can customize the image recipe as you would\n   any other recipe.\n\n   Here are the image recipe requirements:\n\n   -  Inherits ``core-image`` so that kernel modules are installed.\n\n   -  Installs normal linux utilities not BusyBox ones (e.g. ``bash``,\n      ``coreutils``, ``tar``, ``gzip``, and ``kmod``).\n\n"}
{"text": "\n\nPerforming Automated Runtime Testing\n   -  Uses a custom :term:`Initramfs` image with a custom\n      installer. A normal image that you can install usually creates a\n      single root filesystem partition. This image uses another installer that\n      creates a specific partition layout. Not all Board Support\n      Packages (BSPs) can use an installer. For such cases, you need to\n      manually create the following partition layout on the target:\n\n      -  First partition mounted under ``/boot``, labeled \"boot\".\n\n      -  The main root filesystem partition where this image gets installed,\n         which is mounted under ``/``.\n\n      -  Another partition labeled \"testrootfs\" where test images get\n         deployed.\n\n#. *Install image:* Install the image that you just built on the target\n   system.\n\nThe final thing you need to do when setting :term:`TEST_TARGET` to\n\"SystemdbootTarget\" is to set up the test image:\n\n#. *Set up your local.conf file:* Make sure you have the following\n   statements in your ``local.conf`` file::\n\n      IMAGE_FSTYPES += \"tar.gz\"\n      IMAGE_CLASSES += \"testimage\"\n      TEST_TARGET = \"SystemdbootTarget\"\n      TEST_TARGET_IP = \"192.168.2.3\"\n\n#. *Build your test image:* Use BitBake to build the image::\n\n      $ bitbake core-image-sato\n\nPower Control\n-------------\n\nFor most hardware targets other than \"simpleremote\", you can control\npower:\n\n-  You can use :term:`TEST_POWERCONTROL_CMD` together with\n   :term:`TEST_POWERCONTROL_EXTRA_ARGS` as a command that runs on the host\n   and does power cycling. The test code passes one argument to that\n   command: off, on or cycle (off then on). Here is an example that\n   could appear in your ``local.conf`` file::\n\n      TEST_POWERCONTROL_CMD = \"powercontrol.exp test 10.11.12.1 nuc1\"\n\n   In this example, the expect\n   script does the following:\n\n   .. code-block:: shell\n\n      ssh test@10.11.12.1 \"pyctl nuc1 arg\"\n\n   It then runs a Python script that controls power for a label called\n   ``nuc1``.\n\n   .. note::\n\n      You need to customize :term:`TEST_POWERCONTROL_CMD` and\n      :term:`TEST_POWERCONTROL_EXTRA_ARGS` for your own setup. The one requirement\n      is that it accepts \"on\", \"off\", and \"cycle\" as the last argument.\n\n-  When no command is defined, it connects to the device over SSH and\n   uses the classic reboot command to reboot the device. Classic reboot\n   is fine as long as the machine actually reboots (i.e. the SSH test\n   has not failed). It is useful for scenarios where you have a simple\n   setup, typically with a single board, and where some manual\n   interaction is okay from time to time.\n\nIf you have no hardware to automatically perform power control but still\nwish to experiment with automated hardware testing, you can use the\n``dialog-power-control`` script that shows a dialog prompting you to perform\nthe required power action. This script requires either KDialog or Zenity\nto be installed. To use this script, set the\n:term:`TEST_POWERCONTROL_CMD`\nvariable as follows::\n\n   TEST_POWERCONTROL_CMD = \"${COREBASE}/scripts/contrib/dialog-power-control\"\n\nSerial Console Connection\n-------------------------\n\nFor test target classes requiring a serial console to interact with the\nbootloader (e.g. BeagleBoneTarget and GrubTarget),\nyou need to specify a command to use to connect to the serial console of\nthe target machine by using the\n:term:`TEST_SERIALCONTROL_CMD`\nvariable and optionally the\n:term:`TEST_SERIALCONTROL_EXTRA_ARGS`\nvariable.\n\nThese cases could be a serial terminal program if the machine is\nconnected to a local serial port, or a ``telnet`` or ``ssh`` command\nconnecting to a remote console server. Regardless of the case, the\ncommand simply needs to connect to the serial console and forward that\nconnection to standard input and output as any normal terminal program\ndoes. For example, to use the picocom terminal program on serial device\n``/dev/ttyUSB0`` at 115200bps, you would set the variable as follows::\n\n"}
{"text": "\n\nPerforming Automated Runtime Testing\n   TEST_SERIALCONTROL_CMD = \"picocom /dev/ttyUSB0 -b 115200\"\n\nFor local\ndevices where the serial port device disappears when the device reboots,\nan additional \"serdevtry\" wrapper script is provided. To use this\nwrapper, simply prefix the terminal command with\n``${COREBASE}/scripts/contrib/serdevtry``::\n\n   TEST_SERIALCONTROL_CMD = \"${COREBASE}/scripts/contrib/serdevtry picocom -b 115200 /dev/ttyUSB0\"\n\nRunning Tests\n=============\n\nYou can start the tests automatically or manually:\n\n-  *Automatically running tests:* To run the tests automatically after the\n   OpenEmbedded build system successfully creates an image, first set the\n   :term:`TESTIMAGE_AUTO` variable to \"1\" in your ``local.conf`` file in the\n   :term:`Build Directory`::\n\n      TESTIMAGE_AUTO = \"1\"\n\n   Next, build your image. If the image successfully builds, the\n   tests run::\n\n      bitbake core-image-sato\n\n-  *Manually running tests:* To manually run the tests, first globally\n   inherit the :ref:`ref-classes-testimage` class by editing your\n   ``local.conf`` file::\n\n      IMAGE_CLASSES += \"testimage\"\n\n   Next, use BitBake to run the tests::\n\n      bitbake -c testimage image\n\nAll test files reside in ``meta/lib/oeqa/runtime/cases`` in the\n:term:`Source Directory`. A test name maps\ndirectly to a Python module. Each test module may contain a number of\nindividual tests. Tests are usually grouped together by the area tested\n(e.g tests for systemd reside in ``meta/lib/oeqa/runtime/cases/systemd.py``).\n\nYou can add tests to any layer provided you place them in the proper\narea and you extend :term:`BBPATH` in\nthe ``local.conf`` file as normal. Be sure that tests reside in\n``layer/lib/oeqa/runtime/cases``.\n\n.. note::\n\n   Be sure that module names do not collide with module names used in\n   the default set of test modules in ``meta/lib/oeqa/runtime/cases``.\n\nYou can change the set of tests run by appending or overriding\n:term:`TEST_SUITES` variable in\n``local.conf``. Each name in :term:`TEST_SUITES` represents a required test\nfor the image. Test modules named within :term:`TEST_SUITES` cannot be\nskipped even if a test is not suitable for an image (e.g. running the\nRPM tests on an image without ``rpm``). Appending \"auto\" to\n:term:`TEST_SUITES` causes the build system to try to run all tests that are\nsuitable for the image (i.e. each test module may elect to skip itself).\n\nThe order you list tests in :term:`TEST_SUITES` is important and influences\ntest dependencies. Consequently, tests that depend on other tests should\nbe added after the test on which they depend. For example, since the\n``ssh`` test depends on the ``ping`` test, \"ssh\" needs to come after\n\"ping\" in the list. The test class provides no re-ordering or dependency\nhandling.\n\n.. note::\n\n   Each module can have multiple classes with multiple test methods.\n   And, Python ``unittest`` rules apply.\n\nHere are some things to keep in mind when running tests:\n\n-  The default tests for the image are defined as::\n\n      DEFAULT_TEST_SUITES:pn-image = \"ping ssh df connman syslog xorg scp vnc date rpm dnf dmesg\"\n\n-  Add your own test to the list of the by using the following::\n\n      TEST_SUITES:append = \" mytest\"\n\n-  Run a specific list of tests as follows::\n\n     TEST_SUITES = \"test1 test2 test3\"\n\n   Remember, order is important. Be sure to place a test that is\n   dependent on another test later in the order.\n\nExporting Tests\n===============\n\nYou can export tests so that they can run independently of the build\nsystem. Exporting tests is required if you want to be able to hand the\ntest execution off to a scheduler. You can only export tests that are\ndefined in :term:`TEST_SUITES`.\n\nIf your image is already built, make sure the following are set in your\n"}
{"text": "\n\nPerforming Automated Runtime Testing\n``local.conf`` file::\n\n   INHERIT += \"testexport\"\n   TEST_TARGET_IP = \"IP-address-for-the-test-target\"\n   TEST_SERVER_IP = \"IP-address-for-the-test-server\"\n\nYou can then export the tests with the\nfollowing BitBake command form::\n\n   $ bitbake image -c testexport\n\nExporting the tests places them in the :term:`Build Directory` in\n``tmp/testexport/``\\ image, which is controlled by the :term:`TEST_EXPORT_DIR`\nvariable.\n\nYou can now run the tests outside of the build environment::\n\n   $ cd tmp/testexport/image\n   $ ./runexported.py testdata.json\n\nHere is a complete example that shows IP addresses and uses the\n``core-image-sato`` image::\n\n   INHERIT += \"testexport\"\n   TEST_TARGET_IP = \"192.168.7.2\"\n   TEST_SERVER_IP = \"192.168.7.1\"\n\nUse BitBake to export the tests::\n\n   $ bitbake core-image-sato -c testexport\n\nRun the tests outside of\nthe build environment using the following::\n\n   $ cd tmp/testexport/core-image-sato\n   $ ./runexported.py testdata.json\n\nWriting New Tests\n=================\n\nAs mentioned previously, all new test files need to be in the proper\nplace for the build system to find them. New tests for additional\nfunctionality outside of the core should be added to the layer that adds\nthe functionality, in ``layer/lib/oeqa/runtime/cases`` (as long as\n:term:`BBPATH` is extended in the\nlayer's ``layer.conf`` file as normal). Just remember the following:\n\n-  Filenames need to map directly to test (module) names.\n\n-  Do not use module names that collide with existing core tests.\n\n-  Minimally, an empty ``__init__.py`` file must be present in the runtime\n   directory.\n\nTo create a new test, start by copying an existing module (e.g.\n``oe_syslog.py`` or ``gcc.py`` are good ones to use). Test modules can use\ncode from ``meta/lib/oeqa/utils``, which are helper classes.\n\n.. note::\n\n   Structure shell commands such that you rely on them and they return a\n   single code for success. Be aware that sometimes you will need to\n   parse the output. See the ``df.py`` and ``date.py`` modules for examples.\n\nYou will notice that all test classes inherit ``oeRuntimeTest``, which\nis found in ``meta/lib/oetest.py``. This base class offers some helper\nattributes, which are described in the following sections:\n\nClass Methods\n-------------\n\nClass methods are as follows:\n\n-  *hasPackage(pkg):* Returns \"True\" if ``pkg`` is in the installed\n   package list of the image, which is based on the manifest file that\n   is generated during the :ref:`ref-tasks-rootfs` task.\n\n-  *hasFeature(feature):* Returns \"True\" if the feature is in\n   :term:`IMAGE_FEATURES` or\n   :term:`DISTRO_FEATURES`.\n\nClass Attributes\n----------------\n\nClass attributes are as follows:\n\n-  *pscmd:* Equals \"ps -ef\" if ``procps`` is installed in the image.\n   Otherwise, ``pscmd`` equals \"ps\" (busybox).\n\n-  *tc:* The called test context, which gives access to the\n   following attributes:\n\n   -  *d:* The BitBake datastore, which allows you to use stuff such\n      as ``oeRuntimeTest.tc.d.getVar(\"VIRTUAL-RUNTIME_init_manager\")``.\n\n   -  *testslist and testsrequired:* Used internally. The tests\n      do not need these.\n\n   -  *filesdir:* The absolute path to\n      ``meta/lib/oeqa/runtime/files``, which contains helper files for\n"}
{"text": "\n\nPerforming Automated Runtime Testing\n      tests meant for copying on the target such as small files written\n      in C for compilation.\n\n   -  *target:* The target controller object used to deploy and\n      start an image on a particular target (e.g. Qemu, SimpleRemote,\n      and SystemdbootTarget). Tests usually use the following:\n\n      -  *ip:* The target's IP address.\n\n      -  *server_ip:* The host's IP address, which is usually used\n         by the DNF test suite.\n\n      -  *run(cmd, timeout=None):* The single, most used method.\n         This command is a wrapper for: ``ssh root@host \"cmd\"``. The\n         command returns a tuple: (status, output), which are what their\n         names imply - the return code of \"cmd\" and whatever output it\n         produces. The optional timeout argument represents the number\n         of seconds the test should wait for \"cmd\" to return. If the\n         argument is \"None\", the test uses the default instance's\n         timeout period, which is 300 seconds. If the argument is \"0\",\n         the test runs until the command returns.\n\n      -  *copy_to(localpath, remotepath):*\n         ``scp localpath root@ip:remotepath``.\n\n      -  *copy_from(remotepath, localpath):*\n         ``scp root@host:remotepath localpath``.\n\nInstance Attributes\n-------------------\n\nThere is a single instance attribute, which is ``target``. The ``target``\ninstance attribute is identical to the class attribute of the same name,\nwhich is described in the previous section. This attribute exists as\nboth an instance and class attribute so tests can use\n``self.target.run(cmd)`` in instance methods instead of\n``oeRuntimeTest.tc.target.run(cmd)``.\n\nInstalling Packages in the DUT Without the Package Manager\n==========================================================\n\nWhen a test requires a package built by BitBake, it is possible to\ninstall that package. Installing the package does not require a package\nmanager be installed in the device under test (DUT). It does, however,\nrequire an SSH connection and the target must be using the\n``sshcontrol`` class.\n\n.. note::\n\n   This method uses ``scp`` to copy files from the host to the target, which\n   causes permissions and special attributes to be lost.\n\nA JSON file is used to define the packages needed by a test. This file\nmust be in the same path as the file used to define the tests.\nFurthermore, the filename must map directly to the test module name with\na ``.json`` extension.\n\nThe JSON file must include an object with the test name as keys of an\nobject or an array. This object (or array of objects) uses the following\ndata:\n\n-  \"pkg\" --- a mandatory string that is the name of the package to be\n   installed.\n\n-  \"rm\" --- an optional boolean, which defaults to \"false\", that specifies\n   to remove the package after the test.\n\n-  \"extract\" --- an optional boolean, which defaults to \"false\", that\n   specifies if the package must be extracted from the package format.\n   When set to \"true\", the package is not automatically installed into\n   the DUT.\n\nFollowing is an example JSON file that handles test \"foo\" installing\npackage \"bar\" and test \"foobar\" installing packages \"foo\" and \"bar\".\nOnce the test is complete, the packages are removed from the DUT::\n\n     {\n         \"foo\": {\n             \"pkg\": \"bar\"\n         },\n         \"foobar\": [\n             {\n                 \"pkg\": \"foo\",\n                 \"rm\": true\n             },\n             {\n                 \"pkg\": \"bar\",\n                 \"rm\": true\n             }\n         ]\n     }\n\n"}
{"text": "\n\nPerforming Automated Runtime Testing\n.. _init-manager:\n\nSelecting an Initialization Manager\n\n\n.. _init-manager:\n\nSelecting an Initialization Manager\n***********************************\n\nBy default, the Yocto Project uses :wikipedia:`SysVinit <Init#SysV-style>` as\nthe initialization manager. There is also support for BusyBox init, a simpler\nimplementation, as well as support for :wikipedia:`systemd <Systemd>`, which\nis a full replacement for init with parallel starting of services, reduced\nshell overhead, increased security and resource limits for services, and other\nfeatures that are used by many distributions.\n\nWithin the system, SysVinit and BusyBox init treat system components as\nservices. These services are maintained as shell scripts stored in the\n``/etc/init.d/`` directory.\n\nSysVinit is more elaborate than BusyBox init and organizes services in\ndifferent run levels. This organization is maintained by putting links\nto the services in the ``/etc/rcN.d/`` directories, where `N/` is one\nof the following options: \"S\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", or \"6\".\n\n.. note::\n\n   Each runlevel has a dependency on the previous runlevel. This\n   dependency allows the services to work properly.\n\nBoth SysVinit and BusyBox init are configured through the ``/etc/inittab``\nfile, with a very similar syntax, though of course BusyBox init features\nare more limited.\n\nIn comparison, systemd treats components as units. Using units is a\nbroader concept as compared to using a service. A unit includes several\ndifferent types of entities. ``Service`` is one of the types of entities.\nThe runlevel concept in SysVinit corresponds to the concept of a target\nin systemd, where target is also a type of supported unit.\n\nIn systems with SysVinit or BusyBox init, services load sequentially (i.e. one\nby one) during init and parallelization is not supported. With systemd, services\nstart in parallel. This method can have an impact on the startup performance\nof a given service, though systemd will also provide more services by default,\ntherefore increasing the total system boot time. systemd also substantially\nincreases system size because of its multiple components and the extra\ndependencies it pulls.\n\nOn the contrary, BusyBox init is the simplest and the lightest solution and\nalso comes with BusyBox mdev as device manager, a lighter replacement to\n:wikipedia:`udev <Udev>`, which SysVinit and systemd both use.\n\nThe \":ref:`device-manager`\" chapter has more details about device managers.\n\nUsing SysVinit with udev\n=========================\n\nSysVinit with the udev device manager corresponds to the\ndefault setting in Poky. This corresponds to setting::\n\n   INIT_MANAGER = \"sysvinit\"\n\nUsing BusyBox init with BusyBox mdev\n====================================\n\nBusyBox init with BusyBox mdev is the simplest and lightest solution\nfor small root filesystems. All you need is BusyBox, which most systems\nhave anyway::\n\n   INIT_MANAGER = \"mdev-busybox\"\n\nUsing systemd\n=============\n\nThe last option is to use systemd together with the udev device\nmanager. This is the most powerful and versatile solution, especially\nfor more complex systems::\n\n   INIT_MANAGER = \"systemd\"\n\nThis will enable systemd and remove sysvinit components from the image.\nSee :yocto_git:`meta/conf/distro/include/init-manager-systemd.inc\n</poky/tree/meta/conf/distro/include/init-manager-systemd.inc>` for exact\ndetails on what this does.\n\nControling systemd from the target command line\n-----------------------------------------------\n\nHere is a quick reference for controling systemd from the command line on the\ntarget. Instead of opening and sometimes modifying files, most interaction\nhappens through the ``systemctl`` and ``journalctl`` commands:\n\n-  ``systemctl status``: show the status of all services\n-  ``systemctl status <service>``: show the status of one service\n-  ``systemctl [start|stop] <service>``: start or stop a service\n-  ``systemctl [enable|disable] <service>``: enable or disable a service at boot time\n-  ``systemctl list-units``: list all available units\n-  ``journalctl -a``: show all logs for all services\n-  ``journalctl -f``: show only the last log entries, and keep printing updates as they arrive\n-  ``journalctl -u``: show only logs from a particular service\n\nUsing systemd-journald without a traditional syslog daemon\n"}
{"text": "\n\nPerforming Automated Runtime Testing\n.. _init-manager:\n\nSelecting an Initialization Manager\n----------------------------------------------------------\n\nCounter-intuitively, ``systemd-journald`` is not a syslog runtime or provider,\nand the proper way to use ``systemd-journald`` as your sole logging mechanism is to\neffectively disable syslog entirely by setting these variables in your distribution\nconfiguration file::\n\n   VIRTUAL-RUNTIME_syslog = \"\"\n   VIRTUAL-RUNTIME_base-utils-syslog = \"\"\n\nDoing so will prevent ``rsyslog`` / ``busybox-syslog`` from being pulled in by\ndefault, leaving only ``systemd-journald``.\n\nSummary\n-------\n\nThe Yocto Project supports three different initialization managers, offering\nincreasing levels of complexity and functionality:\n\n.. list-table::\n   :widths: 40 20 20 20\n   :header-rows: 1\n\n   * - \n     - BusyBox init\n     - SysVinit\n     - systemd\n   * - Size\n     - Small\n     - Small\n     - Big [#footnote-systemd-size]_\n   * - Complexity\n     - Small\n     - Medium\n     - High\n   * - Support for boot profiles\n     - No\n     - Yes (\"runlevels\")\n     - Yes (\"targets\")\n   * - Services defined as\n     - Shell scripts\n     - Shell scripts\n     - Description files\n   * - Starting services in parallel\n     - No\n     - No\n     - Yes\n   * - Setting service resource limits\n     - No\n     - No\n     - Yes\n   * - Support service isolation\n     - No\n     - No\n     - Yes\n   * - Integrated logging\n     - No\n     - No\n     - Yes\n\n.. [#footnote-systemd-size] Using systemd increases the ``core-image-minimal``\n   image size by 160\\% for ``qemux86-64`` on Mickledore (4.2), compared to SysVinit.\n"}
{"text": "\n\nWorking With Licenses\n\n\nWorking With Licenses\n*********************\n\nAs mentioned in the \":ref:`overview-manual/development-environment:licensing`\"\nsection in the Yocto Project Overview and Concepts Manual, open source\nprojects are open to the public and they consequently have different\nlicensing structures in place. This section describes the mechanism by\nwhich the :term:`OpenEmbedded Build System`\ntracks changes to\nlicensing text and covers how to maintain open source license compliance\nduring your project's lifecycle. The section also describes how to\nenable commercially licensed recipes, which by default are disabled.\n\nTracking License Changes\n========================\n\nThe license of an upstream project might change in the future. In order\nto prevent these changes going unnoticed, the\n:term:`LIC_FILES_CHKSUM`\nvariable tracks changes to the license text. The checksums are validated\nat the end of the configure step, and if the checksums do not match, the\nbuild will fail.\n\nSpecifying the ``LIC_FILES_CHKSUM`` Variable\n--------------------------------------------\n\nThe :term:`LIC_FILES_CHKSUM` variable contains checksums of the license text\nin the source code for the recipe. Following is an example of how to\nspecify :term:`LIC_FILES_CHKSUM`::\n\n   LIC_FILES_CHKSUM = \"file://COPYING;md5=xxxx \\\n                       file://licfile1.txt;beginline=5;endline=29;md5=yyyy \\\n                       file://licfile2.txt;endline=50;md5=zzzz \\\n                       ...\"\n\n.. note::\n\n   -  When using \"beginline\" and \"endline\", realize that line numbering\n      begins with one and not zero. Also, the included lines are\n      inclusive (i.e. lines five through and including 29 in the\n      previous example for ``licfile1.txt``).\n\n   -  When a license check fails, the selected license text is included\n      as part of the QA message. Using this output, you can determine\n      the exact start and finish for the needed license text.\n\nThe build system uses the :term:`S`\nvariable as the default directory when searching files listed in\n:term:`LIC_FILES_CHKSUM`. The previous example employs the default\ndirectory.\n\nConsider this next example::\n\n   LIC_FILES_CHKSUM = \"file://src/ls.c;beginline=5;endline=16;\\\n                                       md5=bb14ed3c4cda583abc85401304b5cd4e\"\n   LIC_FILES_CHKSUM = \"file://${WORKDIR}/license.html;md5=5c94767cedb5d6987c902ac850ded2c6\"\n\nThe first line locates a file in ``${S}/src/ls.c`` and isolates lines\nfive through 16 as license text. The second line refers to a file in\n:term:`WORKDIR`.\n\nNote that :term:`LIC_FILES_CHKSUM` variable is mandatory for all recipes,\nunless the :term:`LICENSE` variable is set to \"CLOSED\".\n\nExplanation of Syntax\n---------------------\n\nAs mentioned in the previous section, the :term:`LIC_FILES_CHKSUM` variable\nlists all the important files that contain the license text for the\nsource code. It is possible to specify a checksum for an entire file, or\na specific section of a file (specified by beginning and ending line\nnumbers with the \"beginline\" and \"endline\" parameters, respectively).\nThe latter is useful for source files with a license notice header,\nREADME documents, and so forth. If you do not use the \"beginline\"\nparameter, then it is assumed that the text begins on the first line of\nthe file. Similarly, if you do not use the \"endline\" parameter, it is\nassumed that the license text ends with the last line of the file.\n\nThe \"md5\" parameter stores the md5 checksum of the license text. If the\nlicense text changes in any way as compared to this parameter then a\nmismatch occurs. This mismatch triggers a build failure and notifies the\ndeveloper. Notification allows the developer to review and address the\nlicense text changes. Also note that if a mismatch occurs during the\nbuild, the correct md5 checksum is placed in the build log and can be\neasily copied to the recipe.\n\nThere is no limit to how many files you can specify using the\n:term:`LIC_FILES_CHKSUM` variable. Generally, however, every project\nrequires a few specifications for license tracking. Many projects have a\n\"COPYING\" file that stores the license information for all the source\ncode files. This practice allows you to just track the \"COPYING\" file as\nlong as it is kept up to date.\n\n.. note::\n\n   -  If you specify an empty or invalid \"md5\" parameter,\n      :term:`BitBake` returns an md5\n      mis-match error and displays the correct \"md5\" parameter value\n"}
{"text": "\n\nWorking With Licenses\n      during the build. The correct parameter is also captured in the\n      build log.\n\n   -  If the whole file contains only license text, you do not need to\n      use the \"beginline\" and \"endline\" parameters.\n\nEnabling Commercially Licensed Recipes\n======================================\n\nBy default, the OpenEmbedded build system disables components that have\ncommercial or other special licensing requirements. Such requirements\nare defined on a recipe-by-recipe basis through the\n:term:`LICENSE_FLAGS` variable\ndefinition in the affected recipe. For instance, the\n``poky/meta/recipes-multimedia/gstreamer/gst-plugins-ugly`` recipe\ncontains the following statement::\n\n   LICENSE_FLAGS = \"commercial\"\n\nHere is a\nslightly more complicated example that contains both an explicit recipe\nname and version (after variable expansion)::\n\n   LICENSE_FLAGS = \"license_${PN}_${PV}\"\n\nIt is possible to give more details about a specific license\nusing flags on the :term:`LICENSE_FLAGS_DETAILS` variable::\n\n   LICENSE_FLAGS_DETAILS[my-eula-license] = \"For further details, see https://example.com/eula.\"\n\nIf set, this will be displayed to the user if the license hasn't been accepted.\n\nIn order for a component restricted by a\n:term:`LICENSE_FLAGS` definition to be enabled and included in an image, it\nneeds to have a matching entry in the global\n:term:`LICENSE_FLAGS_ACCEPTED`\nvariable, which is a variable typically defined in your ``local.conf``\nfile. For example, to enable the\n``poky/meta/recipes-multimedia/gstreamer/gst-plugins-ugly`` package, you\ncould add either the string \"commercial_gst-plugins-ugly\" or the more\ngeneral string \"commercial\" to :term:`LICENSE_FLAGS_ACCEPTED`. See the\n\":ref:`dev-manual/licenses:license flag matching`\" section for a full\nexplanation of how :term:`LICENSE_FLAGS` matching works. Here is the\nexample::\n\n   LICENSE_FLAGS_ACCEPTED = \"commercial_gst-plugins-ugly\"\n\nLikewise, to additionally enable the package built from the recipe\ncontaining ``LICENSE_FLAGS = \"license_${PN}_${PV}\"``, and assuming that\nthe actual recipe name was ``emgd_1.10.bb``, the following string would\nenable that package as well as the original ``gst-plugins-ugly``\npackage::\n\n   LICENSE_FLAGS_ACCEPTED = \"commercial_gst-plugins-ugly license_emgd_1.10\"\n\nAs a convenience, you do not need to specify the\ncomplete license string for every package. You can use\nan abbreviated form, which consists of just the first portion or\nportions of the license string before the initial underscore character\nor characters. A partial string will match any license that contains the\ngiven string as the first portion of its license. For example, the\nfollowing value will also match both of the packages\npreviously mentioned as well as any other packages that have licenses\nstarting with \"commercial\" or \"license\"::\n\n   LICENSE_FLAGS_ACCEPTED = \"commercial license\"\n\nLicense Flag Matching\n---------------------\n\nLicense flag matching allows you to control what recipes the\nOpenEmbedded build system includes in the build. Fundamentally, the\nbuild system attempts to match :term:`LICENSE_FLAGS` strings found in\nrecipes against strings found in :term:`LICENSE_FLAGS_ACCEPTED`.\nA match causes the build system to include a recipe in the\nbuild, while failure to find a match causes the build system to exclude\na recipe.\n\nIn general, license flag matching is simple. However, understanding some\nconcepts will help you correctly and effectively use matching.\n\nBefore a flag defined by a particular recipe is tested against the\nentries of :term:`LICENSE_FLAGS_ACCEPTED`, the expanded\nstring ``_${PN}`` is appended to the flag. This expansion makes each\n:term:`LICENSE_FLAGS` value recipe-specific. After expansion, the\nstring is then matched against the entries. Thus, specifying\n``LICENSE_FLAGS = \"commercial\"`` in recipe \"foo\", for example, results\nin the string ``\"commercial_foo\"``. And, to create a match, that string\nmust appear among the entries of :term:`LICENSE_FLAGS_ACCEPTED`.\n\nJudicious use of the :term:`LICENSE_FLAGS` strings and the contents of the\n:term:`LICENSE_FLAGS_ACCEPTED` variable allows you a lot of flexibility for\nincluding or excluding recipes based on licensing. For example, you can\nbroaden the matching capabilities by using license flags string subsets\nin :term:`LICENSE_FLAGS_ACCEPTED`.\n\n.. note::\n\n   When using a string subset, be sure to use the part of the expanded\n   string that precedes the appended underscore character (e.g.\n"}
{"text": "\n\nWorking With Licenses\n   ``usethispart_1.3``, ``usethispart_1.4``, and so forth).\n\nFor example, simply specifying the string \"commercial\" in the\n:term:`LICENSE_FLAGS_ACCEPTED` variable matches any expanded\n:term:`LICENSE_FLAGS` definition that starts with the string\n\"commercial\" such as \"commercial_foo\" and \"commercial_bar\", which\nare the strings the build system automatically generates for\nhypothetical recipes named \"foo\" and \"bar\" assuming those recipes simply\nspecify the following::\n\n   LICENSE_FLAGS = \"commercial\"\n\nThus, you can choose to exhaustively enumerate each license flag in the\nlist and allow only specific recipes into the image, or you can use a\nstring subset that causes a broader range of matches to allow a range of\nrecipes into the image.\n\nThis scheme works even if the :term:`LICENSE_FLAGS` string already has\n``_${PN}`` appended. For example, the build system turns the license\nflag \"commercial_1.2_foo\" into \"commercial_1.2_foo_foo\" and would match\nboth the general \"commercial\" and the specific \"commercial_1.2_foo\"\nstrings found in the :term:`LICENSE_FLAGS_ACCEPTED` variable, as expected.\n\nHere are some other scenarios:\n\n-  You can specify a versioned string in the recipe such as\n   \"commercial_foo_1.2\" in a \"foo\" recipe. The build system expands this\n   string to \"commercial_foo_1.2_foo\". Combine this license flag with a\n   :term:`LICENSE_FLAGS_ACCEPTED` variable that has the string\n   \"commercial\" and you match the flag along with any other flag that\n   starts with the string \"commercial\".\n\n-  Under the same circumstances, you can add \"commercial_foo\" in the\n   :term:`LICENSE_FLAGS_ACCEPTED` variable and the build system not only\n   matches \"commercial_foo_1.2\" but also matches any license flag with\n   the string \"commercial_foo\", regardless of the version.\n\n-  You can be very specific and use both the package and version parts\n   in the :term:`LICENSE_FLAGS_ACCEPTED` list (e.g.\n   \"commercial_foo_1.2\") to specifically match a versioned recipe.\n\nOther Variables Related to Commercial Licenses\n----------------------------------------------\n\nThere are other helpful variables related to commercial license handling,\ndefined in the\n``poky/meta/conf/distro/include/default-distrovars.inc`` file::\n\n   COMMERCIAL_AUDIO_PLUGINS ?= \"\"\n   COMMERCIAL_VIDEO_PLUGINS ?= \"\"\n\nIf you want to enable these components, you can do so by making sure you have\nstatements similar to the following in your ``local.conf`` configuration file::\n\n   COMMERCIAL_AUDIO_PLUGINS = \"gst-plugins-ugly-mad \\\n       gst-plugins-ugly-mpegaudioparse\"\n   COMMERCIAL_VIDEO_PLUGINS = \"gst-plugins-ugly-mpeg2dec \\\n       gst-plugins-ugly-mpegstream gst-plugins-bad-mpegvideoparse\"\n   LICENSE_FLAGS_ACCEPTED = \"commercial_gst-plugins-ugly commercial_gst-plugins-bad commercial_qmmp\"\n\nOf course, you could also create a matching list for those components using the\nmore general \"commercial\" string in the :term:`LICENSE_FLAGS_ACCEPTED` variable,\nbut that would also enable all the other packages with :term:`LICENSE_FLAGS`\ncontaining \"commercial\", which you may or may not want::\n\n   LICENSE_FLAGS_ACCEPTED = \"commercial\"\n\nSpecifying audio and video plugins as part of the\n:term:`COMMERCIAL_AUDIO_PLUGINS` and :term:`COMMERCIAL_VIDEO_PLUGINS` statements\n(along with :term:`LICENSE_FLAGS_ACCEPTED`) includes the plugins or\ncomponents into built images, thus adding support for media formats or\ncomponents.\n\n.. note::\n\n   GStreamer \"ugly\" and \"bad\" plugins are actually available through\n   open source licenses. However, the \"ugly\" ones can be subject to software\n   patents in some countries, making it necessary to pay licensing fees\n   to distribute them. The \"bad\" ones are just deemed unreliable by the\n   GStreamer community and should therefore be used with care.\n\nMaintaining Open Source License Compliance During Your Product's Lifecycle\n==========================================================================\n\nOne of the concerns for a development organization using open source\nsoftware is how to maintain compliance with various open source\nlicensing during the lifecycle of the product. While this section does\nnot provide legal advice or comprehensively cover all scenarios, it does\npresent methods that you can use to assist you in meeting the compliance\nrequirements during a software release.\n\nWith hundreds of different open source licenses that the Yocto Project\ntracks, it is difficult to know the requirements of each and every\nlicense. However, the requirements of the major FLOSS licenses can begin\nto be covered by assuming that there are three main areas of concern:\n\n-  Source code must be provided.\n\n-  License text for the software must be provided.\n\n"}
{"text": "\n\nWorking With Licenses\n-  Compilation scripts and modifications to the source code must be\n   provided.\n\nThere are other requirements beyond the scope of these three and the\nmethods described in this section (e.g. the mechanism through which\nsource code is distributed).\n\nAs different organizations have different ways of releasing software,\nthere can be multiple ways of meeting license obligations. At\nleast, we describe here two methods for achieving compliance:\n\n-  The first method is to use OpenEmbedded's ability to provide\n   the source code, provide a list of licenses, as well as\n   compilation scripts and source code modifications.\n\n   The remainder of this section describes supported methods to meet\n   the previously mentioned three requirements.\n\n-  The second method is to generate a *Software Bill of Materials*\n   (:term:`SBoM`), as described in the \":doc:`/dev-manual/sbom`\" section.\n   Not only do you generate :term:`SPDX` output which can be used meet\n   license compliance requirements (except for sharing the build system\n   and layers sources for the time being), but this output also includes\n   component version and patch information which can be used\n   for vulnerability assessment.\n\nWhatever method you choose, prior to releasing images, sources,\nand the build system, you should audit all artifacts to ensure\ncompleteness.\n\n.. note::\n\n   The Yocto Project generates a license manifest during image creation\n   that is located in\n   ``${DEPLOY_DIR}/licenses/${SSTATE_PKGARCH}/<image-name>-<machine>.rootfs-<datestamp>/``\n   to assist with any audits.\n\nProviding the Source Code\n-------------------------\n\nCompliance activities should begin before you generate the final image.\nThe first thing you should look at is the requirement that tops the list\nfor most compliance groups --- providing the source. The Yocto Project has\na few ways of meeting this requirement.\n\nOne of the easiest ways to meet this requirement is to provide the\nentire :term:`DL_DIR` used by the\nbuild. This method, however, has a few issues. The most obvious is the\nsize of the directory since it includes all sources used in the build\nand not just the source used in the released image. It will include\ntoolchain source, and other artifacts, which you would not generally\nrelease. However, the more serious issue for most companies is\naccidental release of proprietary software. The Yocto Project provides\nan :ref:`ref-classes-archiver` class to help avoid some of these concerns.\n\nBefore you employ :term:`DL_DIR` or the :ref:`ref-classes-archiver` class, you\nneed to decide how you choose to provide source. The source\n:ref:`ref-classes-archiver` class can generate tarballs and SRPMs and can\ncreate them with various levels of compliance in mind.\n\nOne way of doing this (but certainly not the only way) is to release\njust the source as a tarball. You can do this by adding the following to\nthe ``local.conf`` file found in the :term:`Build Directory`::\n\n   INHERIT += \"archiver\"\n   ARCHIVER_MODE[src] = \"original\"\n\nDuring the creation of your\nimage, the source from all recipes that deploy packages to the image is\nplaced within subdirectories of ``DEPLOY_DIR/sources`` based on the\n:term:`LICENSE` for each recipe.\nReleasing the entire directory enables you to comply with requirements\nconcerning providing the unmodified source. It is important to note that\nthe size of the directory can get large.\n\nA way to help mitigate the size issue is to only release tarballs for\nlicenses that require the release of source. Let us assume you are only\nconcerned with GPL code as identified by running the following script:\n\n.. code-block:: shell\n\n   # Script to archive a subset of packages matching specific license(s)\n   # Source and license files are copied into sub folders of package folder\n   # Must be run from build folder\n   #!/bin/bash\n   src_release_dir=\"source-release\"\n   mkdir -p $src_release_dir\n   for a in tmp/deploy/sources/*; do\n      for d in $a/*; do\n         # Get package name from path\n         p=`basename $d`\n         p=${p%-*}\n         p=${p%-*}\n         # Only archive GPL packages (update *GPL* regex for your license check)\n         numfiles=`ls tmp/deploy/licenses/$p/*GPL* 2> /dev/null | wc -l`\n         if [ $numfiles -ge 1 ]; then\n            echo Archiving $p\n            mkdir -p $src_release_dir/$p/source\n            cp $d/* $src_release_dir/$p/source 2> /dev/null\n            mkdir -p $src_release_dir/$p/license\n"}
{"text": "\n\nWorking With Licenses\n            cp tmp/deploy/licenses/$p/* $src_release_dir/$p/license 2> /dev/null\n         fi\n      done\n   done\n\nAt this point, you\ncould create a tarball from the ``gpl_source_release`` directory and\nprovide that to the end user. This method would be a step toward\nachieving compliance with section 3a of GPLv2 and with section 6 of\nGPLv3.\n\nProviding License Text\n----------------------\n\nOne requirement that is often overlooked is inclusion of license text.\nThis requirement also needs to be dealt with prior to generating the\nfinal image. Some licenses require the license text to accompany the\nbinary. You can achieve this by adding the following to your\n``local.conf`` file::\n\n   COPY_LIC_MANIFEST = \"1\"\n   COPY_LIC_DIRS = \"1\"\n   LICENSE_CREATE_PACKAGE = \"1\"\n\nAdding these statements to the\nconfiguration file ensures that the licenses collected during package\ngeneration are included on your image.\n\n.. note::\n\n   Setting all three variables to \"1\" results in the image having two\n   copies of the same license file. One copy resides in\n   ``/usr/share/common-licenses`` and the other resides in\n   ``/usr/share/license``.\n\n   The reason for this behavior is because\n   :term:`COPY_LIC_DIRS` and\n   :term:`COPY_LIC_MANIFEST`\n   add a copy of the license when the image is built but do not offer a\n   path for adding licenses for newly installed packages to an image.\n   :term:`LICENSE_CREATE_PACKAGE`\n   adds a separate package and an upgrade path for adding licenses to an\n   image.\n\nAs the source :ref:`ref-classes-archiver` class has already archived the\noriginal unmodified source that contains the license files, you would have\nalready met the requirements for inclusion of the license information\nwith source as defined by the GPL and other open source licenses.\n\nProviding Compilation Scripts and Source Code Modifications\n-----------------------------------------------------------\n\nAt this point, we have addressed all we need prior to generating the\nimage. The next two requirements are addressed during the final\npackaging of the release.\n\nBy releasing the version of the OpenEmbedded build system and the layers\nused during the build, you will be providing both compilation scripts\nand the source code modifications in one step.\n\nIf the deployment team has a :ref:`overview-manual/concepts:bsp layer`\nand a distro layer, and those\nthose layers are used to patch, compile, package, or modify (in any way)\nany open source software included in your released images, you might be\nrequired to release those layers under section 3 of GPLv2 or section 1\nof GPLv3. One way of doing that is with a clean checkout of the version\nof the Yocto Project and layers used during your build. Here is an\nexample:\n\n.. code-block:: shell\n\n   # We built using the dunfell branch of the poky repo\n   $ git clone -b dunfell git://git.yoctoproject.org/poky\n   $ cd poky\n   # We built using the release_branch for our layers\n   $ git clone -b release_branch git://git.mycompany.com/meta-my-bsp-layer\n   $ git clone -b release_branch git://git.mycompany.com/meta-my-software-layer\n   # clean up the .git repos\n   $ find . -name \".git\" -type d -exec rm -rf {} \\;\n\nOne thing a development organization might want to consider for end-user\nconvenience is to modify\n``meta-poky/conf/templates/default/bblayers.conf.sample`` to ensure that when\nthe end user utilizes the released build system to build an image, the\ndevelopment organization's layers are included in the ``bblayers.conf`` file\nautomatically::\n\n   # POKY_BBLAYERS_CONF_VERSION is increased each time build/conf/bblayers.conf\n   # changes incompatibly\n   POKY_BBLAYERS_CONF_VERSION = \"2\"\n\n   BBPATH = \"${TOPDIR}\"\n   BBFILES ?= \"\"\n\n   BBLAYERS ?= \" \\\n     ##OEROOT##/meta \\\n     ##OEROOT##/meta-poky \\\n     ##OEROOT##/meta-yocto-bsp \\\n     ##OEROOT##/meta-mylayer \\\n     \"\n"}
{"text": "\n\nWorking With Licenses\n\nCreating and\nproviding an archive of the :term:`Metadata`\nlayers (recipes, configuration files, and so forth) enables you to meet\nyour requirements to include the scripts to control compilation as well\nas any modifications to the original source.\n\nCompliance Limitations with Executables Built from Static Libraries\n-------------------------------------------------------------------\n\nWhen package A is added to an image via the :term:`RDEPENDS` or :term:`RRECOMMENDS`\nmechanisms as well as explicitly included in the image recipe with\n:term:`IMAGE_INSTALL`, and depends on a static linked library recipe B\n(``DEPENDS += \"B\"``), package B will neither appear in the generated license\nmanifest nor in the generated source tarballs.  This occurs as the\n:ref:`ref-classes-license` and :ref:`ref-classes-archiver` classes assume that\nonly packages included via :term:`RDEPENDS` or :term:`RRECOMMENDS`\nend up in the image.\n\nAs a result, potential obligations regarding license compliance for package B\nmay not be met.\n\nThe Yocto Project doesn't enable static libraries by default, in part because\nof this issue. Before a solution to this limitation is found, you need to\nkeep in mind that if your root filesystem is built from static libraries,\nyou will need to manually ensure that your deliveries are compliant\nwith the licenses of these libraries.\n\nCopying Non Standard Licenses\n=============================\n\nSome packages, such as the linux-firmware package, have many licenses\nthat are not in any way common. You can avoid adding a lot of these\ntypes of common license files, which are only applicable to a specific\npackage, by using the\n:term:`NO_GENERIC_LICENSE`\nvariable. Using this variable also avoids QA errors when you use a\nnon-common, non-CLOSED license in a recipe.\n\nHere is an example that uses the ``LICENSE.Abilis.txt`` file as\nthe license from the fetched source::\n\n   NO_GENERIC_LICENSE[Firmware-Abilis] = \"LICENSE.Abilis.txt\"\n\n"}
{"text": "\n\nUsing an External SCM\n\n\nUsing an External SCM\n*********************\n\nIf you're working on a recipe that pulls from an external Source Code\nManager (SCM), it is possible to have the OpenEmbedded build system\nnotice new recipe changes added to the SCM and then build the resulting\npackages that depend on the new recipes by using the latest versions.\nThis only works for SCMs from which it is possible to get a sensible\nrevision number for changes. Currently, you can do this with Apache\nSubversion (SVN), Git, and Bazaar (BZR) repositories.\n\nTo enable this behavior, the :term:`PV` of\nthe recipe needs to reference\n:term:`SRCPV`. Here is an example::\n\n   PV = \"1.2.3+git${SRCPV}\"\n\nThen, you can add the following to your\n``local.conf``::\n\n   SRCREV:pn-PN = \"${AUTOREV}\"\n\n:term:`PN` is the name of the recipe for\nwhich you want to enable automatic source revision updating.\n\nIf you do not want to update your local configuration file, you can add\nthe following directly to the recipe to finish enabling the feature::\n\n   SRCREV = \"${AUTOREV}\"\n\nThe Yocto Project provides a distribution named ``poky-bleeding``, whose\nconfiguration file contains the line::\n\n   require conf/distro/include/poky-floating-revisions.inc\n\nThis line pulls in the\nlisted include file that contains numerous lines of exactly that form::\n\n   #SRCREV:pn-opkg-native ?= \"${AUTOREV}\"\n   #SRCREV:pn-opkg-sdk ?= \"${AUTOREV}\"\n   #SRCREV:pn-opkg ?= \"${AUTOREV}\"\n   #SRCREV:pn-opkg-utils-native ?= \"${AUTOREV}\"\n   #SRCREV:pn-opkg-utils ?= \"${AUTOREV}\"\n   SRCREV:pn-gconf-dbus ?= \"${AUTOREV}\"\n   SRCREV:pn-matchbox-common ?= \"${AUTOREV}\"\n   SRCREV:pn-matchbox-config-gtk ?= \"${AUTOREV}\"\n   SRCREV:pn-matchbox-desktop ?= \"${AUTOREV}\"\n   SRCREV:pn-matchbox-keyboard ?= \"${AUTOREV}\"\n   SRCREV:pn-matchbox-panel-2 ?= \"${AUTOREV}\"\n   SRCREV:pn-matchbox-themes-extra ?= \"${AUTOREV}\"\n   SRCREV:pn-matchbox-terminal ?= \"${AUTOREV}\"\n   SRCREV:pn-matchbox-wm ?= \"${AUTOREV}\"\n   SRCREV:pn-settings-daemon ?= \"${AUTOREV}\"\n   SRCREV:pn-screenshot ?= \"${AUTOREV}\"\n   . . .\n\nThese lines allow you to\nexperiment with building a distribution that tracks the latest\ndevelopment source for numerous packages.\n\n.. note::\n\n   The ``poky-bleeding`` distribution is not tested on a regular basis. Keep\n   this in mind if you use it.\n\n"}
{"text": "\n\nCreating Partitioned Images Using Wic\n\n\nCreating Partitioned Images Using Wic\n*************************************\n\nCreating an image for a particular hardware target using the\nOpenEmbedded build system does not necessarily mean you can boot that\nimage as is on your device. Physical devices accept and boot images in\nvarious ways depending on the specifics of the device. Usually,\ninformation about the hardware can tell you what image format the device\nrequires. Should your device require multiple partitions on an SD card,\nflash, or an HDD, you can use the OpenEmbedded Image Creator, Wic, to\ncreate the properly partitioned image.\n\nThe ``wic`` command generates partitioned images from existing\nOpenEmbedded build artifacts. Image generation is driven by partitioning\ncommands contained in an OpenEmbedded kickstart file (``.wks``)\nspecified either directly on the command line or as one of a selection\nof canned kickstart files as shown with the ``wic list images`` command\nin the\n\":ref:`dev-manual/wic:generate an image using an existing kickstart file`\"\nsection. When you apply the command to a given set of build artifacts, the\nresult is an image or set of images that can be directly written onto media and\nused on a particular system.\n\n.. note::\n\n   For a kickstart file reference, see the\n   \":ref:`ref-manual/kickstart:openembedded kickstart (\\`\\`.wks\\`\\`) reference`\"\n   Chapter in the Yocto Project Reference Manual.\n\nThe ``wic`` command and the infrastructure it is based on is by\ndefinition incomplete. The purpose of the command is to allow the\ngeneration of customized images, and as such, was designed to be\ncompletely extensible through a plugin interface. See the\n\":ref:`dev-manual/wic:using the wic plugin interface`\" section\nfor information on these plugins.\n\nThis section provides some background information on Wic, describes what\nyou need to have in place to run the tool, provides instruction on how\nto use the Wic utility, provides information on using the Wic plugins\ninterface, and provides several examples that show how to use Wic.\n\nBackground\n==========\n\nThis section provides some background on the Wic utility. While none of\nthis information is required to use Wic, you might find it interesting.\n\n-  The name \"Wic\" is derived from OpenEmbedded Image Creator (oeic). The\n   \"oe\" diphthong in \"oeic\" was promoted to the letter \"w\", because\n   \"oeic\" is both difficult to remember and to pronounce.\n\n-  Wic is loosely based on the Meego Image Creator (``mic``) framework.\n   The Wic implementation has been heavily modified to make direct use\n   of OpenEmbedded build artifacts instead of package installation and\n   configuration, which are already incorporated within the OpenEmbedded\n   artifacts.\n\n-  Wic is a completely independent standalone utility that initially\n   provides easier-to-use and more flexible replacements for an existing\n   functionality in OE-Core's :ref:`ref-classes-image-live`\n   class. The difference between Wic and those examples is that with Wic\n   the functionality of those scripts is implemented by a\n   general-purpose partitioning language, which is based on Redhat\n   kickstart syntax.\n\nRequirements\n============\n\nIn order to use the Wic utility with the OpenEmbedded Build system, your\nsystem needs to meet the following requirements:\n\n-  The Linux distribution on your development host must support the\n   Yocto Project. See the \":ref:`system-requirements-supported-distros`\"\n   section in the Yocto Project Reference Manual for the list of\n   distributions that support the Yocto Project.\n\n-  The standard system utilities, such as ``cp``, must be installed on\n   your development host system.\n\n-  You must have sourced the build environment setup script (i.e.\n   :ref:`structure-core-script`) found in the :term:`Build Directory`.\n\n-  You need to have the build artifacts already available, which\n   typically means that you must have already created an image using the\n   OpenEmbedded build system (e.g. ``core-image-minimal``). While it\n   might seem redundant to generate an image in order to create an image\n   using Wic, the current version of Wic requires the artifacts in the\n   form generated by the OpenEmbedded build system.\n\n-  You must build several native tools, which are built to run on the\n   build system::\n\n      $ bitbake wic-tools\n\n-  Include \"wic\" as part of the\n   :term:`IMAGE_FSTYPES`\n   variable.\n\n"}
{"text": "\n\nCreating Partitioned Images Using Wic\n-  Include the name of the :ref:`wic kickstart file <openembedded-kickstart-wks-reference>`\n   as part of the :term:`WKS_FILE` variable. If multiple candidate files can\n   be provided by different layers, specify all the possible names through the\n   :term:`WKS_FILES` variable instead.\n\nGetting Help\n============\n\nYou can get general help for the ``wic`` command by entering the ``wic``\ncommand by itself or by entering the command with a help argument as\nfollows::\n\n   $ wic -h\n   $ wic --help\n   $ wic help\n\nCurrently, Wic supports seven commands: ``cp``, ``create``, ``help``,\n``list``, ``ls``, ``rm``, and ``write``. You can get help for all these\ncommands except \"help\" by using the following form::\n\n   $ wic help command\n\nFor example, the following command returns help for the ``write``\ncommand::\n\n   $ wic help write\n\nWic supports help for three topics: ``overview``, ``plugins``, and\n``kickstart``. You can get help for any topic using the following form::\n\n   $ wic help topic\n\nFor example, the following returns overview help for Wic::\n\n   $ wic help overview\n\nThere is one additional level of help for Wic. You can get help on\nindividual images through the ``list`` command. You can use the ``list``\ncommand to return the available Wic images as follows::\n\n   $ wic list images\n     genericx86                    \t\tCreate an EFI disk image for genericx86*\n     beaglebone-yocto              \t\tCreate SD card image for Beaglebone\n     qemuriscv                     \t\tCreate qcow2 image for RISC-V QEMU machines\n     mkefidisk                     \t\tCreate an EFI disk image\n     qemuloongarch                 \t\tCreate qcow2 image for LoongArch QEMU machines\n     directdisk-multi-rootfs       \t\tCreate multi rootfs image using rootfs plugin\n     directdisk                    \t\tCreate a 'pcbios' direct disk image\n     efi-bootdisk                  \t\t\n     mkhybridiso                   \t\tCreate a hybrid ISO image\n     directdisk-gpt                \t\tCreate a 'pcbios' direct disk image\n     systemd-bootdisk              \t\tCreate an EFI disk image with systemd-boot\n     sdimage-bootpart              \t\tCreate SD card image with a boot partition\n     qemux86-directdisk            \t\tCreate a qemu machine 'pcbios' direct disk image\n     directdisk-bootloader-config  \t\tCreate a 'pcbios' direct disk image with custom bootloader config\n\nOnce you know the list of available\nWic images, you can use ``help`` with the command to get help on a\nparticular image. For example, the following command returns help on the\n\"beaglebone-yocto\" image::\n\n   $ wic list beaglebone-yocto help\n\n   Creates a partitioned SD card image for Beaglebone.\n   Boot files are located in the first vfat partition.\n\nOperational Modes\n=================\n\nYou can use Wic in two different modes, depending on how much control\nyou need for specifying the OpenEmbedded build artifacts that are used\nfor creating the image: Raw and Cooked:\n\n-  *Raw Mode:* You explicitly specify build artifacts through Wic\n   command-line arguments.\n\n-  *Cooked Mode:* The current\n   :term:`MACHINE` setting and image\n   name are used to automatically locate and provide the build\n   artifacts. You just supply a kickstart file and the name of the image\n   from which to use artifacts.\n\nRegardless of the mode you use, you need to have the build artifacts\nready and available.\n\nRaw Mode\n--------\n\nRunning Wic in raw mode allows you to specify all the partitions through\nthe ``wic`` command line. The primary use for raw mode is if you have\nbuilt your kernel outside of the Yocto Project :term:`Build Directory`.\nIn other words, you can point to arbitrary kernel, root filesystem locations,\nand so forth. Contrast this behavior with cooked mode where Wic looks in the\n:term:`Build Directory` (e.g. ``tmp/deploy/images/``\\ machine).\n\nThe general form of the ``wic`` command in raw mode is::\n\n   $ wic create wks_file options ...\n\n     Where:\n"}
{"text": "\n\nCreating Partitioned Images Using Wic\n\n        wks_file:\n           An OpenEmbedded kickstart file.  You can provide\n           your own custom file or use a file from a set of\n           existing files as described by further options.\n\n        optional arguments:\n          -h, --help            show this help message and exit\n          -o OUTDIR, --outdir OUTDIR\n                                name of directory to create image in\n          -e IMAGE_NAME, --image-name IMAGE_NAME\n                                name of the image to use the artifacts from e.g. core-\n                                image-sato\n          -r ROOTFS_DIR, --rootfs-dir ROOTFS_DIR\n                                path to the /rootfs dir to use as the .wks rootfs\n                                source\n          -b BOOTIMG_DIR, --bootimg-dir BOOTIMG_DIR\n                                path to the dir containing the boot artifacts (e.g.\n                                /EFI or /syslinux dirs) to use as the .wks bootimg\n                                source\n          -k KERNEL_DIR, --kernel-dir KERNEL_DIR\n                                path to the dir containing the kernel to use in the\n                                .wks bootimg\n          -n NATIVE_SYSROOT, --native-sysroot NATIVE_SYSROOT\n                                path to the native sysroot containing the tools to use\n                                to build the image\n          -s, --skip-build-check\n                                skip the build check\n          -f, --build-rootfs    build rootfs\n          -c {gzip,bzip2,xz}, --compress-with {gzip,bzip2,xz}\n                                compress image with specified compressor\n          -m, --bmap            generate .bmap\n          --no-fstab-update     Do not change fstab file.\n          -v VARS_DIR, --vars VARS_DIR\n                                directory with <image>.env files that store bitbake\n                                variables\n          -D, --debug           output debug information\n\n.. note::\n\n   You do not need root privileges to run Wic. In fact, you should not\n   run as root when using the utility.\n\nCooked Mode\n-----------\n\nRunning Wic in cooked mode leverages off artifacts in the\n:term:`Build Directory`. In other words, you do not have to specify kernel or\nroot filesystem locations as part of the command. All you need to provide is\na kickstart file and the name of the image from which to use artifacts\nby using the \"-e\" option. Wic looks in the :term:`Build Directory` (e.g.\n``tmp/deploy/images/``\\ machine) for artifacts.\n\nThe general form of the ``wic`` command using Cooked Mode is as follows::\n\n   $ wic create wks_file -e IMAGE_NAME\n\n     Where:\n\n        wks_file:\n           An OpenEmbedded kickstart file.  You can provide\n           your own custom file or use a file from a set of\n           existing files provided with the Yocto Project\n           release.\n\n        required argument:\n           -e IMAGE_NAME, --image-name IMAGE_NAME\n                                name of the image to use the artifacts from e.g. core-\n                                image-sato\n\nUsing an Existing Kickstart File\n================================\n\nIf you do not want to create your own kickstart file, you can use an\nexisting file provided by the Wic installation. As shipped, kickstart\nfiles can be found in the :ref:`overview-manual/development-environment:yocto project source repositories` in the\nfollowing two locations::\n\n   poky/meta-yocto-bsp/wic\n   poky/scripts/lib/wic/canned-wks\n\nUse the following command to list the available kickstart files::\n\n   $ wic list images\n     genericx86                    \t\tCreate an EFI disk image for genericx86*\n     beaglebone-yocto              \t\tCreate SD card image for Beaglebone\n     qemuriscv                     \t\tCreate qcow2 image for RISC-V QEMU machines\n     mkefidisk                     \t\tCreate an EFI disk image\n     qemuloongarch                 \t\tCreate qcow2 image for LoongArch QEMU machines\n     directdisk-multi-rootfs       \t\tCreate multi rootfs image using rootfs plugin\n     directdisk                    \t\tCreate a 'pcbios' direct disk image\n     efi-bootdisk                  \t\t\n     mkhybridiso                   \t\tCreate a hybrid ISO image\n     directdisk-gpt                \t\tCreate a 'pcbios' direct disk image\n     systemd-bootdisk              \t\tCreate an EFI disk image with systemd-boot\n     sdimage-bootpart              \t\tCreate SD card image with a boot partition\n     qemux86-directdisk            \t\tCreate a qemu machine 'pcbios' direct disk image\n     directdisk-bootloader-config  \t\tCreate a 'pcbios' direct disk image with custom bootloader config\n\nWhen you use an existing file, you\n"}
{"text": "\n\nCreating Partitioned Images Using Wic\ndo not have to use the ``.wks`` extension. Here is an example in Raw\nMode that uses the ``directdisk`` file::\n\n   $ wic create directdisk -r rootfs_dir -b bootimg_dir \\\n         -k kernel_dir -n native_sysroot\n\nHere are the actual partition language commands used in the\n``genericx86.wks`` file to generate an image::\n\n   # short-description: Create an EFI disk image for genericx86*\n   # long-description: Creates a partitioned EFI disk image for genericx86* machines\n   part /boot --source bootimg-efi --sourceparams=\"loader=grub-efi\" --ondisk sda --label msdos --active --align 1024\n   part / --source rootfs --ondisk sda --fstype=ext4 --label platform --align 1024 --use-uuid\n   part swap --ondisk sda --size 44 --label swap1 --fstype=swap\n\n   bootloader --ptable gpt --timeout=5 --append=\"rootfstype=ext4 console=ttyS0,115200 console=tty0\"\n\nUsing the Wic Plugin Interface\n==============================\n\nYou can extend and specialize Wic functionality by using Wic plugins.\nThis section explains the Wic plugin interface.\n\n.. note::\n\n   Wic plugins consist of \"source\" and \"imager\" plugins. Imager plugins\n   are beyond the scope of this section.\n\nSource plugins provide a mechanism to customize partition content during\nthe Wic image generation process. You can use source plugins to map\nvalues that you specify using ``--source`` commands in kickstart files\n(i.e. ``*.wks``) to a plugin implementation used to populate a given\npartition.\n\n.. note::\n\n   If you use plugins that have build-time dependencies (e.g. native\n   tools, bootloaders, and so forth) when building a Wic image, you need\n   to specify those dependencies using the :term:`WKS_FILE_DEPENDS`\n   variable.\n\nSource plugins are subclasses defined in plugin files. As shipped, the\nYocto Project provides several plugin files. You can see the source\nplugin files that ship with the Yocto Project\n:yocto_git:`here </poky/tree/scripts/lib/wic/plugins/source>`.\nEach of these plugin files contains source plugins that are designed to\npopulate a specific Wic image partition.\n\nSource plugins are subclasses of the ``SourcePlugin`` class, which is\ndefined in the ``poky/scripts/lib/wic/pluginbase.py`` file. For example,\nthe ``BootimgEFIPlugin`` source plugin found in the ``bootimg-efi.py``\nfile is a subclass of the ``SourcePlugin`` class, which is found in the\n``pluginbase.py`` file.\n\nYou can also implement source plugins in a layer outside of the Source\nRepositories (external layer). To do so, be sure that your plugin files\nare located in a directory whose path is\n``scripts/lib/wic/plugins/source/`` within your external layer. When the\nplugin files are located there, the source plugins they contain are made\navailable to Wic.\n\nWhen the Wic implementation needs to invoke a partition-specific\nimplementation, it looks for the plugin with the same name as the\n``--source`` parameter used in the kickstart file given to that\npartition. For example, if the partition is set up using the following\ncommand in a kickstart file::\n\n   part /boot --source bootimg-pcbios --ondisk sda --label boot --active --align 1024\n\nThe methods defined as class\nmembers of the matching source plugin (i.e. ``bootimg-pcbios``) in the\n``bootimg-pcbios.py`` plugin file are used.\n\nTo be more concrete, here is the corresponding plugin definition from\nthe ``bootimg-pcbios.py`` file for the previous command along with an\nexample method called by the Wic implementation when it needs to prepare\na partition using an implementation-specific function::\n\n                .\n                .\n                .\n   class BootimgPcbiosPlugin(SourcePlugin):\n       \"\"\"\n       Create MBR boot partition and install syslinux on it.\n       \"\"\"\n\n      name = 'bootimg-pcbios'\n                .\n                .\n                .\n       @classmethod\n       def do_prepare_partition(cls, part, source_params, creator, cr_workdir,\n                                oe_builddir, bootimg_dir, kernel_dir,\n                                rootfs_dir, native_sysroot):\n           \"\"\"\n           Called to do the actual content population for a partition i.e. it\n           'prepares' the partition to be incorporated into the image.\n           In this case, prepare content for legacy bios boot partition.\n           \"\"\"\n                .\n"}
{"text": "\n\nCreating Partitioned Images Using Wic\n                .\n                .\n\nIf a\nsubclass (plugin) itself does not implement a particular function, Wic\nlocates and uses the default version in the superclass. It is for this\nreason that all source plugins are derived from the ``SourcePlugin``\nclass.\n\nThe ``SourcePlugin`` class defined in the ``pluginbase.py`` file defines\na set of methods that source plugins can implement or override. Any\nplugins (subclass of ``SourcePlugin``) that do not implement a\nparticular method inherit the implementation of the method from the\n``SourcePlugin`` class. For more information, see the ``SourcePlugin``\nclass in the ``pluginbase.py`` file for details:\n\nThe following list describes the methods implemented in the\n``SourcePlugin`` class:\n\n-  ``do_prepare_partition()``: Called to populate a partition with\n   actual content. In other words, the method prepares the final\n   partition image that is incorporated into the disk image.\n\n-  ``do_configure_partition()``: Called before\n   ``do_prepare_partition()`` to create custom configuration files for a\n   partition (e.g. syslinux or grub configuration files).\n\n-  ``do_install_disk()``: Called after all partitions have been\n   prepared and assembled into a disk image. This method provides a hook\n   to allow finalization of a disk image (e.g. writing an MBR).\n\n-  ``do_stage_partition()``: Special content-staging hook called\n   before ``do_prepare_partition()``. This method is normally empty.\n\n   Typically, a partition just uses the passed-in parameters (e.g. the\n   unmodified value of ``bootimg_dir``). However, in some cases, things\n   might need to be more tailored. As an example, certain files might\n   additionally need to be taken from ``bootimg_dir + /boot``. This hook\n   allows those files to be staged in a customized fashion.\n\n   .. note::\n\n      ``get_bitbake_var()`` allows you to access non-standard variables that\n      you might want to use for this behavior.\n\nYou can extend the source plugin mechanism. To add more hooks, create\nmore source plugin methods within ``SourcePlugin`` and the corresponding\nderived subclasses. The code that calls the plugin methods uses the\n``plugin.get_source_plugin_methods()`` function to find the method or\nmethods needed by the call. Retrieval of those methods is accomplished\nby filling up a dict with keys that contain the method names of\ninterest. On success, these will be filled in with the actual methods.\nSee the Wic implementation for examples and details.\n\nWic Examples\n============\n\nThis section provides several examples that show how to use the Wic\nutility. All the examples assume the list of requirements in the\n\":ref:`dev-manual/wic:requirements`\" section have been met. The\nexamples assume the previously generated image is\n``core-image-minimal``.\n\nGenerate an Image using an Existing Kickstart File\n--------------------------------------------------\n\nThis example runs in Cooked Mode and uses the ``mkefidisk`` kickstart\nfile::\n\n   $ wic create mkefidisk -e core-image-minimal\n   INFO: Building wic-tools...\n             .\n             .\n             .\n   INFO: The new image(s) can be found here:\n     ./mkefidisk-201804191017-sda.direct\n\n   The following build artifacts were used to create the image(s):\n     ROOTFS_DIR:                   /home/stephano/yocto/build/tmp-glibc/work/qemux86-oe-linux/core-image-minimal/1.0-r0/rootfs\n     BOOTIMG_DIR:                  /home/stephano/yocto/build/tmp-glibc/work/qemux86-oe-linux/core-image-minimal/1.0-r0/recipe-sysroot/usr/share\n     KERNEL_DIR:                   /home/stephano/yocto/build/tmp-glibc/deploy/images/qemux86\n     NATIVE_SYSROOT:               /home/stephano/yocto/build/tmp-glibc/work/i586-oe-linux/wic-tools/1.0-r0/recipe-sysroot-native\n\n   INFO: The image(s) were created using OE kickstart file:\n     /home/stephano/yocto/openembedded-core/scripts/lib/wic/canned-wks/mkefidisk.wks\n\nThe previous example shows the easiest way to create an image by running\nin cooked mode and supplying a kickstart file and the \"-e\" option to\npoint to the existing build artifacts. Your ``local.conf`` file needs to\nhave the :term:`MACHINE` variable set\nto the machine you are using, which is \"qemux86\" in this example.\n\nOnce the image builds, the output provides image location, artifact use,\nand kickstart file information.\n\n.. note::\n\n   You should always verify the details provided in the output to make\n   sure that the image was indeed created exactly as expected.\n\n"}
{"text": "\n\nCreating Partitioned Images Using Wic\nContinuing with the example, you can now write the image from the\n:term:`Build Directory` onto a USB stick, or whatever media for which you\nbuilt your image, and boot from the media. You can write the image by using\n``bmaptool`` or ``dd``::\n\n   $ oe-run-native bmap-tools-native bmaptool copy mkefidisk-201804191017-sda.direct /dev/sdX\n\nor ::\n\n   $ sudo dd if=mkefidisk-201804191017-sda.direct of=/dev/sdX\n\n.. note::\n\n   For more information on how to use the ``bmaptool``\n   to flash a device with an image, see the\n   \":ref:`dev-manual/bmaptool:flashing images using \\`\\`bmaptool\\`\\``\"\n   section.\n\nUsing a Modified Kickstart File\n-------------------------------\n\nBecause partitioned image creation is driven by the kickstart file, it\nis easy to affect image creation by changing the parameters in the file.\nThis next example demonstrates that through modification of the\n``directdisk-gpt`` kickstart file.\n\nAs mentioned earlier, you can use the command ``wic list images`` to\nshow the list of existing kickstart files. The directory in which the\n``directdisk-gpt.wks`` file resides is\n``scripts/lib/image/canned-wks/``, which is located in the\n:term:`Source Directory` (e.g. ``poky``).\nBecause available files reside in this directory, you can create and add\nyour own custom files to the directory. Subsequent use of the\n``wic list images`` command would then include your kickstart files.\n\nIn this example, the existing ``directdisk-gpt`` file already does most\nof what is needed. However, for the hardware in this example, the image\nwill need to boot from ``sdb`` instead of ``sda``, which is what the\n``directdisk-gpt`` kickstart file uses.\n\nThe example begins by making a copy of the ``directdisk-gpt.wks`` file\nin the ``scripts/lib/image/canned-wks`` directory and then by changing\nthe lines that specify the target disk from which to boot::\n\n   $ cp /home/stephano/yocto/poky/scripts/lib/wic/canned-wks/directdisk-gpt.wks \\\n        /home/stephano/yocto/poky/scripts/lib/wic/canned-wks/directdisksdb-gpt.wks\n\nNext, the example modifies the ``directdisksdb-gpt.wks`` file and\nchanges all instances of \"``--ondisk sda``\" to \"``--ondisk sdb``\". The\nexample changes the following two lines and leaves the remaining lines\nuntouched::\n\n   part /boot --source bootimg-pcbios --ondisk sdb --label boot --active --align 1024\n   part / --source rootfs --ondisk sdb --fstype=ext4 --label platform --align 1024 --use-uuid\n\nOnce the lines are changed, the\nexample generates the ``directdisksdb-gpt`` image. The command points\nthe process at the ``core-image-minimal`` artifacts for the Next Unit of\nComputing (nuc) :term:`MACHINE` the\n``local.conf``::\n\n   $ wic create directdisksdb-gpt -e core-image-minimal\n   INFO: Building wic-tools...\n              .\n              .\n              .\n   Initialising tasks: 100% |#######################################| Time: 0:00:01\n   NOTE: Executing SetScene Tasks\n   NOTE: Executing RunQueue Tasks\n   NOTE: Tasks Summary: Attempted 1161 tasks of which 1157 didn't need to be rerun and all succeeded.\n   INFO: Creating image(s)...\n\n   INFO: The new image(s) can be found here:\n     ./directdisksdb-gpt-201710090938-sdb.direct\n\n   The following build artifacts were used to create the image(s):\n     ROOTFS_DIR:                   /home/stephano/yocto/build/tmp-glibc/work/qemux86-oe-linux/core-image-minimal/1.0-r0/rootfs\n     BOOTIMG_DIR:                  /home/stephano/yocto/build/tmp-glibc/work/qemux86-oe-linux/core-image-minimal/1.0-r0/recipe-sysroot/usr/share\n     KERNEL_DIR:                   /home/stephano/yocto/build/tmp-glibc/deploy/images/qemux86\n     NATIVE_SYSROOT:               /home/stephano/yocto/build/tmp-glibc/work/i586-oe-linux/wic-tools/1.0-r0/recipe-sysroot-native\n\n   INFO: The image(s) were created using OE kickstart file:\n     /home/stephano/yocto/poky/scripts/lib/wic/canned-wks/directdisksdb-gpt.wks\n\nContinuing with the example, you can now directly ``dd`` the image to a\nUSB stick, or whatever media for which you built your image, and boot\nthe resulting media::\n\n   $ sudo dd if=directdisksdb-gpt-201710090938-sdb.direct of=/dev/sdb\n   140966+0 records in\n   140966+0 records out\n   72174592 bytes (72 MB, 69 MiB) copied, 78.0282 s, 925 kB/s\n   $ sudo eject /dev/sdb\n\nUsing a Modified Kickstart File and Running in Raw Mode\n-------------------------------------------------------\n\nThis next example manually specifies each build artifact (runs in Raw\nMode) and uses a modified kickstart file. The example also uses the\n``-o`` option to cause Wic to create the output somewhere other than the\n"}
{"text": "\n\nCreating Partitioned Images Using Wic\ndefault output directory, which is the current directory::\n\n   $ wic create test.wks -o /home/stephano/testwic \\\n        --rootfs-dir /home/stephano/yocto/build/tmp/work/qemux86-poky-linux/core-image-minimal/1.0-r0/rootfs \\\n        --bootimg-dir /home/stephano/yocto/build/tmp/work/qemux86-poky-linux/core-image-minimal/1.0-r0/recipe-sysroot/usr/share \\\n        --kernel-dir /home/stephano/yocto/build/tmp/deploy/images/qemux86 \\\n        --native-sysroot /home/stephano/yocto/build/tmp/work/i586-poky-linux/wic-tools/1.0-r0/recipe-sysroot-native\n\n   INFO: Creating image(s)...\n\n   INFO: The new image(s) can be found here:\n     /home/stephano/testwic/test-201710091445-sdb.direct\n\n   The following build artifacts were used to create the image(s):\n     ROOTFS_DIR:                   /home/stephano/yocto/build/tmp-glibc/work/qemux86-oe-linux/core-image-minimal/1.0-r0/rootfs\n     BOOTIMG_DIR:                  /home/stephano/yocto/build/tmp-glibc/work/qemux86-oe-linux/core-image-minimal/1.0-r0/recipe-sysroot/usr/share\n     KERNEL_DIR:                   /home/stephano/yocto/build/tmp-glibc/deploy/images/qemux86\n     NATIVE_SYSROOT:               /home/stephano/yocto/build/tmp-glibc/work/i586-oe-linux/wic-tools/1.0-r0/recipe-sysroot-native\n\n   INFO: The image(s) were created using OE kickstart file:\n     test.wks\n\nFor this example,\n:term:`MACHINE` did not have to be\nspecified in the ``local.conf`` file since the artifact is manually\nspecified.\n\nUsing Wic to Manipulate an Image\n--------------------------------\n\nWic image manipulation allows you to shorten turnaround time during\nimage development. For example, you can use Wic to delete the kernel\npartition of a Wic image and then insert a newly built kernel. This\nsaves you time from having to rebuild the entire image each time you\nmodify the kernel.\n\n.. note::\n\n   In order to use Wic to manipulate a Wic image as in this example,\n   your development machine must have the ``mtools`` package installed.\n\nThe following example examines the contents of the Wic image, deletes\nthe existing kernel, and then inserts a new kernel:\n\n#. *List the Partitions:* Use the ``wic ls`` command to list all the\n   partitions in the Wic image::\n\n      $ wic ls tmp/deploy/images/qemux86/core-image-minimal-qemux86.wic\n      Num     Start        End          Size      Fstype\n       1       1048576     25041919     23993344  fat16\n       2      25165824     72157183     46991360  ext4\n\n   The previous output shows two partitions in the\n   ``core-image-minimal-qemux86.wic`` image.\n\n#. *Examine a Particular Partition:* Use the ``wic ls`` command again\n   but in a different form to examine a particular partition.\n\n   .. note::\n\n      You can get command usage on any Wic command using the following\n      form::\n\n              $ wic help command\n\n\n      For example, the following command shows you the various ways to\n      use the\n      wic ls\n      command::\n\n              $ wic help ls\n\n\n   The following command shows what is in partition one::\n\n        $ wic ls tmp/deploy/images/qemux86/core-image-minimal-qemux86.wic:1\n        Volume in drive : is boot\n         Volume Serial Number is E894-1809\n        Directory for ::/\n\n        libcom32 c32    186500 2017-10-09  16:06\n        libutil  c32     24148 2017-10-09  16:06\n        syslinux cfg       220 2017-10-09  16:06\n        vesamenu c32     27104 2017-10-09  16:06\n        vmlinuz        6904608 2017-10-09  16:06\n                5 files           7 142 580 bytes\n                                 16 582 656 bytes free\n\n   The previous output shows five files, with the\n   ``vmlinuz`` being the kernel.\n\n   .. note::\n\n      If you see the following error, you need to update or create a\n      ``~/.mtoolsrc`` file and be sure to have the line \"mtools_skip_check=1\"\n      in the file. Then, run the Wic command again::\n\n              ERROR: _exec_cmd: /usr/bin/mdir -i /tmp/wic-parttfokuwra ::/ returned '1' instead of 0\n               output: Total number of sectors (47824) not a multiple of sectors per track (32)!\n"}
{"text": "\n\nCreating Partitioned Images Using Wic\n               Add mtools_skip_check=1 to your .mtoolsrc file to skip this test\n\n\n#. *Remove the Old Kernel:* Use the ``wic rm`` command to remove the\n   ``vmlinuz`` file (kernel)::\n\n      $ wic rm tmp/deploy/images/qemux86/core-image-minimal-qemux86.wic:1/vmlinuz\n\n#. *Add In the New Kernel:* Use the ``wic cp`` command to add the\n   updated kernel to the Wic image. Depending on how you built your\n   kernel, it could be in different places. If you used ``devtool`` and\n   an SDK to build your kernel, it resides in the ``tmp/work`` directory\n   of the extensible SDK. If you used ``make`` to build the kernel, the\n   kernel will be in the ``workspace/sources`` area.\n\n   The following example assumes ``devtool`` was used to build the\n   kernel::\n\n      $ wic cp poky_sdk/tmp/work/qemux86-poky-linux/linux-yocto/4.12.12+git999-r0/linux-yocto-4.12.12+git999/arch/x86/boot/bzImage \\\n               poky/build/tmp/deploy/images/qemux86/core-image-minimal-qemux86.wic:1/vmlinuz\n\n   Once the new kernel is added back into the image, you can use the\n   ``dd`` command or :ref:`bmaptool\n   <dev-manual/bmaptool:flashing images using \\`\\`bmaptool\\`\\`>`\n   to flash your wic image onto an SD card or USB stick and test your\n   target.\n\n   .. note::\n\n      Using ``bmaptool`` is generally 10 to 20 times faster than using ``dd``.\n\n"}
{"text": "\n\nCreating a Custom Template Configuration Directory\n\n\nCreating a Custom Template Configuration Directory\n**************************************************\n\nIf you are producing your own customized version of the build system for\nuse by other users, you might want to provide a custom build configuration\nthat includes all the necessary settings and layers (i.e. ``local.conf`` and\n``bblayers.conf`` that are created in a new :term:`Build Directory`) and a custom\nmessage that is shown when setting up the build. This can be done by\ncreating one or more template configuration directories in your\ncustom distribution layer.\n\nThis can be done by using ``bitbake-layers save-build-conf``::\n\n   $ bitbake-layers save-build-conf ../../meta-alex/ test-1\n   NOTE: Starting bitbake server...\n   NOTE: Configuration template placed into /srv/work/alex/meta-alex/conf/templates/test-1\n   Please review the files in there, and particularly provide a configuration description in /srv/work/alex/meta-alex/conf/templates/test-1/conf-notes.txt\n   You can try out the configuration with\n   TEMPLATECONF=/srv/work/alex/meta-alex/conf/templates/test-1 . /srv/work/alex/poky/oe-init-build-env build-try-test-1\n\nThe above command takes the config files from the currently active :term:`Build Directory` under ``conf``,\nreplaces site-specific paths in ``bblayers.conf`` with ``##OECORE##``-relative paths, and copies\nthe config files into a specified layer under a specified template name.\n\nTo use those saved templates as a starting point for a build, users should point\nto one of them with :term:`TEMPLATECONF` environment variable::\n\n   TEMPLATECONF=/srv/work/alex/meta-alex/conf/templates/test-1 . /srv/work/alex/poky/oe-init-build-env build-try-test-1\n\nThe OpenEmbedded build system uses the environment variable\n:term:`TEMPLATECONF` to locate the directory from which it gathers\nconfiguration information that ultimately ends up in the\n:term:`Build Directory` ``conf`` directory.\n\nIf :term:`TEMPLATECONF` is not set, the default value is obtained\nfrom ``.templateconf`` file that is read from the same directory as\n``oe-init-build-env`` script. For the Poky reference distribution this\nwould be::\n\n   TEMPLATECONF=${TEMPLATECONF:-meta-poky/conf/templates/default}\n\nIf you look at a configuration template directory, you will\nsee the ``bblayers.conf.sample``, ``local.conf.sample``, and\n``conf-notes.txt`` files. The build system uses these files to form the\nrespective ``bblayers.conf`` file, ``local.conf`` file, and show\nusers a note about the build they're setting up\nwhen running the ``oe-init-build-env`` setup script. These can be\nedited further if needed to improve or change the build configurations\navailable to the users.\n\n"}
{"text": "\n\nUsing Quilt in Your Workflow\n\n\nUsing Quilt in Your Workflow\n****************************\n\n`Quilt <https://savannah.nongnu.org/projects/quilt>`__ is a powerful tool\nthat allows you to capture source code changes without having a clean\nsource tree. This section outlines the typical workflow you can use to\nmodify source code, test changes, and then preserve the changes in the\nform of a patch all using Quilt.\n\n.. note::\n\n   With regard to preserving changes to source files, if you clean a\n   recipe or have :ref:`ref-classes-rm-work` enabled, the\n   :ref:`devtool workflow <sdk-manual/extensible:using \\`\\`devtool\\`\\` in your sdk workflow>`\n   as described in the Yocto Project Application Development and the\n   Extensible Software Development Kit (eSDK) manual is a safer\n   development flow than the flow that uses Quilt.\n\nFollow these general steps:\n\n#. *Find the Source Code:* Temporary source code used by the\n   OpenEmbedded build system is kept in the :term:`Build Directory`. See the\n   \":ref:`dev-manual/temporary-source-code:finding temporary source code`\" section to\n   learn how to locate the directory that has the temporary source code for a\n   particular package.\n\n#. *Change Your Working Directory:* You need to be in the directory that\n   has the temporary source code. That directory is defined by the\n   :term:`S` variable.\n\n#. *Create a New Patch:* Before modifying source code, you need to\n   create a new patch. To create a new patch file, use ``quilt new`` as\n   below::\n\n      $ quilt new my_changes.patch\n\n#. *Notify Quilt and Add Files:* After creating the patch, you need to\n   notify Quilt about the files you plan to edit. You notify Quilt by\n   adding the files to the patch you just created::\n\n      $ quilt add file1.c file2.c file3.c\n\n#. *Edit the Files:* Make your changes in the source code to the files\n   you added to the patch.\n\n#. *Test Your Changes:* Once you have modified the source code, the\n   easiest way to test your changes is by calling the :ref:`ref-tasks-compile`\n   task as shown in the following example::\n\n      $ bitbake -c compile -f package\n\n   The ``-f`` or ``--force`` option forces the specified task to\n   execute. If you find problems with your code, you can just keep\n   editing and re-testing iteratively until things work as expected.\n\n   .. note::\n\n      All the modifications you make to the temporary source code disappear\n      once you run the :ref:`ref-tasks-clean` or :ref:`ref-tasks-cleanall`\n      tasks using BitBake (i.e. ``bitbake -c clean package`` and\n      ``bitbake -c cleanall package``). Modifications will also disappear if\n      you use the :ref:`ref-classes-rm-work` feature as described in\n      the \":ref:`dev-manual/disk-space:conserving disk space during builds`\"\n      section.\n\n#. *Generate the Patch:* Once your changes work as expected, you need to\n   use Quilt to generate the final patch that contains all your\n   modifications::\n\n      $ quilt refresh\n\n   At this point, the\n   ``my_changes.patch`` file has all your edits made to the ``file1.c``,\n   ``file2.c``, and ``file3.c`` files.\n\n   You can find the resulting patch file in the ``patches/``\n   subdirectory of the source (:term:`S`) directory.\n\n#. *Copy the Patch File:* For simplicity, copy the patch file into a\n   directory named ``files``, which you can create in the same directory\n   that holds the recipe (``.bb``) file or the append (``.bbappend``)\n   file. Placing the patch here guarantees that the OpenEmbedded build\n   system will find the patch. Next, add the patch into the :term:`SRC_URI`\n   of the recipe. Here is an example::\n\n      SRC_URI += \"file://my_changes.patch\"\n\n"}
{"text": "\n\nFlashing Images Using ``bmaptool``\n\n\nFlashing Images Using ``bmaptool``\n**********************************\n\nA fast and easy way to flash an image to a bootable device is to use\nBmaptool, which is integrated into the OpenEmbedded build system.\nBmaptool is a generic tool that creates a file's block map (bmap) and\nthen uses that map to copy the file. As compared to traditional tools\nsuch as dd or cp, Bmaptool can copy (or flash) large files like raw\nsystem image files much faster.\n\n.. note::\n\n   -  If you are using Ubuntu or Debian distributions, you can install\n      the ``bmap-tools`` package using the following command and then\n      use the tool without specifying ``PATH`` even from the root\n      account::\n\n         $ sudo apt install bmap-tools\n\n   -  If you are unable to install the ``bmap-tools`` package, you will\n      need to build Bmaptool before using it. Use the following command::\n\n         $ bitbake bmap-tools-native\n\nFollowing, is an example that shows how to flash a Wic image. Realize\nthat while this example uses a Wic image, you can use Bmaptool to flash\nany type of image. Use these steps to flash an image using Bmaptool:\n\n#. *Update your local.conf File:* You need to have the following set\n   in your ``local.conf`` file before building your image::\n\n      IMAGE_FSTYPES += \"wic wic.bmap\"\n\n#. *Get Your Image:* Either have your image ready (pre-built with the\n   :term:`IMAGE_FSTYPES`\n   setting previously mentioned) or take the step to build the image::\n\n      $ bitbake image\n\n#. *Flash the Device:* Flash the device with the image by using Bmaptool\n   depending on your particular setup. The following commands assume the\n   image resides in the :term:`Build Directory`'s ``deploy/images/`` area:\n\n   -  If you have write access to the media, use this command form::\n\n         $ oe-run-native bmap-tools-native bmaptool copy build-directory/tmp/deploy/images/machine/image.wic /dev/sdX\n\n   -  If you do not have write access to the media, set your permissions\n      first and then use the same command form::\n\n         $ sudo chmod 666 /dev/sdX\n         $ oe-run-native bmap-tools-native bmaptool copy build-directory/tmp/deploy/images/machine/image.wic /dev/sdX\n\nFor help on the ``bmaptool`` command, use the following command::\n\n   $ bmaptool --help\n\n"}
{"text": "\n\nWorking with Packages\n\n\nWorking with Packages\n*********************\n\nThis section describes a few tasks that involve packages:\n\n-  :ref:`dev-manual/packages:excluding packages from an image`\n\n-  :ref:`dev-manual/packages:incrementing a package version`\n\n-  :ref:`dev-manual/packages:handling optional module packaging`\n\n-  :ref:`dev-manual/packages:using runtime package management`\n\n-  :ref:`dev-manual/packages:generating and using signed packages`\n\n-  :ref:`Setting up and running package test\n   (ptest) <dev-manual/packages:testing packages with ptest>`\n\n-  :ref:`dev-manual/packages:creating node package manager (npm) packages`\n\n-  :ref:`dev-manual/packages:adding custom metadata to packages`\n\nExcluding Packages from an Image\n================================\n\nYou might find it necessary to prevent specific packages from being\ninstalled into an image. If so, you can use several variables to direct\nthe build system to essentially ignore installing recommended packages\nor to not install a package at all.\n\nThe following list introduces variables you can use to prevent packages\nfrom being installed into your image. Each of these variables only works\nwith IPK and RPM package types, not for Debian packages.\nAlso, you can use these variables from your ``local.conf`` file\nor attach them to a specific image recipe by using a recipe name\noverride. For more detail on the variables, see the descriptions in the\nYocto Project Reference Manual's glossary chapter.\n\n-  :term:`BAD_RECOMMENDATIONS`:\n   Use this variable to specify \"recommended-only\" packages that you do\n   not want installed.\n\n-  :term:`NO_RECOMMENDATIONS`:\n   Use this variable to prevent all \"recommended-only\" packages from\n   being installed.\n\n-  :term:`PACKAGE_EXCLUDE`:\n   Use this variable to prevent specific packages from being installed\n   regardless of whether they are \"recommended-only\" or not. You need to\n   realize that the build process could fail with an error when you\n   prevent the installation of a package whose presence is required by\n   an installed package.\n\nIncrementing a Package Version\n==============================\n\nThis section provides some background on how binary package versioning\nis accomplished and presents some of the services, variables, and\nterminology involved.\n\nIn order to understand binary package versioning, you need to consider\nthe following:\n\n-  Binary Package: The binary package that is eventually built and\n   installed into an image.\n\n-  Binary Package Version: The binary package version is composed of two\n   components --- a version and a revision.\n\n   .. note::\n\n      Technically, a third component, the \"epoch\" (i.e. :term:`PE`) is involved\n      but this discussion for the most part ignores :term:`PE`.\n\n   The version and revision are taken from the\n   :term:`PV` and\n   :term:`PR` variables, respectively.\n\n-  :term:`PV`: The recipe version. :term:`PV` represents the version of the\n   software being packaged. Do not confuse :term:`PV` with the binary\n   package version.\n\n-  :term:`PR`: The recipe revision.\n\n-  :term:`SRCPV`: The OpenEmbedded\n   build system uses this string to help define the value of :term:`PV` when\n   the source code revision needs to be included in it.\n\n-  :yocto_wiki:`PR Service </PR_Service>`: A\n   network-based service that helps automate keeping package feeds\n   compatible with existing package manager applications such as RPM,\n   APT, and OPKG.\n\nWhenever the binary package content changes, the binary package version\nmust change. Changing the binary package version is accomplished by\nchanging or \"bumping\" the :term:`PR` and/or :term:`PV` values. Increasing these\nvalues occurs one of two ways:\n\n"}
{"text": "\n\nWorking with Packages\n-  Automatically using a Package Revision Service (PR Service).\n\n-  Manually incrementing the :term:`PR` and/or :term:`PV` variables.\n\nGiven a primary challenge of any build system and its users is how to\nmaintain a package feed that is compatible with existing package manager\napplications such as RPM, APT, and OPKG, using an automated system is\nmuch preferred over a manual system. In either system, the main\nrequirement is that binary package version numbering increases in a\nlinear fashion and that there is a number of version components that\nsupport that linear progression. For information on how to ensure\npackage revisioning remains linear, see the\n\":ref:`dev-manual/packages:automatically incrementing a package version number`\"\nsection.\n\nThe following three sections provide related information on the PR\nService, the manual method for \"bumping\" :term:`PR` and/or :term:`PV`, and on\nhow to ensure binary package revisioning remains linear.\n\nWorking With a PR Service\n-------------------------\n\nAs mentioned, attempting to maintain revision numbers in the\n:term:`Metadata` is error prone, inaccurate,\nand causes problems for people submitting recipes. Conversely, the PR\nService automatically generates increasing numbers, particularly the\nrevision field, which removes the human element.\n\n.. note::\n\n   For additional information on using a PR Service, you can see the\n   :yocto_wiki:`PR Service </PR_Service>` wiki page.\n\nThe Yocto Project uses variables in order of decreasing priority to\nfacilitate revision numbering (i.e.\n:term:`PE`,\n:term:`PV`, and\n:term:`PR` for epoch, version, and\nrevision, respectively). The values are highly dependent on the policies\nand procedures of a given distribution and package feed.\n\nBecause the OpenEmbedded build system uses\n\":ref:`signatures <overview-manual/concepts:checksums (signatures)>`\", which are\nunique to a given build, the build system knows when to rebuild\npackages. All the inputs into a given task are represented by a\nsignature, which can trigger a rebuild when different. Thus, the build\nsystem itself does not rely on the :term:`PR`, :term:`PV`, and :term:`PE` numbers to\ntrigger a rebuild. The signatures, however, can be used to generate\nthese values.\n\nThe PR Service works with both ``OEBasic`` and ``OEBasicHash``\ngenerators. The value of :term:`PR` bumps when the checksum changes and the\ndifferent generator mechanisms change signatures under different\ncircumstances.\n\nAs implemented, the build system includes values from the PR Service\ninto the :term:`PR` field as an addition using the form \"``.x``\" so ``r0``\nbecomes ``r0.1``, ``r0.2`` and so forth. This scheme allows existing\n:term:`PR` values to be used for whatever reasons, which include manual\n:term:`PR` bumps, should it be necessary.\n\nBy default, the PR Service is not enabled or running. Thus, the packages\ngenerated are just \"self consistent\". The build system adds and removes\npackages and there are no guarantees about upgrade paths but images will\nbe consistent and correct with the latest changes.\n\nThe simplest form for a PR Service is for a single host development system\nthat builds the package feed (building system). For this scenario, you can\nenable a local PR Service by setting :term:`PRSERV_HOST` in your\n``local.conf`` file in the :term:`Build Directory`::\n\n   PRSERV_HOST = \"localhost:0\"\n\nOnce the service is started, packages will automatically\nget increasing :term:`PR` values and BitBake takes care of starting and\nstopping the server.\n\nIf you have a more complex setup where multiple host development systems\nwork against a common, shared package feed, you have a single PR Service\nrunning and it is connected to each building system. For this scenario,\nyou need to start the PR Service using the ``bitbake-prserv`` command::\n\n   bitbake-prserv --host ip --port port --start\n\nIn addition to\nhand-starting the service, you need to update the ``local.conf`` file of\neach building system as described earlier so each system points to the\nserver and port.\n\nIt is also recommended you use build history, which adds some sanity\nchecks to binary package versions, in conjunction with the server that\nis running the PR Service. To enable build history, add the following to\neach building system's ``local.conf`` file::\n\n   # It is recommended to activate \"buildhistory\" for testing the PR service\n   INHERIT += \"buildhistory\"\n   BUILDHISTORY_COMMIT = \"1\"\n\nFor information on build\nhistory, see the\n"}
{"text": "\n\nWorking with Packages\n\":ref:`dev-manual/build-quality:maintaining build output quality`\" section.\n\n.. note::\n\n   The OpenEmbedded build system does not maintain :term:`PR` information as\n   part of the shared state (sstate) packages. If you maintain an sstate\n   feed, it's expected that either all your building systems that\n   contribute to the sstate feed use a shared PR Service, or you do not\n   run a PR Service on any of your building systems. Having some systems\n   use a PR Service while others do not leads to obvious problems.\n\n   For more information on shared state, see the\n   \":ref:`overview-manual/concepts:shared state cache`\"\n   section in the Yocto Project Overview and Concepts Manual.\n\nManually Bumping PR\n-------------------\n\nThe alternative to setting up a PR Service is to manually \"bump\" the\n:term:`PR` variable.\n\nIf a committed change results in changing the package output, then the\nvalue of the :term:`PR` variable needs to be increased (or \"bumped\") as part of\nthat commit. For new recipes you should add the :term:`PR` variable and set\nits initial value equal to \"r0\", which is the default. Even though the\ndefault value is \"r0\", the practice of adding it to a new recipe makes\nit harder to forget to bump the variable when you make changes to the\nrecipe in future.\n\nUsually, version increases occur only to binary packages. However, if\nfor some reason :term:`PV` changes but does not increase, you can increase\nthe :term:`PE` variable (Package Epoch). The :term:`PE` variable defaults to\n\"0\".\n\nBinary package version numbering strives to follow the `Debian Version\nField Policy\nGuidelines <https://www.debian.org/doc/debian-policy/ch-controlfields.html>`__.\nThese guidelines define how versions are compared and what \"increasing\"\na version means.\n\nAutomatically Incrementing a Package Version Number\n---------------------------------------------------\n\nWhen fetching a repository, BitBake uses the\n:term:`SRCREV` variable to determine\nthe specific source code revision from which to build. You set the\n:term:`SRCREV` variable to\n:term:`AUTOREV` to cause the\nOpenEmbedded build system to automatically use the latest revision of\nthe software::\n\n   SRCREV = \"${AUTOREV}\"\n\nFurthermore, you need to reference :term:`SRCPV` in :term:`PV` in order to\nautomatically update the version whenever the revision of the source\ncode changes. Here is an example::\n\n   PV = \"1.0+git${SRCPV}\"\n\nThe OpenEmbedded build system substitutes :term:`SRCPV` with the following:\n\n.. code-block:: none\n\n   AUTOINC+source_code_revision\n\nThe build system replaces the ``AUTOINC``\nwith a number. The number used depends on the state of the PR Service:\n\n-  If PR Service is enabled, the build system increments the number,\n   which is similar to the behavior of\n   :term:`PR`. This behavior results in\n   linearly increasing package versions, which is desirable. Here is an\n   example:\n\n   .. code-block:: none\n\n      hello-world-git_0.0+git0+b6558dd387-r0.0_armv7a-neon.ipk\n      hello-world-git_0.0+git1+dd2f5c3565-r0.0_armv7a-neon.ipk\n\n-  If PR Service is not enabled, the build system replaces the\n   ``AUTOINC`` placeholder with zero (i.e. \"0\"). This results in\n   changing the package version since the source revision is included.\n   However, package versions are not increased linearly. Here is an\n   example:\n\n   .. code-block:: none\n\n      hello-world-git_0.0+git0+b6558dd387-r0.0_armv7a-neon.ipk\n      hello-world-git_0.0+git0+dd2f5c3565-r0.0_armv7a-neon.ipk\n\nIn summary, the OpenEmbedded build system does not track the history of\nbinary package versions for this purpose. ``AUTOINC``, in this case, is\ncomparable to :term:`PR`. If PR server is not enabled, ``AUTOINC`` in the\npackage version is simply replaced by \"0\". If PR server is enabled, the\nbuild system keeps track of the package versions and bumps the number\nwhen the package revision changes.\n\nHandling Optional Module Packaging\n==================================\n\n"}
{"text": "\n\nWorking with Packages\nMany pieces of software split functionality into optional modules (or\nplugins) and the plugins that are built might depend on configuration\noptions. To avoid having to duplicate the logic that determines what\nmodules are available in your recipe or to avoid having to package each\nmodule by hand, the OpenEmbedded build system provides functionality to\nhandle module packaging dynamically.\n\nTo handle optional module packaging, you need to do two things:\n\n-  Ensure the module packaging is actually done.\n\n-  Ensure that any dependencies on optional modules from other recipes\n   are satisfied by your recipe.\n\nMaking Sure the Packaging is Done\n---------------------------------\n\nTo ensure the module packaging actually gets done, you use the\n``do_split_packages`` function within the ``populate_packages`` Python\nfunction in your recipe. The ``do_split_packages`` function searches for\na pattern of files or directories under a specified path and creates a\npackage for each one it finds by appending to the\n:term:`PACKAGES` variable and\nsetting the appropriate values for ``FILES:packagename``,\n``RDEPENDS:packagename``, ``DESCRIPTION:packagename``, and so forth.\nHere is an example from the ``lighttpd`` recipe::\n\n   python populate_packages:prepend () {\n       lighttpd_libdir = d.expand('${libdir}')\n       do_split_packages(d, lighttpd_libdir, '^mod_(.*).so$',\n                        'lighttpd-module-%s', 'Lighttpd module for %s',\n                         extra_depends='')\n   }\n\nThe previous example specifies a number of things in the call to\n``do_split_packages``.\n\n-  A directory within the files installed by your recipe through\n   :ref:`ref-tasks-install` in which to search.\n\n-  A regular expression used to match module files in that directory. In\n   the example, note the parentheses () that mark the part of the\n   expression from which the module name should be derived.\n\n-  A pattern to use for the package names.\n\n-  A description for each package.\n\n-  An empty string for ``extra_depends``, which disables the default\n   dependency on the main ``lighttpd`` package. Thus, if a file in\n   ``${libdir}`` called ``mod_alias.so`` is found, a package called\n   ``lighttpd-module-alias`` is created for it and the\n   :term:`DESCRIPTION` is set to\n   \"Lighttpd module for alias\".\n\nOften, packaging modules is as simple as the previous example. However,\nthere are more advanced options that you can use within\n``do_split_packages`` to modify its behavior. And, if you need to, you\ncan add more logic by specifying a hook function that is called for each\npackage. It is also perfectly acceptable to call ``do_split_packages``\nmultiple times if you have more than one set of modules to package.\n\nFor more examples that show how to use ``do_split_packages``, see the\n``connman.inc`` file in the ``meta/recipes-connectivity/connman/``\ndirectory of the ``poky`` :ref:`source repository <overview-manual/development-environment:yocto project source repositories>`. You can\nalso find examples in ``meta/classes-recipe/kernel.bbclass``.\n\nFollowing is a reference that shows ``do_split_packages`` mandatory and\noptional arguments::\n\n   Mandatory arguments\n\n   root\n      The path in which to search\n   file_regex\n      Regular expression to match searched files.\n      Use parentheses () to mark the part of this\n      expression that should be used to derive the\n      module name (to be substituted where %s is\n      used in other function arguments as noted below)\n   output_pattern\n      Pattern to use for the package names. Must\n      include %s.\n   description\n      Description to set for each package. Must\n      include %s.\n\n   Optional arguments\n\n   postinst\n      Postinstall script to use for all packages\n      (as a string)\n   recursive\n      True to perform a recursive search --- default\n      False\n   hook\n      A hook function to be called for every match.\n      The function will be called with the following\n      arguments (in the order listed):\n\n"}
{"text": "\n\nWorking with Packages\n      f\n         Full path to the file/directory match\n      pkg\n         The package name\n      file_regex\n         As above\n      output_pattern\n         As above\n      modulename\n         The module name derived using file_regex\n   extra_depends\n      Extra runtime dependencies (RDEPENDS) to be\n      set for all packages. The default value of None\n      causes a dependency on the main package\n      (${PN}) --- if you do not want this, pass empty\n      string '' for this parameter.\n   aux_files_pattern\n      Extra item(s) to be added to FILES for each\n      package. Can be a single string item or a list\n      of strings for multiple items. Must include %s.\n   postrm\n      postrm script to use for all packages (as a\n      string)\n   allow_dirs\n      True to allow directories to be matched -\n      default False\n   prepend\n      If True, prepend created packages to PACKAGES\n      instead of the default False which appends them\n   match_path\n      match file_regex on the whole relative path to\n      the root rather than just the filename\n   aux_files_pattern_verbatim\n      Extra item(s) to be added to FILES for each\n      package, using the actual derived module name\n      rather than converting it to something legal\n      for a package name. Can be a single string item\n      or a list of strings for multiple items. Must\n      include %s.\n   allow_links\n      True to allow symlinks to be matched --- default\n      False\n   summary\n      Summary to set for each package. Must include %s;\n      defaults to description if not set.\n\n\n\nSatisfying Dependencies\n-----------------------\n\nThe second part for handling optional module packaging is to ensure that\nany dependencies on optional modules from other recipes are satisfied by\nyour recipe. You can be sure these dependencies are satisfied by using\nthe :term:`PACKAGES_DYNAMIC`\nvariable. Here is an example that continues with the ``lighttpd`` recipe\nshown earlier::\n\n   PACKAGES_DYNAMIC = \"lighttpd-module-.*\"\n\nThe name\nspecified in the regular expression can of course be anything. In this\nexample, it is ``lighttpd-module-`` and is specified as the prefix to\nensure that any :term:`RDEPENDS` and\n:term:`RRECOMMENDS` on a package\nname starting with the prefix are satisfied during build time. If you\nare using ``do_split_packages`` as described in the previous section,\nthe value you put in :term:`PACKAGES_DYNAMIC` should correspond to the name\npattern specified in the call to ``do_split_packages``.\n\nUsing Runtime Package Management\n================================\n\nDuring a build, BitBake always transforms a recipe into one or more\npackages. For example, BitBake takes the ``bash`` recipe and produces a\nnumber of packages (e.g. ``bash``, ``bash-bashbug``,\n``bash-completion``, ``bash-completion-dbg``, ``bash-completion-dev``,\n``bash-completion-extra``, ``bash-dbg``, and so forth). Not all\ngenerated packages are included in an image.\n\nIn several situations, you might need to update, add, remove, or query\nthe packages on a target device at runtime (i.e. without having to\ngenerate a new image). Examples of such situations include:\n\n-  You want to provide in-the-field updates to deployed devices (e.g.\n   security updates).\n\n-  You want to have a fast turn-around development cycle for one or more\n   applications that run on your device.\n\n-  You want to temporarily install the \"debug\" packages of various\n   applications on your device so that debugging can be greatly improved\n   by allowing access to symbols and source debugging.\n\n-  You want to deploy a more minimal package selection of your device\n   but allow in-the-field updates to add a larger selection for\n   customization.\n\nIn all these situations, you have something similar to a more\ntraditional Linux distribution in that in-field devices are able to\n"}
{"text": "\n\nWorking with Packages\nreceive pre-compiled packages from a server for installation or update.\nBeing able to install these packages on a running, in-field device is\nwhat is termed \"runtime package management\".\n\nIn order to use runtime package management, you need a host or server\nmachine that serves up the pre-compiled packages plus the required\nmetadata. You also need package manipulation tools on the target. The\nbuild machine is a likely candidate to act as the server. However, that\nmachine does not necessarily have to be the package server. The build\nmachine could push its artifacts to another machine that acts as the\nserver (e.g. Internet-facing). In fact, doing so is advantageous for a\nproduction environment as getting the packages away from the development\nsystem's :term:`Build Directory` prevents accidental overwrites.\n\nA simple build that targets just one device produces more than one\npackage database. In other words, the packages produced by a build are\nseparated out into a couple of different package groupings based on\ncriteria such as the target's CPU architecture, the target board, or the\nC library used on the target. For example, a build targeting the\n``qemux86`` device produces the following three package databases:\n``noarch``, ``i586``, and ``qemux86``. If you wanted your ``qemux86``\ndevice to be aware of all the packages that were available to it, you\nwould need to point it to each of these databases individually. In a\nsimilar way, a traditional Linux distribution usually is configured to\nbe aware of a number of software repositories from which it retrieves\npackages.\n\nUsing runtime package management is completely optional and not required\nfor a successful build or deployment in any way. But if you want to make\nuse of runtime package management, you need to do a couple things above\nand beyond the basics. The remainder of this section describes what you\nneed to do.\n\nBuild Considerations\n--------------------\n\nThis section describes build considerations of which you need to be\naware in order to provide support for runtime package management.\n\nWhen BitBake generates packages, it needs to know what format or formats\nto use. In your configuration, you use the\n:term:`PACKAGE_CLASSES`\nvariable to specify the format:\n\n#. Open the ``local.conf`` file inside your :term:`Build Directory` (e.g.\n   ``poky/build/conf/local.conf``).\n\n#. Select the desired package format as follows::\n\n      PACKAGE_CLASSES ?= \"package_packageformat\"\n\n   where packageformat can be \"ipk\", \"rpm\",\n   \"deb\", or \"tar\" which are the supported package formats.\n\n   .. note::\n\n      Because the Yocto Project supports four different package formats,\n      you can set the variable with more than one argument. However, the\n      OpenEmbedded build system only uses the first argument when\n      creating an image or Software Development Kit (SDK).\n\nIf you would like your image to start off with a basic package database\ncontaining the packages in your current build as well as to have the\nrelevant tools available on the target for runtime package management,\nyou can include \"package-management\" in the\n:term:`IMAGE_FEATURES`\nvariable. Including \"package-management\" in this configuration variable\nensures that when the image is assembled for your target, the image\nincludes the currently-known package databases as well as the\ntarget-specific tools required for runtime package management to be\nperformed on the target. However, this is not strictly necessary. You\ncould start your image off without any databases but only include the\nrequired on-target package tool(s). As an example, you could include\n\"opkg\" in your\n:term:`IMAGE_INSTALL` variable\nif you are using the IPK package format. You can then initialize your\ntarget's package database(s) later once your image is up and running.\n\nWhenever you perform any sort of build step that can potentially\ngenerate a package or modify existing package, it is always a good idea\nto re-generate the package index after the build by using the following\ncommand::\n\n   $ bitbake package-index\n\nIt might be tempting to build the\npackage and the package index at the same time with a command such as\nthe following::\n\n   $ bitbake some-package package-index\n\nDo not do this as\nBitBake does not schedule the package index for after the completion of\nthe package you are building. Consequently, you cannot be sure of the\npackage index including information for the package you just built.\nThus, be sure to run the package update step separately after building\nany packages.\n\nYou can use the\n:term:`PACKAGE_FEED_ARCHS`,\n"}
{"text": "\n\nWorking with Packages\n:term:`PACKAGE_FEED_BASE_PATHS`,\nand\n:term:`PACKAGE_FEED_URIS`\nvariables to pre-configure target images to use a package feed. If you\ndo not define these variables, then manual steps as described in the\nsubsequent sections are necessary to configure the target. You should\nset these variables before building the image in order to produce a\ncorrectly configured image.\n\nWhen your build is complete, your packages reside in the\n``${TMPDIR}/deploy/packageformat`` directory. For example, if\n``${``\\ :term:`TMPDIR`\\ ``}`` is\n``tmp`` and your selected package type is RPM, then your RPM packages\nare available in ``tmp/deploy/rpm``.\n\nHost or Server Machine Setup\n----------------------------\n\nAlthough other protocols are possible, a server using HTTP typically\nserves packages. If you want to use HTTP, then set up and configure a\nweb server such as Apache 2, lighttpd, or Python web server on the\nmachine serving the packages.\n\nTo keep things simple, this section describes how to set up a\nPython web server to share package feeds from the developer's\nmachine. Although this server might not be the best for a production\nenvironment, the setup is simple and straight forward. Should you want\nto use a different server more suited for production (e.g. Apache 2,\nLighttpd, or Nginx), take the appropriate steps to do so.\n\nFrom within the :term:`Build Directory` where you have built an image based on\nyour packaging choice (i.e. the :term:`PACKAGE_CLASSES` setting), simply start\nthe server. The following example assumes a :term:`Build Directory` of ``poky/build``\nand a :term:`PACKAGE_CLASSES` setting of \":ref:`ref-classes-package_rpm`\"::\n\n   $ cd poky/build/tmp/deploy/rpm\n   $ python3 -m http.server\n\nTarget Setup\n------------\n\nSetting up the target differs depending on the package management\nsystem. This section provides information for RPM, IPK, and DEB.\n\nUsing RPM\n~~~~~~~~~\n\nThe :wikipedia:`Dandified Packaging <DNF_(software)>` (DNF) performs\nruntime package management of RPM packages. In order to use DNF for\nruntime package management, you must perform an initial setup on the\ntarget machine for cases where the ``PACKAGE_FEED_*`` variables were not\nset as part of the image that is running on the target. This means if\nyou built your image and did not use these variables as part of the\nbuild and your image is now running on the target, you need to perform\nthe steps in this section if you want to use runtime package management.\n\n.. note::\n\n   For information on the ``PACKAGE_FEED_*`` variables, see\n   :term:`PACKAGE_FEED_ARCHS`, :term:`PACKAGE_FEED_BASE_PATHS`, and\n   :term:`PACKAGE_FEED_URIS` in the Yocto Project Reference Manual variables\n   glossary.\n\nOn the target, you must inform DNF that package databases are available.\nYou do this by creating a file named\n``/etc/yum.repos.d/oe-packages.repo`` and defining the ``oe-packages``.\n\nAs an example, assume the target is able to use the following package\ndatabases: ``all``, ``i586``, and ``qemux86`` from a server named\n``my.server``. The specifics for setting up the web server are up to\nyou. The critical requirement is that the URIs in the target repository\nconfiguration point to the correct remote location for the feeds.\n\n.. note::\n\n   For development purposes, you can point the web server to the build\n   system's ``deploy`` directory. However, for production use, it is better to\n   copy the package directories to a location outside of the build area and use\n   that location. Doing so avoids situations where the build system\n   overwrites or changes the ``deploy`` directory.\n\nWhen telling DNF where to look for the package databases, you must\ndeclare individual locations per architecture or a single location used\nfor all architectures. You cannot do both:\n\n-  *Create an Explicit List of Architectures:* Define individual base\n   URLs to identify where each package database is located:\n\n   .. code-block:: none\n\n      [oe-packages]\n      baseurl=http://my.server/rpm/i586  http://my.server/rpm/qemux86 http://my.server/rpm/all\n\n   This example\n   informs DNF about individual package databases for all three\n   architectures.\n\n-  *Create a Single (Full) Package Index:* Define a single base URL that\n   identifies where a full package database is located::\n\n"}
{"text": "\n\nWorking with Packages\n      [oe-packages]\n      baseurl=http://my.server/rpm\n\n   This example informs DNF about a single\n   package database that contains all the package index information for\n   all supported architectures.\n\nOnce you have informed DNF where to find the package databases, you need\nto fetch them:\n\n.. code-block:: none\n\n   # dnf makecache\n\nDNF is now able to find, install, and\nupgrade packages from the specified repository or repositories.\n\n.. note::\n\n   See the `DNF documentation <https://dnf.readthedocs.io/en/latest/>`__ for\n   additional information.\n\nUsing IPK\n~~~~~~~~~\n\nThe ``opkg`` application performs runtime package management of IPK\npackages. You must perform an initial setup for ``opkg`` on the target\nmachine if the\n:term:`PACKAGE_FEED_ARCHS`,\n:term:`PACKAGE_FEED_BASE_PATHS`,\nand\n:term:`PACKAGE_FEED_URIS`\nvariables have not been set or the target image was built before the\nvariables were set.\n\nThe ``opkg`` application uses configuration files to find available\npackage databases. Thus, you need to create a configuration file inside\nthe ``/etc/opkg/`` directory, which informs ``opkg`` of any repository\nyou want to use.\n\nAs an example, suppose you are serving packages from a ``ipk/``\ndirectory containing the ``i586``, ``all``, and ``qemux86`` databases\nthrough an HTTP server named ``my.server``. On the target, create a\nconfiguration file (e.g. ``my_repo.conf``) inside the ``/etc/opkg/``\ndirectory containing the following:\n\n.. code-block:: none\n\n   src/gz all http://my.server/ipk/all\n   src/gz i586 http://my.server/ipk/i586\n   src/gz qemux86 http://my.server/ipk/qemux86\n\nNext, instruct ``opkg`` to fetch the\nrepository information:\n\n.. code-block:: none\n\n   # opkg update\n\nThe ``opkg`` application is now able to find, install, and upgrade packages\nfrom the specified repository.\n\nUsing DEB\n~~~~~~~~~\n\nThe ``apt`` application performs runtime package management of DEB\npackages. This application uses a source list file to find available\npackage databases. You must perform an initial setup for ``apt`` on the\ntarget machine if the\n:term:`PACKAGE_FEED_ARCHS`,\n:term:`PACKAGE_FEED_BASE_PATHS`,\nand\n:term:`PACKAGE_FEED_URIS`\nvariables have not been set or the target image was built before the\nvariables were set.\n\nTo inform ``apt`` of the repository you want to use, you might create a\nlist file (e.g. ``my_repo.list``) inside the\n``/etc/apt/sources.list.d/`` directory. As an example, suppose you are\nserving packages from a ``deb/`` directory containing the ``i586``,\n``all``, and ``qemux86`` databases through an HTTP server named\n``my.server``. The list file should contain:\n\n.. code-block:: none\n\n   deb http://my.server/deb/all ./\n   deb http://my.server/deb/i586 ./\n   deb http://my.server/deb/qemux86 ./\n\nNext, instruct the ``apt`` application\nto fetch the repository information:\n\n.. code-block:: none\n\n  $ sudo apt update\n\nAfter this step,\n``apt`` is able to find, install, and upgrade packages from the\nspecified repository.\n\n"}
{"text": "\n\nWorking with Packages\nGenerating and Using Signed Packages\n====================================\n\nIn order to add security to RPM packages used during a build, you can\ntake steps to securely sign them. Once a signature is verified, the\nOpenEmbedded build system can use the package in the build. If security\nfails for a signed package, the build system stops the build.\n\nThis section describes how to sign RPM packages during a build and how\nto use signed package feeds (repositories) when doing a build.\n\nSigning RPM Packages\n--------------------\n\nTo enable signing RPM packages, you must set up the following\nconfigurations in either your ``local.config`` or ``distro.config``\nfile::\n\n   # Inherit sign_rpm.bbclass to enable signing functionality\n   INHERIT += \" sign_rpm\"\n   # Define the GPG key that will be used for signing.\n   RPM_GPG_NAME = \"key_name\"\n   # Provide passphrase for the key\n   RPM_GPG_PASSPHRASE = \"passphrase\"\n\n.. note::\n\n   Be sure to supply appropriate values for both `key_name` and\n   `passphrase`.\n\nAside from the ``RPM_GPG_NAME`` and ``RPM_GPG_PASSPHRASE`` variables in\nthe previous example, two optional variables related to signing are available:\n\n-  *GPG_BIN:* Specifies a ``gpg`` binary/wrapper that is executed\n   when the package is signed.\n\n-  *GPG_PATH:* Specifies the ``gpg`` home directory used when the\n   package is signed.\n\nProcessing Package Feeds\n------------------------\n\nIn addition to being able to sign RPM packages, you can also enable\nsigned package feeds for IPK and RPM packages.\n\nThe steps you need to take to enable signed package feed use are similar\nto the steps used to sign RPM packages. You must define the following in\nyour ``local.config`` or ``distro.config`` file::\n\n   INHERIT += \"sign_package_feed\"\n   PACKAGE_FEED_GPG_NAME = \"key_name\"\n   PACKAGE_FEED_GPG_PASSPHRASE_FILE = \"path_to_file_containing_passphrase\"\n\nFor signed package feeds, the passphrase must be specified in a separate file,\nwhich is pointed to by the ``PACKAGE_FEED_GPG_PASSPHRASE_FILE``\nvariable. Regarding security, keeping a plain text passphrase out of the\nconfiguration is more secure.\n\nAside from the ``PACKAGE_FEED_GPG_NAME`` and\n``PACKAGE_FEED_GPG_PASSPHRASE_FILE`` variables, three optional variables\nrelated to signed package feeds are available:\n\n-  *GPG_BIN* Specifies a ``gpg`` binary/wrapper that is executed\n   when the package is signed.\n\n-  *GPG_PATH:* Specifies the ``gpg`` home directory used when the\n   package is signed.\n\n-  *PACKAGE_FEED_GPG_SIGNATURE_TYPE:* Specifies the type of ``gpg``\n   signature. This variable applies only to RPM and IPK package feeds.\n   Allowable values for the ``PACKAGE_FEED_GPG_SIGNATURE_TYPE`` are\n   \"ASC\", which is the default and specifies ascii armored, and \"BIN\",\n   which specifies binary.\n\nTesting Packages With ptest\n===========================\n\nA Package Test (ptest) runs tests against packages built by the\nOpenEmbedded build system on the target machine. A ptest contains at\nleast two items: the actual test, and a shell script (``run-ptest``)\nthat starts the test. The shell script that starts the test must not\ncontain the actual test --- the script only starts the test. On the other\nhand, the test can be anything from a simple shell script that runs a\nbinary and checks the output to an elaborate system of test binaries and\ndata files.\n\nThe test generates output in the format used by Automake::\n\n   result: testname\n\nwhere the result can be ``PASS``, ``FAIL``, or ``SKIP``, and\nthe testname can be any identifying string.\n\nFor a list of Yocto Project recipes that are already enabled with ptest,\nsee the :yocto_wiki:`Ptest </Ptest>` wiki page.\n\n.. note::\n\n   A recipe is \"ptest-enabled\" if it inherits the :ref:`ref-classes-ptest`\n   class.\n"}
{"text": "\n\nWorking with Packages\n\nAdding ptest to Your Build\n--------------------------\n\nTo add package testing to your build, add the :term:`DISTRO_FEATURES` and\n:term:`EXTRA_IMAGE_FEATURES` variables to your ``local.conf`` file, which\nis found in the :term:`Build Directory`::\n\n   DISTRO_FEATURES:append = \" ptest\"\n   EXTRA_IMAGE_FEATURES += \"ptest-pkgs\"\n\nOnce your build is complete, the ptest files are installed into the\n``/usr/lib/package/ptest`` directory within the image, where ``package``\nis the name of the package.\n\nRunning ptest\n-------------\n\nThe ``ptest-runner`` package installs a shell script that loops through\nall installed ptest test suites and runs them in sequence. Consequently,\nyou might want to add this package to your image.\n\nGetting Your Package Ready\n--------------------------\n\nIn order to enable a recipe to run installed ptests on target hardware,\nyou need to prepare the recipes that build the packages you want to\ntest. Here is what you have to do for each recipe:\n\n-  *Be sure the recipe inherits the* :ref:`ref-classes-ptest` *class:*\n   Include the following line in each recipe::\n\n      inherit ptest\n\n-  *Create run-ptest:* This script starts your test. Locate the\n   script where you will refer to it using\n   :term:`SRC_URI`. Here is an\n   example that starts a test for ``dbus``::\n\n      #!/bin/sh\n      cd test\n      make -k runtest-TESTS\n\n-  *Ensure dependencies are met:* If the test adds build or runtime\n   dependencies that normally do not exist for the package (such as\n   requiring \"make\" to run the test suite), use the\n   :term:`DEPENDS` and\n   :term:`RDEPENDS` variables in\n   your recipe in order for the package to meet the dependencies. Here\n   is an example where the package has a runtime dependency on \"make\"::\n\n      RDEPENDS:${PN}-ptest += \"make\"\n\n-  *Add a function to build the test suite:* Not many packages support\n   cross-compilation of their test suites. Consequently, you usually\n   need to add a cross-compilation function to the package.\n\n   Many packages based on Automake compile and run the test suite by\n   using a single command such as ``make check``. However, the host\n   ``make check`` builds and runs on the same computer, while\n   cross-compiling requires that the package is built on the host but\n   executed for the target architecture (though often, as in the case\n   for ptest, the execution occurs on the host). The built version of\n   Automake that ships with the Yocto Project includes a patch that\n   separates building and execution. Consequently, packages that use the\n   unaltered, patched version of ``make check`` automatically\n   cross-compiles.\n\n   Regardless, you still must add a ``do_compile_ptest`` function to\n   build the test suite. Add a function similar to the following to your\n   recipe::\n\n      do_compile_ptest() {\n          oe_runmake buildtest-TESTS\n      }\n\n-  *Ensure special configurations are set:* If the package requires\n   special configurations prior to compiling the test code, you must\n   insert a ``do_configure_ptest`` function into the recipe.\n\n-  *Install the test suite:* The :ref:`ref-classes-ptest` class\n   automatically copies the file ``run-ptest`` to the target and then runs make\n   ``install-ptest`` to run the tests. If this is not enough, you need\n   to create a ``do_install_ptest`` function and make sure it gets\n   called after the \"make install-ptest\" completes.\n\nCreating Node Package Manager (NPM) Packages\n============================================\n\n:wikipedia:`NPM <Npm_(software)>` is a package manager for the JavaScript\nprogramming language. The Yocto Project supports the NPM\n:ref:`fetcher <bitbake-user-manual/bitbake-user-manual-fetching:fetchers>`.\nYou can use this fetcher in combination with\n:doc:`devtool </ref-manual/devtool-reference>` to create recipes that produce\nNPM packages.\n\nThere are two workflows that allow you to create NPM packages using\n``devtool``: the NPM registry modules method and the NPM project code\nmethod.\n\n"}
{"text": "\n\nWorking with Packages\n.. note::\n\n   While it is possible to create NPM recipes manually, using\n   ``devtool`` is far simpler.\n\nAdditionally, some requirements and caveats exist.\n\nRequirements and Caveats\n------------------------\n\nYou need to be aware of the following before using ``devtool`` to create\nNPM packages:\n\n-  Of the two methods that you can use ``devtool`` to create NPM\n   packages, the registry approach is slightly simpler. However, you\n   might consider the project approach because you do not have to\n   publish your module in the `NPM registry <https://docs.npmjs.com/misc/registry>`__,\n   which is NPM's public registry.\n\n-  Be familiar with\n   :doc:`devtool </ref-manual/devtool-reference>`.\n\n-  The NPM host tools need the native ``nodejs-npm`` package, which is\n   part of the OpenEmbedded environment. You need to get the package by\n   cloning the :oe_git:`meta-openembedded </meta-openembedded>`\n   repository. Be sure to add the path to your local copy\n   to your ``bblayers.conf`` file.\n\n-  ``devtool`` cannot detect native libraries in module dependencies.\n   Consequently, you must manually add packages to your recipe.\n\n-  While deploying NPM packages, ``devtool`` cannot determine which\n   dependent packages are missing on the target (e.g. the node runtime\n   ``nodejs``). Consequently, you need to find out what files are\n   missing and be sure they are on the target.\n\n-  Although you might not need NPM to run your node package, it is\n   useful to have NPM on your target. The NPM package name is\n   ``nodejs-npm``.\n\nUsing the Registry Modules Method\n---------------------------------\n\nThis section presents an example that uses the ``cute-files`` module,\nwhich is a file browser web application.\n\n.. note::\n\n   You must know the ``cute-files`` module version.\n\nThe first thing you need to do is use ``devtool`` and the NPM fetcher to\ncreate the recipe::\n\n   $ devtool add \"npm://registry.npmjs.org;package=cute-files;version=1.0.2\"\n\nThe\n``devtool add`` command runs ``recipetool create`` and uses the same\nfetch URI to download each dependency and capture license details where\npossible. The result is a generated recipe.\n\nAfter running for quite a long time, in particular building the\n``nodejs-native`` package, the command should end as follows::\n\n   INFO: Recipe /home/.../build/workspace/recipes/cute-files/cute-files_1.0.2.bb has been automatically created; further editing may be required to make it fully functional\n\nThe recipe file is fairly simple and contains every license that\n``recipetool`` finds and includes the licenses in the recipe's\n:term:`LIC_FILES_CHKSUM`\nvariables. You need to examine the variables and look for those with\n\"unknown\" in the :term:`LICENSE`\nfield. You need to track down the license information for \"unknown\"\nmodules and manually add the information to the recipe.\n\n``recipetool`` creates a \"shrinkwrap\" file for your recipe. Shrinkwrap\nfiles capture the version of all dependent modules. Many packages do not\nprovide shrinkwrap files but ``recipetool`` will create a shrinkwrap file as it\nruns.\n\n.. note::\n\n   A package is created for each sub-module. This policy is the only\n   practical way to have the licenses for all of the dependencies\n   represented in the license manifest of the image.\n\nThe ``devtool edit-recipe`` command lets you take a look at the recipe::\n\n   $ devtool edit-recipe cute-files\n   # Recipe created by recipetool\n   # This is the basis of a recipe and may need further editing in order to be fully functional.\n   # (Feel free to remove these comments when editing.)\n\n   SUMMARY = \"Turn any folder on your computer into a cute file browser, available on the local network.\"\n   # WARNING: the following LICENSE and LIC_FILES_CHKSUM values are best guesses - it is\n   # your responsibility to verify that the values are complete and correct.\n   #\n   # NOTE: multiple licenses have been detected; they have been separated with &\n   # in the LICENSE value for now since it is a reasonable assumption that all\n   # of the licenses apply. If instead there is a choice between the multiple\n   # licenses then you should change the value to separate the licenses with |\n   # instead of &. If there is any doubt, check the accompanying documentation\n"}
{"text": "\n\nWorking with Packages\n   # to determine which situation is applicable.\n\n   SUMMARY = \"Turn any folder on your computer into a cute file browser, available on the local network.\"\n   LICENSE = \"BSD-3-Clause & ISC & MIT\"\n   LIC_FILES_CHKSUM = \"file://LICENSE;md5=71d98c0a1db42956787b1909c74a86ca \\\n                       file://node_modules/accepts/LICENSE;md5=bf1f9ad1e2e1d507aef4883fff7103de \\\n                       file://node_modules/array-flatten/LICENSE;md5=44088ba57cb871a58add36ce51b8de08 \\\n   ...\n                       file://node_modules/cookie-signature/Readme.md;md5=57ae8b42de3dd0c1f22d5f4cf191e15a\"\n\n   SRC_URI = \" \\\n       npm://registry.npmjs.org/;package=cute-files;version=${PV} \\\n       npmsw://${THISDIR}/${BPN}/npm-shrinkwrap.json \\\n       \"\n\n   S = \"${WORKDIR}/npm\"\n\n   inherit npm\n\n   LICENSE:${PN} = \"MIT\"\n   LICENSE:${PN}-accepts = \"MIT\"\n   LICENSE:${PN}-array-flatten = \"MIT\"\n   ...\n   LICENSE:${PN}-vary = \"MIT\"\n\nHere are three key points in the previous example:\n\n-  :term:`SRC_URI` uses the NPM\n   scheme so that the NPM fetcher is used.\n\n-  ``recipetool`` collects all the license information. If a\n   sub-module's license is unavailable, the sub-module's name appears in\n   the comments.\n\n-  The ``inherit npm`` statement causes the :ref:`ref-classes-npm` class to\n   package up all the modules.\n\nYou can run the following command to build the ``cute-files`` package::\n\n   $ devtool build cute-files\n\nRemember that ``nodejs`` must be installed on\nthe target before your package.\n\nAssuming 192.168.7.2 for the target's IP address, use the following\ncommand to deploy your package::\n\n   $ devtool deploy-target -s cute-files root@192.168.7.2\n\nOnce the package is installed on the target, you can\ntest the application to show the contents of any directory::\n\n  $ cd /usr/lib/node_modules/cute-files\n  $ cute-files\n\nOn a browser,\ngo to ``http://192.168.7.2:3000`` and you see the following:\n\n.. image:: figures/cute-files-npm-example.png\n   :width: 100%\n\nYou can find the recipe in ``workspace/recipes/cute-files``. You can use\nthe recipe in any layer you choose.\n\nUsing the NPM Projects Code Method\n----------------------------------\n\nAlthough it is useful to package modules already in the NPM registry,\nadding ``node.js`` projects under development is a more common developer\nuse case.\n\nThis section covers the NPM projects code method, which is very similar\nto the \"registry\" approach described in the previous section. In the NPM\nprojects method, you provide ``devtool`` with an URL that points to the\nsource files.\n\nReplicating the same example, (i.e. ``cute-files``) use the following\ncommand::\n\n   $ devtool add https://github.com/martinaglv/cute-files.git\n\nThe recipe this command generates is very similar to the recipe created in\nthe previous section. However, the :term:`SRC_URI` looks like the following::\n\n   SRC_URI = \" \\\n       git://github.com/martinaglv/cute-files.git;protocol=https;branch=master \\\n       npmsw://${THISDIR}/${BPN}/npm-shrinkwrap.json \\\n       \"\n\nIn this example,\nthe main module is taken from the Git repository and dependencies are\ntaken from the NPM registry. Other than those differences, the recipe is\nbasically the same between the two methods. You can build and deploy the\npackage exactly as described in the previous section that uses the\nregistry modules method.\n\nAdding custom metadata to packages\n==================================\n\nThe variable\n"}
{"text": "\n\nWorking with Packages\n:term:`PACKAGE_ADD_METADATA`\ncan be used to add additional metadata to packages. This is reflected in\nthe package control/spec file. To take the ipk format for example, the\nCONTROL file stored inside would contain the additional metadata as\nadditional lines.\n\nThe variable can be used in multiple ways, including using suffixes to\nset it for a specific package type and/or package. Note that the order\nof precedence is the same as this list:\n\n-  ``PACKAGE_ADD_METADATA_<PKGTYPE>:<PN>``\n\n-  ``PACKAGE_ADD_METADATA_<PKGTYPE>``\n\n-  ``PACKAGE_ADD_METADATA:<PN>``\n\n-  :term:`PACKAGE_ADD_METADATA`\n\n`<PKGTYPE>` is a parameter and expected to be a distinct name of specific\npackage type:\n\n-  IPK for .ipk packages\n\n-  DEB for .deb packages\n\n-  RPM for .rpm packages\n\n`<PN>` is a parameter and expected to be a package name.\n\nThe variable can contain multiple [one-line] metadata fields separated\nby the literal sequence '\\\\n'. The separator can be redefined using the\nvariable flag ``separator``.\n\nHere is an example that adds two custom fields for ipk\npackages::\n\n   PACKAGE_ADD_METADATA_IPK = \"Vendor: CustomIpk\\nGroup:Applications/Spreadsheets\"\n\n"}
{"text": "\n\nBuilding\n\n\nBuilding\n********\n\nThis section describes various build procedures, such as the steps\nneeded for a simple build, building a target for multiple configurations,\ngenerating an image for more than one machine, and so forth.\n\nBuilding a Simple Image\n=======================\n\nIn the development environment, you need to build an image whenever you\nchange hardware support, add or change system libraries, or add or\nchange services that have dependencies. There are several methods that allow\nyou to build an image within the Yocto Project. This section presents\nthe basic steps you need to build a simple image using BitBake from a\nbuild host running Linux.\n\n.. note::\n\n   -  For information on how to build an image using\n      :term:`Toaster`, see the\n      :doc:`/toaster-manual/index`.\n\n   -  For information on how to use ``devtool`` to build images, see the\n      \":ref:`sdk-manual/extensible:using \\`\\`devtool\\`\\` in your sdk workflow`\"\n      section in the Yocto Project Application Development and the\n      Extensible Software Development Kit (eSDK) manual.\n\n   -  For a quick example on how to build an image using the\n      OpenEmbedded build system, see the\n      :doc:`/brief-yoctoprojectqs/index` document.\n\n   -  You can also use the `Yocto Project BitBake\n      <https://marketplace.visualstudio.com/items?itemName=yocto-project.yocto-bitbake>`__\n      extension for Visual Studio Code to build images.\n\nThe build process creates an entire Linux distribution from source and\nplaces it in your :term:`Build Directory` under ``tmp/deploy/images``. For\ndetailed information on the build process using BitBake, see the\n\":ref:`overview-manual/concepts:images`\" section in the Yocto Project Overview\nand Concepts Manual.\n\nThe following figure and list overviews the build process:\n\n.. image:: figures/bitbake-build-flow.png\n   :width: 100%\n\n#. *Set up Your Host Development System to Support Development Using the\n   Yocto Project*: See the \":doc:`start`\" section for options on how to get a\n   build host ready to use the Yocto Project.\n\n#. *Initialize the Build Environment:* Initialize the build environment\n   by sourcing the build environment script (i.e.\n   :ref:`structure-core-script`)::\n\n      $ source oe-init-build-env [build_dir]\n\n   When you use the initialization script, the OpenEmbedded build system\n   uses ``build`` as the default :term:`Build Directory` in your current work\n   directory. You can use a `build_dir` argument with the script to\n   specify a different :term:`Build Directory`.\n\n   .. note::\n\n      A common practice is to use a different :term:`Build Directory` for\n      different targets; for example, ``~/build/x86`` for a ``qemux86``\n      target, and ``~/build/arm`` for a ``qemuarm`` target. In any\n      event, it's typically cleaner to locate the :term:`Build Directory`\n      somewhere outside of your source directory.\n\n#. *Make Sure Your* ``local.conf`` *File is Correct*: Ensure the\n   ``conf/local.conf`` configuration file, which is found in the\n   :term:`Build Directory`, is set up how you want it. This file defines many\n   aspects of the build environment including the target machine architecture\n   through the :term:`MACHINE` variable, the packaging format used during\n   the build (:term:`PACKAGE_CLASSES`), and a centralized tarball download\n   directory through the :term:`DL_DIR` variable.\n\n#. *Build the Image:* Build the image using the ``bitbake`` command::\n\n      $ bitbake target\n\n   .. note::\n\n      For information on BitBake, see the :doc:`bitbake:index`.\n\n   The target is the name of the recipe you want to build. Common\n   targets are the images in ``meta/recipes-core/images``,\n   ``meta/recipes-sato/images``, and so forth all found in the\n   :term:`Source Directory`. Alternatively, the target\n   can be the name of a recipe for a specific piece of software such as\n   BusyBox. For more details about the images the OpenEmbedded build\n   system supports, see the\n   \":ref:`ref-manual/images:Images`\" chapter in the Yocto\n   Project Reference Manual.\n\n   As an example, the following command builds the\n   ``core-image-minimal`` image::\n"}
{"text": "\n\nBuilding\n\n      $ bitbake core-image-minimal\n\n   Once an\n   image has been built, it often needs to be installed. The images and\n   kernels built by the OpenEmbedded build system are placed in the\n   :term:`Build Directory` in ``tmp/deploy/images``. For information on how to\n   run pre-built images such as ``qemux86`` and ``qemuarm``, see the\n   :doc:`/sdk-manual/index` manual. For\n   information about how to install these images, see the documentation\n   for your particular board or machine.\n\nBuilding Images for Multiple Targets Using Multiple Configurations\n==================================================================\n\nYou can use a single ``bitbake`` command to build multiple images or\npackages for different targets where each image or package requires a\ndifferent configuration (multiple configuration builds). The builds, in\nthis scenario, are sometimes referred to as \"multiconfigs\", and this\nsection uses that term throughout.\n\nThis section describes how to set up for multiple configuration builds\nand how to account for cross-build dependencies between the\nmulticonfigs.\n\nSetting Up and Running a Multiple Configuration Build\n-----------------------------------------------------\n\nTo accomplish a multiple configuration build, you must define each\ntarget's configuration separately using a parallel configuration file in\nthe :term:`Build Directory` or configuration directory within a layer, and you\nmust follow a required file hierarchy. Additionally, you must enable the\nmultiple configuration builds in your ``local.conf`` file.\n\nFollow these steps to set up and execute multiple configuration builds:\n\n-  *Create Separate Configuration Files*: You need to create a single\n   configuration file for each build target (each multiconfig).\n   The configuration definitions are implementation dependent but often\n   each configuration file will define the machine and the\n   temporary directory BitBake uses for the build. Whether the same\n   temporary directory (:term:`TMPDIR`) can be shared will depend on what is\n   similar and what is different between the configurations. Multiple MACHINE\n   targets can share the same (:term:`TMPDIR`) as long as the rest of the\n   configuration is the same, multiple :term:`DISTRO` settings would need separate\n   (:term:`TMPDIR`) directories.\n\n   For example, consider a scenario with two different multiconfigs for the same\n   :term:`MACHINE`: \"qemux86\" built\n   for two distributions such as \"poky\" and \"poky-lsb\". In this case,\n   you would need to use the different :term:`TMPDIR`.\n\n   Here is an example showing the minimal statements needed in a\n   configuration file for a \"qemux86\" target whose temporary build\n   directory is ``tmpmultix86``::\n\n      MACHINE = \"qemux86\"\n      TMPDIR = \"${TOPDIR}/tmpmultix86\"\n\n   The location for these multiconfig configuration files is specific.\n   They must reside in the current :term:`Build Directory` in a sub-directory of\n   ``conf`` named ``multiconfig`` or within a layer's ``conf`` directory\n   under a directory named ``multiconfig``. Following is an example that defines\n   two configuration files for the \"x86\" and \"arm\" multiconfigs:\n\n   .. image:: figures/multiconfig_files.png\n      :align: center\n      :width: 50%\n\n   The usual :term:`BBPATH` search path is used to locate multiconfig files in\n   a similar way to other conf files.\n\n-  *Add the BitBake Multi-configuration Variable to the Local\n   Configuration File*: Use the\n   :term:`BBMULTICONFIG`\n   variable in your ``conf/local.conf`` configuration file to specify\n   each multiconfig. Continuing with the example from the previous\n   figure, the :term:`BBMULTICONFIG` variable needs to enable two\n   multiconfigs: \"x86\" and \"arm\" by specifying each configuration file::\n\n      BBMULTICONFIG = \"x86 arm\"\n\n   .. note::\n\n      A \"default\" configuration already exists by definition. This\n      configuration is named: \"\" (i.e. empty string) and is defined by\n      the variables coming from your ``local.conf``\n      file. Consequently, the previous example actually adds two\n      additional configurations to your build: \"arm\" and \"x86\" along\n      with \"\".\n\n-  *Launch BitBake*: Use the following BitBake command form to launch\n   the multiple configuration build::\n\n      $ bitbake [mc:multiconfigname:]target [[[mc:multiconfigname:]target] ... ]\n\n   For the example in this section, the following command applies::\n\n      $ bitbake mc:x86:core-image-minimal mc:arm:core-image-sato mc::core-image-base\n\n"}
{"text": "\n\nBuilding\n   The previous BitBake command builds a ``core-image-minimal`` image\n   that is configured through the ``x86.conf`` configuration file, a\n   ``core-image-sato`` image that is configured through the ``arm.conf``\n   configuration file and a ``core-image-base`` that is configured\n   through your ``local.conf`` configuration file.\n\n.. note::\n\n   Support for multiple configuration builds in the Yocto Project &DISTRO;\n   (&DISTRO_NAME;) Release does not include Shared State (sstate)\n   optimizations. Consequently, if a build uses the same object twice\n   in, for example, two different :term:`TMPDIR`\n   directories, the build either loads from an existing sstate cache for\n   that build at the start or builds the object fresh.\n\nEnabling Multiple Configuration Build Dependencies\n--------------------------------------------------\n\nSometimes dependencies can exist between targets (multiconfigs) in a\nmultiple configuration build. For example, suppose that in order to\nbuild a ``core-image-sato`` image for an \"x86\" multiconfig, the root\nfilesystem of an \"arm\" multiconfig must exist. This dependency is\nessentially that the\n:ref:`ref-tasks-image` task in the\n``core-image-sato`` recipe depends on the completion of the\n:ref:`ref-tasks-rootfs` task of the\n``core-image-minimal`` recipe.\n\nTo enable dependencies in a multiple configuration build, you must\ndeclare the dependencies in the recipe using the following statement\nform::\n\n   task_or_package[mcdepends] = \"mc:from_multiconfig:to_multiconfig:recipe_name:task_on_which_to_depend\"\n\nTo better show how to use this statement, consider the example scenario\nfrom the first paragraph of this section. The following statement needs\nto be added to the recipe that builds the ``core-image-sato`` image::\n\n   do_image[mcdepends] = \"mc:x86:arm:core-image-minimal:do_rootfs\"\n\nIn this example, the `from_multiconfig` is \"x86\". The `to_multiconfig` is \"arm\". The\ntask on which the :ref:`ref-tasks-image` task in the recipe depends is the\n:ref:`ref-tasks-rootfs` task from the ``core-image-minimal`` recipe associated\nwith the \"arm\" multiconfig.\n\nOnce you set up this dependency, you can build the \"x86\" multiconfig\nusing a BitBake command as follows::\n\n   $ bitbake mc:x86:core-image-sato\n\nThis command executes all the tasks needed to create the\n``core-image-sato`` image for the \"x86\" multiconfig. Because of the\ndependency, BitBake also executes through the :ref:`ref-tasks-rootfs` task for the\n\"arm\" multiconfig build.\n\nHaving a recipe depend on the root filesystem of another build might not\nseem that useful. Consider this change to the statement in the\n``core-image-sato`` recipe::\n\n   do_image[mcdepends] = \"mc:x86:arm:core-image-minimal:do_image\"\n\nIn this case, BitBake must\ncreate the ``core-image-minimal`` image for the \"arm\" build since the\n\"x86\" build depends on it.\n\nBecause \"x86\" and \"arm\" are enabled for multiple configuration builds\nand have separate configuration files, BitBake places the artifacts for\neach build in the respective temporary build directories (i.e.\n:term:`TMPDIR`).\n\nBuilding an Initial RAM Filesystem (Initramfs) Image\n====================================================\n\nAn initial RAM filesystem (:term:`Initramfs`) image provides a temporary root\nfilesystem used for early system initialization, typically providing tools and\nloading modules needed to locate and mount the final root filesystem.\n\nFollow these steps to create an :term:`Initramfs` image:\n\n#. *Create the Initramfs Image Recipe:* You can reference the\n   ``core-image-minimal-initramfs.bb`` recipe found in the\n   ``meta/recipes-core`` directory of the :term:`Source Directory`\n   as an example from which to work.\n\n#. *Decide if You Need to Bundle the Initramfs Image Into the Kernel\n   Image:* If you want the :term:`Initramfs` image that is built to be bundled\n   in with the kernel image, set the :term:`INITRAMFS_IMAGE_BUNDLE`\n   variable to ``\"1\"`` in your ``local.conf`` configuration file and set the\n   :term:`INITRAMFS_IMAGE` variable in the recipe that builds the kernel image.\n\n   Setting the :term:`INITRAMFS_IMAGE_BUNDLE` flag causes the :term:`Initramfs`\n   image to be unpacked into the ``${B}/usr/`` directory. The unpacked\n   :term:`Initramfs` image is then passed to the kernel's ``Makefile`` using the\n   :term:`CONFIG_INITRAMFS_SOURCE` variable, allowing the :term:`Initramfs`\n   image to be built into the kernel normally.\n\n#. *Optionally Add Items to the Initramfs Image Through the Initramfs\n   Image Recipe:* If you add items to the :term:`Initramfs` image by way of its\n   recipe, you should use :term:`PACKAGE_INSTALL` rather than\n   :term:`IMAGE_INSTALL`. :term:`PACKAGE_INSTALL` gives more direct control of\n"}
{"text": "\n\nBuilding\n   what is added to the image as compared to the defaults you might not\n   necessarily want that are set by the :ref:`ref-classes-image`\n   or :ref:`ref-classes-core-image` classes.\n\n#. *Build the Kernel Image and the Initramfs Image:* Build your kernel\n   image using BitBake. Because the :term:`Initramfs` image recipe is a\n   dependency of the kernel image, the :term:`Initramfs` image is built as well\n   and bundled with the kernel image if you used the\n   :term:`INITRAMFS_IMAGE_BUNDLE` variable described earlier.\n\nBundling an Initramfs Image From a Separate Multiconfig\n-------------------------------------------------------\n\nThere may be a case where we want to build an :term:`Initramfs` image which does not\ninherit the same distro policy as our main image, for example, we may want\nour main image to use ``TCLIBC=\"glibc\"``, but to use ``TCLIBC=\"musl\"`` in our :term:`Initramfs`\nimage to keep a smaller footprint. However, by performing the steps mentioned\nabove the :term:`Initramfs` image will inherit ``TCLIBC=\"glibc\"`` without allowing us\nto override it.\n\nTo achieve this, you need to perform some additional steps:\n\n#. *Create a multiconfig for your Initramfs image:* You can perform the steps\n   on \":ref:`dev-manual/building:building images for multiple targets using multiple configurations`\" to create a separate multiconfig.\n   For the sake of simplicity let's assume such multiconfig is called: ``initramfscfg.conf`` and\n   contains the variables::\n\n      TMPDIR=\"${TOPDIR}/tmp-initramfscfg\"\n      TCLIBC=\"musl\"\n\n#. *Set additional Initramfs variables on your main configuration:*\n   Additionally, on your main configuration (``local.conf``) you need to set the\n   variables::\n\n     INITRAMFS_MULTICONFIG = \"initramfscfg\"\n     INITRAMFS_DEPLOY_DIR_IMAGE = \"${TOPDIR}/tmp-initramfscfg/deploy/images/${MACHINE}\"\n\n   The variables :term:`INITRAMFS_MULTICONFIG` and :term:`INITRAMFS_DEPLOY_DIR_IMAGE`\n   are used to create a multiconfig dependency from the kernel to the :term:`INITRAMFS_IMAGE`\n   to be built coming from the ``initramfscfg`` multiconfig, and to let the\n   buildsystem know where the :term:`INITRAMFS_IMAGE` will be located.\n\n   Building a system with such configuration will build the kernel using the\n   main configuration but the :ref:`ref-tasks-bundle_initramfs` task will grab the\n   selected :term:`INITRAMFS_IMAGE` from :term:`INITRAMFS_DEPLOY_DIR_IMAGE`\n   instead, resulting in a musl based :term:`Initramfs` image bundled in the kernel\n   but a glibc based main image.\n\n   The same is applicable to avoid inheriting :term:`DISTRO_FEATURES` on :term:`INITRAMFS_IMAGE`\n   or to build a different :term:`DISTRO` for it such as ``poky-tiny``.\n\n\nBuilding a Tiny System\n======================\n\nVery small distributions have some significant advantages such as\nrequiring less on-die or in-package memory (cheaper), better performance\nthrough efficient cache usage, lower power requirements due to less\nmemory, faster boot times, and reduced development overhead. Some\nreal-world examples where a very small distribution gives you distinct\nadvantages are digital cameras, medical devices, and small headless\nsystems.\n\nThis section presents information that shows you how you can trim your\ndistribution to even smaller sizes than the ``poky-tiny`` distribution,\nwhich is around 5 Mbytes, that can be built out-of-the-box using the\nYocto Project.\n\nTiny System Overview\n--------------------\n\nThe following list presents the overall steps you need to consider and\nperform to create distributions with smaller root filesystems, achieve\nfaster boot times, maintain your critical functionality, and avoid\ninitial RAM disks:\n\n-  :ref:`Determine your goals and guiding principles\n   <dev-manual/building:goals and guiding principles>`\n\n-  :ref:`dev-manual/building:understand what contributes to your image size`\n\n-  :ref:`Reduce the size of the root filesystem\n   <dev-manual/building:trim the root filesystem>`\n\n-  :ref:`Reduce the size of the kernel <dev-manual/building:trim the kernel>`\n\n-  :ref:`dev-manual/building:remove package management requirements`\n\n-  :ref:`dev-manual/building:look for other ways to minimize size`\n\n-  :ref:`dev-manual/building:iterate on the process`\n\nGoals and Guiding Principles\n----------------------------\n\nBefore you can reach your destination, you need to know where you are\ngoing. Here is an example list that you can use as a guide when creating\nvery small distributions:\n\n-  Determine how much space you need (e.g. a kernel that is 1 Mbyte or\n"}
{"text": "\n\nBuilding\n   less and a root filesystem that is 3 Mbytes or less).\n\n-  Find the areas that are currently taking 90% of the space and\n   concentrate on reducing those areas.\n\n-  Do not create any difficult \"hacks\" to achieve your goals.\n\n-  Leverage the device-specific options.\n\n-  Work in a separate layer so that you keep changes isolated. For\n   information on how to create layers, see the\n   \":ref:`dev-manual/layers:understanding and creating layers`\" section.\n\nUnderstand What Contributes to Your Image Size\n----------------------------------------------\n\nIt is easiest to have something to start with when creating your own\ndistribution. You can use the Yocto Project out-of-the-box to create the\n``poky-tiny`` distribution. Ultimately, you will want to make changes in\nyour own distribution that are likely modeled after ``poky-tiny``.\n\n.. note::\n\n   To use ``poky-tiny`` in your build, set the :term:`DISTRO` variable in your\n   ``local.conf`` file to \"poky-tiny\" as described in the\n   \":ref:`dev-manual/custom-distribution:creating your own distribution`\"\n   section.\n\nUnderstanding some memory concepts will help you reduce the system size.\nMemory consists of static, dynamic, and temporary memory. Static memory\nis the TEXT (code), DATA (initialized data in the code), and BSS\n(uninitialized data) sections. Dynamic memory represents memory that is\nallocated at runtime: stacks, hash tables, and so forth. Temporary\nmemory is recovered after the boot process. This memory consists of\nmemory used for decompressing the kernel and for the ``__init__``\nfunctions.\n\nTo help you see where you currently are with kernel and root filesystem\nsizes, you can use two tools found in the :term:`Source Directory`\nin the\n``scripts/tiny/`` directory:\n\n-  ``ksize.py``: Reports component sizes for the kernel build objects.\n\n-  ``dirsize.py``: Reports component sizes for the root filesystem.\n\nThis next tool and command help you organize configuration fragments and\nview file dependencies in a human-readable form:\n\n-  ``merge_config.sh``: Helps you manage configuration files and\n   fragments within the kernel. With this tool, you can merge individual\n   configuration fragments together. The tool allows you to make\n   overrides and warns you of any missing configuration options. The\n   tool is ideal for allowing you to iterate on configurations, create\n   minimal configurations, and create configuration files for different\n   machines without having to duplicate your process.\n\n   The ``merge_config.sh`` script is part of the Linux Yocto kernel Git\n   repositories (i.e. ``linux-yocto-3.14``, ``linux-yocto-3.10``,\n   ``linux-yocto-3.8``, and so forth) in the ``scripts/kconfig``\n   directory.\n\n   For more information on configuration fragments, see the\n   \":ref:`kernel-dev/common:creating configuration fragments`\"\n   section in the Yocto Project Linux Kernel Development Manual.\n\n-  ``bitbake -u taskexp -g bitbake_target``: Using the BitBake command\n   with these options brings up a Dependency Explorer from which you can\n   view file dependencies. Understanding these dependencies allows you\n   to make informed decisions when cutting out various pieces of the\n   kernel and root filesystem.\n\nTrim the Root Filesystem\n------------------------\n\nThe root filesystem is made up of packages for booting, libraries, and\napplications. To change things, you can configure how the packaging\nhappens, which changes the way you build them. You can also modify the\nfilesystem itself or select a different filesystem.\n\nFirst, find out what is hogging your root filesystem by running the\n``dirsize.py`` script from your root directory::\n\n   $ cd root-directory-of-image\n   $ dirsize.py 100000 > dirsize-100k.log\n   $ cat dirsize-100k.log\n\nYou can apply a filter to the script to ignore files\nunder a certain size. The previous example filters out any files below\n100 Kbytes. The sizes reported by the tool are uncompressed, and thus\nwill be smaller by a relatively constant factor in a compressed root\nfilesystem. When you examine your log file, you can focus on areas of\nthe root filesystem that take up large amounts of memory.\n\nYou need to be sure that what you eliminate does not cripple the\nfunctionality you need. One way to see how packages relate to each other\nis by using the Dependency Explorer UI with the BitBake command::\n\n   $ cd image-directory\n   $ bitbake -u taskexp -g image\n"}
{"text": "\n\nBuilding\n\nUse the interface to\nselect potential packages you wish to eliminate and see their dependency\nrelationships.\n\nWhen deciding how to reduce the size, get rid of packages that result in\nminimal impact on the feature set. For example, you might not need a VGA\ndisplay. Or, you might be able to get by with ``devtmpfs`` and ``mdev``\ninstead of ``udev``.\n\nUse your ``local.conf`` file to make changes. For example, to eliminate\n``udev`` and ``glib``, set the following in the local configuration\nfile::\n\n   VIRTUAL-RUNTIME_dev_manager = \"\"\n\nFinally, you should consider exactly the type of root filesystem you\nneed to meet your needs while also reducing its size. For example,\nconsider ``cramfs``, ``squashfs``, ``ubifs``, ``ext2``, or an\n:term:`Initramfs` using ``initramfs``. Be aware that ``ext3`` requires a 1\nMbyte journal. If you are okay with running read-only, you do not need\nthis journal.\n\n.. note::\n\n   After each round of elimination, you need to rebuild your system and\n   then use the tools to see the effects of your reductions.\n\nTrim the Kernel\n---------------\n\nThe kernel is built by including policies for hardware-independent\naspects. What subsystems do you enable? For what architecture are you\nbuilding? Which drivers do you build by default?\n\n.. note::\n\n   You can modify the kernel source if you want to help with boot time.\n\nRun the ``ksize.py`` script from the top-level Linux build directory to\nget an idea of what is making up the kernel::\n\n   $ cd top-level-linux-build-directory\n   $ ksize.py > ksize.log\n   $ cat ksize.log\n\nWhen you examine the log, you will see how much space is taken up with\nthe built-in ``.o`` files for drivers, networking, core kernel files,\nfilesystem, sound, and so forth. The sizes reported by the tool are\nuncompressed, and thus will be smaller by a relatively constant factor\nin a compressed kernel image. Look to reduce the areas that are large\nand taking up around the \"90% rule.\"\n\nTo examine, or drill down, into any particular area, use the ``-d``\noption with the script::\n\n   $ ksize.py -d > ksize.log\n\nUsing this option\nbreaks out the individual file information for each area of the kernel\n(e.g. drivers, networking, and so forth).\n\nUse your log file to see what you can eliminate from the kernel based on\nfeatures you can let go. For example, if you are not going to need\nsound, you do not need any drivers that support sound.\n\nAfter figuring out what to eliminate, you need to reconfigure the kernel\nto reflect those changes during the next build. You could run\n``menuconfig`` and make all your changes at once. However, that makes it\ndifficult to see the effects of your individual eliminations and also\nmakes it difficult to replicate the changes for perhaps another target\ndevice. A better method is to start with no configurations using\n``allnoconfig``, create configuration fragments for individual changes,\nand then manage the fragments into a single configuration file using\n``merge_config.sh``. The tool makes it easy for you to iterate using the\nconfiguration change and build cycle.\n\nEach time you make configuration changes, you need to rebuild the kernel\nand check to see what impact your changes had on the overall size.\n\nRemove Package Management Requirements\n--------------------------------------\n\nPackaging requirements add size to the image. One way to reduce the size\nof the image is to remove all the packaging requirements from the image.\nThis reduction includes both removing the package manager and its unique\ndependencies as well as removing the package management data itself.\n\nTo eliminate all the packaging requirements for an image, be sure that\n\"package-management\" is not part of your\n:term:`IMAGE_FEATURES`\nstatement for the image. When you remove this feature, you are removing\nthe package manager as well as its dependencies from the root\nfilesystem.\n\nLook for Other Ways to Minimize Size\n------------------------------------\n\nDepending on your particular circumstances, other areas that you can\ntrim likely exist. The key to finding these areas is through tools and\n"}
{"text": "\n\nBuilding\nmethods described here combined with experimentation and iteration. Here\nare a couple of areas to experiment with:\n\n-  ``glibc``: In general, follow this process:\n\n   #. Remove ``glibc`` features from\n      :term:`DISTRO_FEATURES`\n      that you think you do not need.\n\n   #. Build your distribution.\n\n   #. If the build fails due to missing symbols in a package, determine\n      if you can reconfigure the package to not need those features. For\n      example, change the configuration to not support wide character\n      support as is done for ``ncurses``. Or, if support for those\n      characters is needed, determine what ``glibc`` features provide\n      the support and restore the configuration.\n\n   4. Rebuild and repeat the process.\n\n-  ``busybox``: For BusyBox, use a process similar as described for\n   ``glibc``. A difference is you will need to boot the resulting system\n   to see if you are able to do everything you expect from the running\n   system. You need to be sure to integrate configuration fragments into\n   Busybox because BusyBox handles its own core features and then allows\n   you to add configuration fragments on top.\n\nIterate on the Process\n----------------------\n\nIf you have not reached your goals on system size, you need to iterate\non the process. The process is the same. Use the tools and see just what\nis taking up 90% of the root filesystem and the kernel. Decide what you\ncan eliminate without limiting your device beyond what you need.\n\nDepending on your system, a good place to look might be Busybox, which\nprovides a stripped down version of Unix tools in a single, executable\nfile. You might be able to drop virtual terminal services or perhaps\nipv6.\n\nBuilding Images for More than One Machine\n=========================================\n\nA common scenario developers face is creating images for several\ndifferent machines that use the same software environment. In this\nsituation, it is tempting to set the tunings and optimization flags for\neach build specifically for the targeted hardware (i.e. \"maxing out\" the\ntunings). Doing so can considerably add to build times and package feed\nmaintenance collectively for the machines. For example, selecting tunes\nthat are extremely specific to a CPU core used in a system might enable\nsome micro optimizations in GCC for that particular system but would\notherwise not gain you much of a performance difference across the other\nsystems as compared to using a more general tuning across all the builds\n(e.g. setting :term:`DEFAULTTUNE`\nspecifically for each machine's build). Rather than \"max out\" each\nbuild's tunings, you can take steps that cause the OpenEmbedded build\nsystem to reuse software across the various machines where it makes\nsense.\n\nIf build speed and package feed maintenance are considerations, you\nshould consider the points in this section that can help you optimize\nyour tunings to best consider build times and package feed maintenance.\n\n-  *Share the :term:`Build Directory`:* If at all possible, share the\n   :term:`TMPDIR` across builds. The Yocto Project supports switching between\n   different :term:`MACHINE` values in the same :term:`TMPDIR`. This practice\n   is well supported and regularly used by developers when building for\n   multiple machines. When you use the same :term:`TMPDIR` for multiple\n   machine builds, the OpenEmbedded build system can reuse the existing native\n   and often cross-recipes for multiple machines. Thus, build time decreases.\n\n   .. note::\n\n      If :term:`DISTRO` settings change or fundamental configuration settings\n      such as the filesystem layout, you need to work with a clean :term:`TMPDIR`.\n      Sharing :term:`TMPDIR` under these circumstances might work but since it is\n      not guaranteed, you should use a clean :term:`TMPDIR`.\n\n-  *Enable the Appropriate Package Architecture:* By default, the\n   OpenEmbedded build system enables three levels of package\n   architectures: \"all\", \"tune\" or \"package\", and \"machine\". Any given\n   recipe usually selects one of these package architectures (types) for\n   its output. Depending for what a given recipe creates packages,\n   making sure you enable the appropriate package architecture can\n   directly impact the build time.\n\n   A recipe that just generates scripts can enable \"all\" architecture\n   because there are no binaries to build. To specifically enable \"all\"\n   architecture, be sure your recipe inherits the\n   :ref:`ref-classes-allarch` class.\n   This class is useful for \"all\" architectures because it configures\n   many variables so packages can be used across multiple architectures.\n\n   If your recipe needs to generate packages that are machine-specific\n   or when one of the build or runtime dependencies is already\n   machine-architecture dependent, which makes your recipe also\n   machine-architecture dependent, make sure your recipe enables the\n   \"machine\" package architecture through the\n   :term:`MACHINE_ARCH`\n   variable::\n"}
{"text": "\n\nBuilding\n\n      PACKAGE_ARCH = \"${MACHINE_ARCH}\"\n\n   When you do not\n   specifically enable a package architecture through the\n   :term:`PACKAGE_ARCH`, The\n   OpenEmbedded build system defaults to the\n   :term:`TUNE_PKGARCH` setting::\n\n      PACKAGE_ARCH = \"${TUNE_PKGARCH}\"\n\n-  *Choose a Generic Tuning File if Possible:* Some tunes are more\n   generic and can run on multiple targets (e.g. an ``armv5`` set of\n   packages could run on ``armv6`` and ``armv7`` processors in most\n   cases). Similarly, ``i486`` binaries could work on ``i586`` and\n   higher processors. You should realize, however, that advances on\n   newer processor versions would not be used.\n\n   If you select the same tune for several different machines, the\n   OpenEmbedded build system reuses software previously built, thus\n   speeding up the overall build time. Realize that even though a new\n   sysroot for each machine is generated, the software is not recompiled\n   and only one package feed exists.\n\n-  *Manage Granular Level Packaging:* Sometimes there are cases where\n   injecting another level of package architecture beyond the three\n   higher levels noted earlier can be useful. For example, consider how\n   NXP (formerly Freescale) allows for the easy reuse of binary packages\n   in their layer\n   :yocto_git:`meta-freescale </meta-freescale/>`.\n   In this example, the\n   :yocto_git:`fsl-dynamic-packagearch </meta-freescale/tree/classes/fsl-dynamic-packagearch.bbclass>`\n   class shares GPU packages for i.MX53 boards because all boards share\n   the AMD GPU. The i.MX6-based boards can do the same because all\n   boards share the Vivante GPU. This class inspects the BitBake\n   datastore to identify if the package provides or depends on one of\n   the sub-architecture values. If so, the class sets the\n   :term:`PACKAGE_ARCH` value\n   based on the ``MACHINE_SUBARCH`` value. If the package does not\n   provide or depend on one of the sub-architecture values but it\n   matches a value in the machine-specific filter, it sets\n   :term:`MACHINE_ARCH`. This\n   behavior reduces the number of packages built and saves build time by\n   reusing binaries.\n\n-  *Use Tools to Debug Issues:* Sometimes you can run into situations\n   where software is being rebuilt when you think it should not be. For\n   example, the OpenEmbedded build system might not be using shared\n   state between machines when you think it should be. These types of\n   situations are usually due to references to machine-specific\n   variables such as :term:`MACHINE`,\n   :term:`SERIAL_CONSOLES`,\n   :term:`XSERVER`,\n   :term:`MACHINE_FEATURES`,\n   and so forth in code that is supposed to only be tune-specific or\n   when the recipe depends\n   (:term:`DEPENDS`,\n   :term:`RDEPENDS`,\n   :term:`RRECOMMENDS`,\n   :term:`RSUGGESTS`, and so forth)\n   on some other recipe that already has\n   :term:`PACKAGE_ARCH` defined\n   as \"${MACHINE_ARCH}\".\n\n   .. note::\n\n      Patches to fix any issues identified are most welcome as these\n      issues occasionally do occur.\n\n   For such cases, you can use some tools to help you sort out the\n   situation:\n\n   -  ``state-diff-machines.sh``*:* You can find this tool in the\n      ``scripts`` directory of the Source Repositories. See the comments\n      in the script for information on how to use the tool.\n\n   -  *BitBake's \"-S printdiff\" Option:* Using this option causes\n      BitBake to try to establish the closest signature match it can\n      (e.g. in the shared state cache) and then run ``bitbake-diffsigs``\n      over the matches to determine the stamps and delta where these two\n      stamp trees diverge.\n\nBuilding Software from an External Source\n=========================================\n\nBy default, the OpenEmbedded build system uses the :term:`Build Directory`\nwhen building source code. The build process involves fetching the source\nfiles, unpacking them, and then patching them if necessary before the build\ntakes place.\n\nThere are situations where you might want to build software from source\nfiles that are external to and thus outside of the OpenEmbedded build\nsystem. For example, suppose you have a project that includes a new BSP\nwith a heavily customized kernel. And, you want to minimize exposing the\nbuild system to the development team so that they can focus on their\nproject and maintain everyone's workflow as much as possible. In this\ncase, you want a kernel source directory on the development machine\nwhere the development occurs. You want the recipe's\n:term:`SRC_URI` variable to point to\nthe external directory and use it as is, not copy it.\n"}
{"text": "\n\nBuilding\n\nTo build from software that comes from an external source, all you need to do\nis inherit the :ref:`ref-classes-externalsrc` class and then set\nthe :term:`EXTERNALSRC` variable to point to your external source code. Here\nare the statements to put in your ``local.conf`` file::\n\n   INHERIT += \"externalsrc\"\n   EXTERNALSRC:pn-myrecipe = \"path-to-your-source-tree\"\n\nThis next example shows how to accomplish the same thing by setting\n:term:`EXTERNALSRC` in the recipe itself or in the recipe's append file::\n\n   EXTERNALSRC = \"path\"\n   EXTERNALSRC_BUILD = \"path\"\n\n.. note::\n\n   In order for these settings to take effect, you must globally or\n   locally inherit the :ref:`ref-classes-externalsrc` class.\n\nBy default, :ref:`ref-classes-externalsrc` builds the source code in a\ndirectory separate from the external source directory as specified by\n:term:`EXTERNALSRC`. If you need\nto have the source built in the same directory in which it resides, or\nsome other nominated directory, you can set\n:term:`EXTERNALSRC_BUILD`\nto point to that directory::\n\n   EXTERNALSRC_BUILD:pn-myrecipe = \"path-to-your-source-tree\"\n\nReplicating a Build Offline\n===========================\n\nIt can be useful to take a \"snapshot\" of upstream sources used in a\nbuild and then use that \"snapshot\" later to replicate the build offline.\nTo do so, you need to first prepare and populate your downloads\ndirectory your \"snapshot\" of files. Once your downloads directory is\nready, you can use it at any time and from any machine to replicate your\nbuild.\n\nFollow these steps to populate your Downloads directory:\n\n#. *Create a Clean Downloads Directory:* Start with an empty downloads\n   directory (:term:`DL_DIR`). You\n   start with an empty downloads directory by either removing the files\n   in the existing directory or by setting :term:`DL_DIR` to point to either\n   an empty location or one that does not yet exist.\n\n#. *Generate Tarballs of the Source Git Repositories:* Edit your\n   ``local.conf`` configuration file as follows::\n\n      DL_DIR = \"/home/your-download-dir/\"\n      BB_GENERATE_MIRROR_TARBALLS = \"1\"\n\n   During\n   the fetch process in the next step, BitBake gathers the source files\n   and creates tarballs in the directory pointed to by :term:`DL_DIR`. See\n   the\n   :term:`BB_GENERATE_MIRROR_TARBALLS`\n   variable for more information.\n\n#. *Populate Your Downloads Directory Without Building:* Use BitBake to\n   fetch your sources but inhibit the build::\n\n      $ bitbake target --runonly=fetch\n\n   The downloads directory (i.e. ``${DL_DIR}``) now has\n   a \"snapshot\" of the source files in the form of tarballs, which can\n   be used for the build.\n\n#. *Optionally Remove Any Git or other SCM Subdirectories From the\n   Downloads Directory:* If you want, you can clean up your downloads\n   directory by removing any Git or other Source Control Management\n   (SCM) subdirectories such as ``${DL_DIR}/git2/*``. The tarballs\n   already contain these subdirectories.\n\nOnce your downloads directory has everything it needs regarding source\nfiles, you can create your \"own-mirror\" and build your target.\nUnderstand that you can use the files to build the target offline from\nany machine and at any time.\n\nFollow these steps to build your target using the files in the downloads\ndirectory:\n\n#. *Using Local Files Only:* Inside your ``local.conf`` file, add the\n   :term:`SOURCE_MIRROR_URL` variable, inherit the\n   :ref:`ref-classes-own-mirrors` class, and use the\n   :term:`BB_NO_NETWORK` variable to your ``local.conf``::\n\n      SOURCE_MIRROR_URL ?= \"file:///home/your-download-dir/\"\n      INHERIT += \"own-mirrors\"\n      BB_NO_NETWORK = \"1\"\n\n   The :term:`SOURCE_MIRROR_URL` and :ref:`ref-classes-own-mirrors`\n   class set up the system to use the downloads directory as your \"own\n   mirror\". Using the :term:`BB_NO_NETWORK` variable makes sure that\n   BitBake's fetching process in step 3 stays local, which means files\n   from your \"own-mirror\" are used.\n\n#. *Start With a Clean Build:* You can start with a clean build by\n"}
{"text": "\n\nBuilding\n   removing the ``${``\\ :term:`TMPDIR`\\ ``}`` directory or using a new\n   :term:`Build Directory`.\n\n#. *Build Your Target:* Use BitBake to build your target::\n\n      $ bitbake target\n\n   The build completes using the known local \"snapshot\" of source\n   files from your mirror. The resulting tarballs for your \"snapshot\" of\n   source files are in the downloads directory.\n\n   .. note::\n\n      The offline build does not work if recipes attempt to find the\n      latest version of software by setting\n      :term:`SRCREV` to\n      ``${``\\ :term:`AUTOREV`\\ ``}``::\n\n         SRCREV = \"${AUTOREV}\"\n\n      When a recipe sets :term:`SRCREV` to\n      ``${``\\ :term:`AUTOREV`\\ ``}``, the build system accesses the network in an\n      attempt to determine the latest version of software from the SCM.\n      Typically, recipes that use :term:`AUTOREV` are custom or modified\n      recipes. Recipes that reside in public repositories usually do not\n      use :term:`AUTOREV`.\n\n      If you do have recipes that use :term:`AUTOREV`, you can take steps to\n      still use the recipes in an offline build. Do the following:\n\n      #. Use a configuration generated by enabling :ref:`build\n         history <dev-manual/build-quality:maintaining build output quality>`.\n\n      #. Use the ``buildhistory-collect-srcrevs`` command to collect the\n         stored :term:`SRCREV` values from the build's history. For more\n         information on collecting these values, see the\n         \":ref:`dev-manual/build-quality:build history package information`\"\n         section.\n\n      #. Once you have the correct source revisions, you can modify\n         those recipes to set :term:`SRCREV` to specific versions of the\n         software.\n\n"}
{"text": "\n\nChecking for Vulnerabilities\n\n\nChecking for Vulnerabilities\n****************************\n\nVulnerabilities in Poky and OE-Core\n===================================\n\nThe Yocto Project has an infrastructure to track and address unfixed\nknown security vulnerabilities, as tracked by the public\n:wikipedia:`Common Vulnerabilities and Exposures (CVE) <Common_Vulnerabilities_and_Exposures>`\ndatabase.\n\nThe Yocto Project maintains a `list of known vulnerabilities\n<https://autobuilder.yocto.io/pub/non-release/patchmetrics/>`__\nfor packages in Poky and OE-Core, tracking the evolution of the number of\nunpatched CVEs and the status of patches. Such information is available for\nthe current development version and for each supported release.\n\nSecurity is a process, not a product, and thus at any time, a number of security\nissues may be impacting Poky and OE-Core. It is up to the maintainers, users,\ncontributors and anyone interested in the issues to investigate and possibly fix them by\nupdating software components to newer versions or by applying patches to address them.\nIt is recommended to work with Poky and OE-Core upstream maintainers and submit\npatches to fix them, see \":doc:`../contributor-guide/submit-changes`\" for details.\n\nVulnerability check at build time\n=================================\n\nTo enable a check for CVE security vulnerabilities using\n:ref:`ref-classes-cve-check` in the specific image or target you are building,\nadd the following setting to your configuration::\n\n   INHERIT += \"cve-check\"\n\nThe CVE database contains some old incomplete entries which have been\ndeemed not to impact Poky or OE-Core. These CVE entries can be excluded from the\ncheck using build configuration::\n\n   include conf/distro/include/cve-extra-exclusions.inc\n\nWith this CVE check enabled, BitBake build will try to map each compiled software component\nrecipe name and version information to the CVE database and generate recipe and\nimage specific reports. These reports will contain:\n\n-  metadata about the software component like names and versions\n\n-  metadata about the CVE issue such as description and NVD link\n\n-  for each software component, a list of CVEs which are possibly impacting this version\n\n-  status of each CVE: ``Patched``, ``Unpatched`` or ``Ignored``\n\nThe status ``Patched`` means that a patch file to address the security issue has been\napplied. ``Unpatched`` status means that no patches to address the issue have been\napplied and that the issue needs to be investigated. ``Ignored`` means that after\nanalysis, it has been deemed to ignore the issue as it for example affects\nthe software component on a different operating system platform.\n\nAfter a build with CVE check enabled, reports for each compiled source recipe will be\nfound in ``build/tmp/deploy/cve``.\n\nFor example the CVE check report for the ``flex-native`` recipe looks like::\n\n   $ cat poky/build/tmp/deploy/cve/flex-native\n   LAYER: meta\n   PACKAGE NAME: flex-native\n   PACKAGE VERSION: 2.6.4\n   CVE: CVE-2016-6354\n   CVE STATUS: Patched\n   CVE SUMMARY: Heap-based buffer overflow in the yy_get_next_buffer function in Flex before 2.6.1 might allow context-dependent attackers to cause a denial of service or possibly execute arbitrary code via vectors involving num_to_read.\n   CVSS v2 BASE SCORE: 7.5\n   CVSS v3 BASE SCORE: 9.8\n   VECTOR: NETWORK\n   MORE INFORMATION: https://nvd.nist.gov/vuln/detail/CVE-2016-6354\n\n   LAYER: meta\n   PACKAGE NAME: flex-native\n   PACKAGE VERSION: 2.6.4\n   CVE: CVE-2019-6293\n   CVE STATUS: Ignored\n   CVE SUMMARY: An issue was discovered in the function mark_beginning_as_normal in nfa.c in flex 2.6.4. There is a stack exhaustion problem caused by the mark_beginning_as_normal function making recursive calls to itself in certain scenarios involving lots of '*' characters. Remote attackers could leverage this vulnerability to cause a denial-of-service.\n   CVSS v2 BASE SCORE: 4.3\n   CVSS v3 BASE SCORE: 5.5\n   VECTOR: NETWORK\n   MORE INFORMATION: https://nvd.nist.gov/vuln/detail/CVE-2019-6293\n\nFor images, a summary of all recipes included in the image and their CVEs is also\ngenerated in textual and JSON formats. These ``.cve`` and ``.json`` reports can be found\nin the ``tmp/deploy/images`` directory for each compiled image.\n\nAt build time CVE check will also throw warnings about ``Unpatched`` CVEs::\n\n   WARNING: flex-2.6.4-r0 do_cve_check: Found unpatched CVE (CVE-2019-6293), for more information check /poky/build/tmp/work/core2-64-poky-linux/flex/2.6.4-r0/temp/cve.log\n   WARNING: libarchive-3.5.1-r0 do_cve_check: Found unpatched CVE (CVE-2021-36976), for more information check /poky/build/tmp/work/core2-64-poky-linux/libarchive/3.5.1-r0/temp/cve.log\n\nIt is also possible to check the CVE status of individual packages as follows::\n\n   bitbake -c cve_check flex libarchive\n\n"}
{"text": "\n\nChecking for Vulnerabilities\nFixing CVE product name and version mappings\n============================================\n\nBy default, :ref:`ref-classes-cve-check` uses the recipe name :term:`BPN` as CVE\nproduct name when querying the CVE database. If this mapping contains false positives, e.g.\nsome reported CVEs are not for the software component in question, or false negatives like\nsome CVEs are not found to impact the recipe when they should, then the problems can be\nin the recipe name to CVE product mapping. These mapping issues can be fixed by setting\nthe :term:`CVE_PRODUCT` variable inside the recipe. This defines the name of the software component in the\nupstream `NIST CVE database <https://nvd.nist.gov/>`__.\n\nThe variable supports using vendor and product names like this::\n\n   CVE_PRODUCT = \"flex_project:flex\"\n\nIn this example the vendor name used in the CVE database is ``flex_project`` and the\nproduct is ``flex``. With this setting the ``flex`` recipe only maps to this specific\nproduct and not products from other vendors with same name ``flex``.\n\nSimilarly, when the recipe version :term:`PV` is not compatible with software versions used by\nthe upstream software component releases and the CVE database, these can be fixed using\nthe :term:`CVE_VERSION` variable.\n\nNote that if the CVE entries in the NVD database contain bugs or have missing or incomplete\ninformation, it is recommended to fix the information there directly instead of working\naround the issues possibly for a long time in Poky and OE-Core side recipes. Feedback to\nNVD about CVE entries can be provided through the `NVD contact form <https://nvd.nist.gov/info/contact-form>`__.\n\nFixing vulnerabilities in recipes\n=================================\n\nSuppose a CVE security issue impacts a software component. In that case, it can\nbe fixed by updating to a newer version, by applying a patch, or by marking it\nas patched via :term:`CVE_STATUS` variable flag. For Poky and OE-Core master\nbranches, updating to a more recent software component release with fixes is\nthe best option, but patches can be applied if releases are not yet available.\n\nFor stable branches, we want to avoid API (Application Programming Interface)\nor ABI (Application Binary Interface) breakages. When submitting an update,\na minor version update of a component is preferred if the version is\nbackward-compatible. Many software components have backward-compatible stable\nversions, with a notable example of the Linux kernel. However, if the new\nversion does or likely might introduce incompatibilities, extracting and\nbackporting patches is preferred.\n\nHere is an example of fixing CVE security issues with patch files,\nan example from the :oe_layerindex:`ffmpeg recipe for dunfell </layerindex/recipe/122174>`::\n\n   SRC_URI = \"https://www.ffmpeg.org/releases/${BP}.tar.xz \\\n              file://mips64_cpu_detection.patch \\\n              file://CVE-2020-12284.patch \\\n              file://0001-libavutil-include-assembly-with-full-path-from-sourc.patch \\\n              file://CVE-2021-3566.patch \\\n              file://CVE-2021-38291.patch \\\n              file://CVE-2022-1475.patch \\\n              file://CVE-2022-3109.patch \\\n              file://CVE-2022-3341.patch \\\n              file://CVE-2022-48434.patch \\\n          \"\n\nThe recipe has both generic and security-related fixes. The CVE patch files are named\naccording to the CVE they fix.\n\nWhen preparing the patch file, take the original patch from the upstream repository.\nDo not use patches from different distributions, except if it is the only available source.\n\nModify the patch adding OE-related metadata. We will follow the example of the\n``CVE-2022-3341.patch``.\n\nThe original `commit message <https://github.com/FFmpeg/FFmpeg/commit/9cf652cef49d74afe3d454f27d49eb1a1394951e.patch/>`__\nis::\n\n   From 9cf652cef49d74afe3d454f27d49eb1a1394951e Mon Sep 17 00:00:00 2001\n   From: Jiasheng Jiang <jiasheng@iscas.ac.cn>\n   Date: Wed, 23 Feb 2022 10:31:59 +0800\n   Subject: [PATCH] avformat/nutdec: Add check for avformat_new_stream\n\n   Check for failure of avformat_new_stream() and propagate\n   the error code.\n\n   Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>\n   ---\n    libavformat/nutdec.c | 16 ++++++++++++----\n    1 file changed, 12 insertions(+), 4 deletions(-)\n\n\nFor the correct operations of the ``cve-check``, it requires the CVE\nidentification in a ``CVE:`` tag of the patch file commit message using\nthe format::\n\n   CVE: CVE-2022-3341\n\nIt is also recommended to add the ``Upstream-Status:`` tag with a link\nto the original patch and sign-off by people working on the backport.\nIf there are any modifications to the original patch, note them in\nthe ``Comments:`` tag.\n\nWith the additional information, the header of the patch file in OE-core becomes::\n\n   From 9cf652cef49d74afe3d454f27d49eb1a1394951e Mon Sep 17 00:00:00 2001\n"}
{"text": "\n\nChecking for Vulnerabilities\n   From: Jiasheng Jiang <jiasheng@iscas.ac.cn>\n   Date: Wed, 23 Feb 2022 10:31:59 +0800\n   Subject: [PATCH] avformat/nutdec: Add check for avformat_new_stream\n\n   Check for failure of avformat_new_stream() and propagate\n   the error code.\n\n   Signed-off-by: Michael Niedermayer <michael@niedermayer.cc>\n\n   CVE: CVE-2022-3341\n\n   Upstream-Status: Backport [https://github.com/FFmpeg/FFmpeg/commit/9cf652cef49d74afe3d454f27d49eb1a1394951e]\n\n   Comments: Refreshed Hunk\n   Signed-off-by: Narpat Mali <narpat.mali@windriver.com>\n   Signed-off-by: Bhabu Bindu <bhabu.bindu@kpit.com>\n   ---\n    libavformat/nutdec.c | 16 ++++++++++++----\n    1 file changed, 12 insertions(+), 4 deletions(-)\n\nA good practice is to include the CVE identifier in the patch file name, the patch file\ncommit message and optionally in the recipe commit message.\n\nCVE checker will then capture this information and change the CVE status to ``Patched``\nin the generated reports.\n\nIf analysis shows that the CVE issue does not impact the recipe due to configuration, platform,\nversion or other reasons, the CVE can be marked as ``Ignored`` by using\nthe :term:`CVE_STATUS` variable flag with appropriate reason which is mapped to ``Ignored``.\nThe entry should have the format like::\n\n   CVE_STATUS[CVE-2016-10642] = \"cpe-incorrect: This is specific to the npm package that installs cmake, so isn't relevant to OpenEmbedded\"\n\nAs mentioned previously, if data in the CVE database is wrong, it is recommended\nto fix those issues in the CVE database (NVD in the case of OE-core and Poky)\ndirectly.\n\nNote that if there are many CVEs with the same status and reason, those can be\nshared by using the :term:`CVE_STATUS_GROUPS` variable.\n\nRecipes can be completely skipped by CVE check by including the recipe name in\nthe :term:`CVE_CHECK_SKIP_RECIPE` variable.\n\nImplementation details\n======================\n\nHere's what the :ref:`ref-classes-cve-check` class does to find unpatched CVE IDs.\n\nFirst the code goes through each patch file provided by a recipe. If a valid CVE ID\nis found in the name of the file, the corresponding CVE is considered as patched.\nDon't forget that if multiple CVE IDs are found in the filename, only the last\none is considered. Then, the code looks for ``CVE: CVE-ID`` lines in the patch\nfile. The found CVE IDs are also considered as patched.\nAdditionally ``CVE_STATUS`` variable flags are parsed for reasons mapped to ``Patched``\nand these are also considered as patched.\n\nThen, the code looks up all the CVE IDs in the NIST database for all the\nproducts defined in :term:`CVE_PRODUCT`. Then, for each found CVE:\n\n-  If the package name (:term:`PN`) is part of\n   :term:`CVE_CHECK_SKIP_RECIPE`, it is considered as ``Patched``.\n\n-  If the CVE ID has status ``CVE_STATUS[<CVE ID>] = \"ignored\"`` or if it's set to\n   any reason which is mapped to status ``Ignored`` via ``CVE_CHECK_STATUSMAP``,\n   it is  set as ``Ignored``.\n\n-  If the CVE ID is part of the patched CVE for the recipe, it is\n   already considered as ``Patched``.\n\n-  Otherwise, the code checks whether the recipe version (:term:`PV`)\n   is within the range of versions impacted by the CVE. If so, the CVE\n   is considered as ``Unpatched``.\n\nThe CVE database is stored in :term:`DL_DIR` and can be inspected using\n``sqlite3`` command as follows::\n\n   sqlite3 downloads/CVE_CHECK/nvdcve_1.1.db .dump | grep CVE-2021-37462\n\nWhen analyzing CVEs, it is recommended to:\n\n-  study the latest information in `CVE database <https://nvd.nist.gov/vuln/search>`__.\n\n-  check how upstream developers of the software component addressed the issue, e.g.\n   what patch was applied, which upstream release contains the fix.\n\n-  check what other Linux distributions like `Debian <https://security-tracker.debian.org/tracker/>`__\n   did to analyze and address the issue.\n\n-  follow security notices from other Linux distributions.\n\n-  follow public `open source security mailing lists <https://oss-security.openwall.org/wiki/mailing-lists>`__ for\n   discussions and advance notifications of CVE bugs and software releases with fixes.\n\n"}
{"text": "\n\nUsing Wayland and Weston\n\n\nUsing Wayland and Weston\n************************\n\n:wikipedia:`Wayland <Wayland_(display_server_protocol)>`\nis a computer display server protocol that provides a method for\ncompositing window managers to communicate directly with applications\nand video hardware and expects them to communicate with input hardware\nusing other libraries. Using Wayland with supporting targets can result\nin better control over graphics frame rendering than an application\nmight otherwise achieve.\n\nThe Yocto Project provides the Wayland protocol libraries and the\nreference :wikipedia:`Weston <Wayland_(display_server_protocol)#Weston>`\ncompositor as part of its release. You can find the integrated packages\nin the ``meta`` layer of the :term:`Source Directory`.\nSpecifically, you\ncan find the recipes that build both Wayland and Weston at\n``meta/recipes-graphics/wayland``.\n\nYou can build both the Wayland and Weston packages for use only with targets\nthat accept the :wikipedia:`Mesa 3D and Direct Rendering Infrastructure\n<Mesa_(computer_graphics)>`, which is also known as Mesa DRI. This implies that\nyou cannot build and use the packages if your target uses, for example, the\nIntel Embedded Media and Graphics Driver (Intel EMGD) that overrides Mesa DRI.\n\n.. note::\n\n   Due to lack of EGL support, Weston 1.0.3 will not run directly on the\n   emulated QEMU hardware. However, this version of Weston will run\n   under X emulation without issues.\n\nThis section describes what you need to do to implement Wayland and use\nthe Weston compositor when building an image for a supporting target.\n\nEnabling Wayland in an Image\n============================\n\nTo enable Wayland, you need to enable it to be built and enable it to be\nincluded (installed) in the image.\n\nBuilding Wayland\n----------------\n\nTo cause Mesa to build the ``wayland-egl`` platform and Weston to build\nWayland with Kernel Mode Setting\n(`KMS <https://wiki.archlinux.org/index.php/Kernel_Mode_Setting>`__)\nsupport, include the \"wayland\" flag in the\n:term:`DISTRO_FEATURES`\nstatement in your ``local.conf`` file::\n\n   DISTRO_FEATURES:append = \" wayland\"\n\n.. note::\n\n   If X11 has been enabled elsewhere, Weston will build Wayland with X11\n   support\n\nInstalling Wayland and Weston\n-----------------------------\n\nTo install the Wayland feature into an image, you must include the\nfollowing\n:term:`CORE_IMAGE_EXTRA_INSTALL`\nstatement in your ``local.conf`` file::\n\n   CORE_IMAGE_EXTRA_INSTALL += \"wayland weston\"\n\nRunning Weston\n==============\n\nTo run Weston inside X11, enabling it as described earlier and building\na Sato image is sufficient. If you are running your image under Sato, a\nWeston Launcher appears in the \"Utility\" category.\n\nAlternatively, you can run Weston through the command-line interpretor\n(CLI), which is better suited for development work. To run Weston under\nthe CLI, you need to do the following after your image is built:\n\n#. Run these commands to export ``XDG_RUNTIME_DIR``::\n\n      mkdir -p /tmp/$USER-weston\n      chmod 0700 /tmp/$USER-weston\n      export XDG_RUNTIME_DIR=/tmp/$USER-weston\n\n#. Launch Weston in the shell::\n\n      weston\n\n"}
{"text": "\n\nCreating Your Own Distribution\n\n\nCreating Your Own Distribution\n******************************\n\nWhen you build an image using the Yocto Project and do not alter any\ndistribution :term:`Metadata`, you are\ncreating a Poky distribution. If you wish to gain more control over\npackage alternative selections, compile-time options, and other\nlow-level configurations, you can create your own distribution.\n\nTo create your own distribution, the basic steps consist of creating\nyour own distribution layer, creating your own distribution\nconfiguration file, and then adding any needed code and Metadata to the\nlayer. The following steps provide some more detail:\n\n-  *Create a layer for your new distro:* Create your distribution layer\n   so that you can keep your Metadata and code for the distribution\n   separate. It is strongly recommended that you create and use your own\n   layer for configuration and code. Using your own layer as compared to\n   just placing configurations in a ``local.conf`` configuration file\n   makes it easier to reproduce the same build configuration when using\n   multiple build machines. See the\n   \":ref:`dev-manual/layers:creating a general layer using the \\`\\`bitbake-layers\\`\\` script`\"\n   section for information on how to quickly set up a layer.\n\n-  *Create the distribution configuration file:* The distribution\n   configuration file needs to be created in the ``conf/distro``\n   directory of your layer. You need to name it using your distribution\n   name (e.g. ``mydistro.conf``).\n\n   .. note::\n\n      The :term:`DISTRO` variable in your ``local.conf`` file determines the\n      name of your distribution.\n\n   You can split out parts of your configuration file into include files\n   and then \"require\" them from within your distribution configuration\n   file. Be sure to place the include files in the\n   ``conf/distro/include`` directory of your layer. A common example\n   usage of include files would be to separate out the selection of\n   desired version and revisions for individual recipes.\n\n   Your configuration file needs to set the following required\n   variables:\n\n   - :term:`DISTRO_NAME`\n\n   - :term:`DISTRO_VERSION`\n\n   These following variables are optional and you typically set them\n   from the distribution configuration file:\n\n   - :term:`DISTRO_FEATURES`\n\n   - :term:`DISTRO_EXTRA_RDEPENDS`\n\n   - :term:`DISTRO_EXTRA_RRECOMMENDS`\n\n   - :term:`TCLIBC`\n\n   .. tip::\n\n      If you want to base your distribution configuration file on the\n      very basic configuration from OE-Core, you can use\n      ``conf/distro/defaultsetup.conf`` as a reference and just include\n      variables that differ as compared to ``defaultsetup.conf``.\n      Alternatively, you can create a distribution configuration file\n      from scratch using the ``defaultsetup.conf`` file or configuration files\n      from another distribution such as Poky as a reference.\n\n-  *Provide miscellaneous variables:* Be sure to define any other\n   variables for which you want to create a default or enforce as part\n   of the distribution configuration. You can include nearly any\n   variable from the ``local.conf`` file. The variables you use are not\n   limited to the list in the previous bulleted item.\n\n-  *Point to Your distribution configuration file:* In your ``local.conf``\n   file in the :term:`Build Directory`, set your :term:`DISTRO` variable to\n   point to your distribution's configuration file. For example, if your\n   distribution's configuration file is named ``mydistro.conf``, then\n   you point to it as follows::\n\n      DISTRO = \"mydistro\"\n\n-  *Add more to the layer if necessary:* Use your layer to hold other\n   information needed for the distribution:\n\n   -  Add recipes for installing distro-specific configuration files\n      that are not already installed by another recipe. If you have\n      distro-specific configuration files that are included by an\n      existing recipe, you should add an append file (``.bbappend``) for\n      those. For general information and recommendations on how to add\n      recipes to your layer, see the\n      \":ref:`dev-manual/layers:creating your own layer`\" and\n      \":ref:`dev-manual/layers:following best practices when creating layers`\"\n      sections.\n\n   -  Add any image recipes that are specific to your distribution.\n\n"}
{"text": "\n\nCreating Your Own Distribution\n   -  Add a ``psplash`` append file for a branded splash screen, using\n      the :term:`SPLASH_IMAGES` variable.\n\n   -  Add any other append files to make custom changes that are\n      specific to individual recipes.\n\n   For information on append files, see the\n   \":ref:`dev-manual/layers:appending other layers metadata with your layer`\"\n   section.\n"}
{"text": "\n\nEnabling GObject Introspection Support\n\n\nEnabling GObject Introspection Support\n**************************************\n\n`GObject introspection <https://gi.readthedocs.io/en/latest/>`__\nis the standard mechanism for accessing GObject-based software from\nruntime environments. GObject is a feature of the GLib library that\nprovides an object framework for the GNOME desktop and related software.\nGObject Introspection adds information to GObject that allows objects\ncreated within it to be represented across different programming\nlanguages. If you want to construct GStreamer pipelines using Python, or\ncontrol UPnP infrastructure using Javascript and GUPnP, GObject\nintrospection is the only way to do it.\n\nThis section describes the Yocto Project support for generating and\npackaging GObject introspection data. GObject introspection data is a\ndescription of the API provided by libraries built on top of the GLib\nframework, and, in particular, that framework's GObject mechanism.\nGObject Introspection Repository (GIR) files go to ``-dev`` packages,\n``typelib`` files go to main packages as they are packaged together with\nlibraries that are introspected.\n\nThe data is generated when building such a library, by linking the\nlibrary with a small executable binary that asks the library to describe\nitself, and then executing the binary and processing its output.\n\nGenerating this data in a cross-compilation environment is difficult\nbecause the library is produced for the target architecture, but its\ncode needs to be executed on the build host. This problem is solved with\nthe OpenEmbedded build system by running the code through QEMU, which\nallows precisely that. Unfortunately, QEMU does not always work\nperfectly as mentioned in the \":ref:`dev-manual/gobject-introspection:known issues`\"\nsection.\n\nEnabling the Generation of Introspection Data\n=============================================\n\nEnabling the generation of introspection data (GIR files) in your\nlibrary package involves the following:\n\n#. Inherit the :ref:`ref-classes-gobject-introspection` class.\n\n#. Make sure introspection is not disabled anywhere in the recipe or\n   from anything the recipe includes. Also, make sure that\n   \"gobject-introspection-data\" is not in\n   :term:`DISTRO_FEATURES_BACKFILL_CONSIDERED`\n   and that \"qemu-usermode\" is not in\n   :term:`MACHINE_FEATURES_BACKFILL_CONSIDERED`.\n   In either of these conditions, nothing will happen.\n\n#. Try to build the recipe. If you encounter build errors that look like\n   something is unable to find ``.so`` libraries, check where these\n   libraries are located in the source tree and add the following to the\n   recipe::\n\n      GIR_EXTRA_LIBS_PATH = \"${B}/something/.libs\"\n\n   .. note::\n\n      See recipes in the ``oe-core`` repository that use that\n      :term:`GIR_EXTRA_LIBS_PATH` variable as an example.\n\n#. Look for any other errors, which probably mean that introspection\n   support in a package is not entirely standard, and thus breaks down\n   in a cross-compilation environment. For such cases, custom-made fixes\n   are needed. A good place to ask and receive help in these cases is\n   the :ref:`Yocto Project mailing\n   lists <resources-mailinglist>`.\n\n.. note::\n\n   Using a library that no longer builds against the latest Yocto\n   Project release and prints introspection related errors is a good\n   candidate for the previous procedure.\n\nDisabling the Generation of Introspection Data\n==============================================\n\nYou might find that you do not want to generate introspection data. Or,\nperhaps QEMU does not work on your build host and target architecture\ncombination. If so, you can use either of the following methods to\ndisable GIR file generations:\n\n-  Add the following to your distro configuration::\n\n      DISTRO_FEATURES_BACKFILL_CONSIDERED = \"gobject-introspection-data\"\n\n   Adding this statement disables generating introspection data using\n   QEMU but will still enable building introspection tools and libraries\n   (i.e. building them does not require the use of QEMU).\n\n-  Add the following to your machine configuration::\n\n      MACHINE_FEATURES_BACKFILL_CONSIDERED = \"qemu-usermode\"\n\n   Adding this statement disables the use of QEMU when building packages for your\n   machine. Currently, this feature is used only by introspection\n   recipes and has the same effect as the previously described option.\n\n"}
{"text": "\n\nEnabling GObject Introspection Support\n   .. note::\n\n      Future releases of the Yocto Project might have other features\n      affected by this option.\n\nIf you disable introspection data, you can still obtain it through other\nmeans such as copying the data from a suitable sysroot, or by generating\nit on the target hardware. The OpenEmbedded build system does not\ncurrently provide specific support for these techniques.\n\nTesting that Introspection Works in an Image\n============================================\n\nUse the following procedure to test if generating introspection data is\nworking in an image:\n\n#. Make sure that \"gobject-introspection-data\" is not in\n   :term:`DISTRO_FEATURES_BACKFILL_CONSIDERED`\n   and that \"qemu-usermode\" is not in\n   :term:`MACHINE_FEATURES_BACKFILL_CONSIDERED`.\n\n#. Build ``core-image-sato``.\n\n#. Launch a Terminal and then start Python in the terminal.\n\n#. Enter the following in the terminal::\n\n      >>> from gi.repository import GLib\n      >>> GLib.get_host_name()\n\n#. For something a little more advanced, enter the following see:\n   https://python-gtk-3-tutorial.readthedocs.io/en/latest/introduction.html\n\nKnown Issues\n============\n\nHere are know issues in GObject Introspection Support:\n\n-  ``qemu-ppc64`` immediately crashes. Consequently, you cannot build\n   introspection data on that architecture.\n\n-  x32 is not supported by QEMU. Consequently, introspection data is\n   disabled.\n\n-  musl causes transient GLib binaries to crash on assertion failures.\n   Consequently, generating introspection data is disabled.\n\n-  Because QEMU is not able to run the binaries correctly, introspection\n   is disabled for some specific packages under specific architectures\n   (e.g. ``gcr``, ``libsecret``, and ``webkit``).\n\n-  QEMU usermode might not work properly when running 64-bit binaries\n   under 32-bit host machines. In particular, \"qemumips64\" is known to\n   not work under i686.\n\n"}
{"text": "\n\n\n\n***********************************\nSetting Up to Use the Yocto Project\n***********************************\n\nThis chapter provides guidance on how to prepare to use the Yocto\nProject. You can learn about creating a team environment to develop\nusing the Yocto Project, how to set up a :ref:`build\nhost <dev-manual/start:preparing the build host>`, how to locate\nYocto Project source repositories, and how to create local Git\nrepositories.\n\nCreating a Team Development Environment\n=======================================\n\nIt might not be immediately clear how you can use the Yocto Project in a\nteam development environment, or how to scale it for a large team of\ndevelopers. You can adapt the Yocto Project to many different use cases\nand scenarios; however, this flexibility could cause difficulties if you\nare trying to create a working setup that scales effectively.\n\nTo help you understand how to set up this type of environment, this\nsection presents a procedure that gives you information that can help\nyou get the results you want. The procedure is high-level and presents\nsome of the project's most successful experiences, practices, solutions,\nand available technologies that have proved to work well in the past;\nhowever, keep in mind, the procedure here is simply a starting point.\nYou can build off these steps and customize the procedure to fit any\nparticular working environment and set of practices.\n\n#.  *Determine Who is Going to be Developing:* You first need to\n    understand who is going to be doing anything related to the Yocto\n    Project and determine their roles. Making this determination is\n    essential to completing subsequent steps, which are to get your\n    equipment together and set up your development environment's\n    hardware topology.\n\n    Here are possible roles:\n\n    -  *Application Developer:* This type of developer does application\n       level work on top of an existing software stack.\n\n    -  *Core System Developer:* This type of developer works on the\n       contents of the operating system image itself.\n\n    -  *Build Engineer:* This type of developer manages Autobuilders and\n       releases. Depending on the specifics of the environment, not all\n       situations might need a Build Engineer.\n\n    -  *Test Engineer:* This type of developer creates and manages\n       automated tests that are used to ensure all application and core\n       system development meets desired quality standards.\n\n#.  *Gather the Hardware:* Based on the size and make-up of the team,\n    get the hardware together. Ideally, any development, build, or test\n    engineer uses a system that runs a supported Linux distribution.\n    These systems, in general, should be high performance (e.g. dual,\n    six-core Xeons with 24 Gbytes of RAM and plenty of disk space). You\n    can help ensure efficiency by having any machines used for testing\n    or that run Autobuilders be as high performance as possible.\n\n    .. note::\n\n       Given sufficient processing power, you might also consider\n       building Yocto Project development containers to be run under\n       Docker, which is described later.\n\n#.  *Understand the Hardware Topology of the Environment:* Once you\n    understand the hardware involved and the make-up of the team, you\n    can understand the hardware topology of the development environment.\n    You can get a visual idea of the machines and their roles across the\n    development environment.\n\n#.  *Use Git as Your Source Control Manager (SCM):* Keeping your\n    :term:`Metadata` (i.e. recipes,\n    configuration files, classes, and so forth) and any software you are\n    developing under the control of an SCM system that is compatible\n    with the OpenEmbedded build system is advisable. Of all of the SCMs\n    supported by BitBake, the Yocto Project team strongly recommends using\n    :ref:`overview-manual/development-environment:git`.\n    Git is a distributed system\n    that is easy to back up, allows you to work remotely, and then\n    connects back to the infrastructure.\n\n    .. note::\n\n       For information about BitBake, see the\n       :doc:`bitbake:index`.\n\n    It is relatively easy to set up Git services and create infrastructure like\n    :yocto_git:`/`, which is based on server software called\n    `Gitolite <https://gitolite.com>`__\n    with `cgit <https://git.zx2c4.com/cgit/about/>`__ being used to\n    generate the web interface that lets you view the repositories.\n    ``gitolite`` identifies users using SSH keys and allows\n    branch-based access controls to repositories that you can control as\n    little or as much as necessary.\n\n#.  *Set up the Application Development Machines:* As mentioned earlier,\n"}
{"text": "\n\n\nSetting Up to Use the Yocto Project\n    application developers are creating applications on top of existing\n    software stacks. Following are some best practices for setting up\n    machines used for application development:\n\n    -  Use a pre-built toolchain that contains the software stack\n       itself. Then, develop the application code on top of the stack.\n       This method works well for small numbers of relatively isolated\n       applications.\n\n    -  Keep your cross-development toolchains updated. You can do this\n       through provisioning either as new toolchain downloads or as\n       updates through a package update mechanism using ``opkg`` to\n       provide updates to an existing toolchain. The exact mechanics of\n       how and when to do this depend on local policy.\n\n    -  Use multiple toolchains installed locally into different\n       locations to allow development across versions.\n\n#.  *Set up the Core Development Machines:* As mentioned earlier, core\n    developers work on the contents of the operating system itself.\n    Following are some best practices for setting up machines used for\n    developing images:\n\n    -  Have the :term:`OpenEmbedded Build System` available on\n       the developer workstations so developers can run their own builds\n       and directly rebuild the software stack.\n\n    -  Keep the core system unchanged as much as possible and do your\n       work in layers on top of the core system. Doing so gives you a\n       greater level of portability when upgrading to new versions of\n       the core system or Board Support Packages (BSPs).\n\n    -  Share layers amongst the developers of a particular project and\n       contain the policy configuration that defines the project.\n\n#.  *Set up an Autobuilder:* Autobuilders are often the core of the\n    development environment. It is here that changes from individual\n    developers are brought together and centrally tested. Based on this\n    automated build and test environment, subsequent decisions about\n    releases can be made. Autobuilders also allow for \"continuous\n    integration\" style testing of software components and regression\n    identification and tracking.\n\n    See \":yocto_ab:`Yocto Project Autobuilder <>`\" for more\n    information and links to buildbot. The Yocto Project team has found\n    this implementation works well in this role. A public example of\n    this is the Yocto Project Autobuilders, which the Yocto Project team\n    uses to test the overall health of the project.\n\n    The features of this system are:\n\n    -  Highlights when commits break the build.\n\n    -  Populates an :ref:`sstate\n       cache <overview-manual/concepts:shared state cache>` from which\n       developers can pull rather than requiring local builds.\n\n    -  Allows commit hook triggers, which trigger builds when commits\n       are made.\n\n    -  Allows triggering of automated image booting and testing under\n       the QuickEMUlator (QEMU).\n\n    -  Supports incremental build testing and from-scratch builds.\n\n    -  Shares output that allows developer testing and historical\n       regression investigation.\n\n    -  Creates output that can be used for releases.\n\n    -  Allows scheduling of builds so that resources can be used\n       efficiently.\n\n#.  *Set up Test Machines:* Use a small number of shared, high\n    performance systems for testing purposes. Developers can use these\n    systems for wider, more extensive testing while they continue to\n    develop locally using their primary development system.\n\n#.  *Document Policies and Change Flow:* The Yocto Project uses a\n    hierarchical structure and a pull model. There are scripts to create and\n    send pull requests (i.e. ``create-pull-request`` and\n    ``send-pull-request``). This model is in line with other open source\n    projects where maintainers are responsible for specific areas of the\n    project and a single maintainer handles the final \"top-of-tree\"\n    merges.\n\n    .. note::\n\n       You can also use a more collective push model. The ``gitolite``\n       software supports both the push and pull models quite easily.\n\n    As with any development environment, it is important to document the\n    policy used as well as any main project guidelines so they are\n    understood by everyone. It is also a good idea to have\n    well-structured commit messages, which are usually a part of a\n    project's guidelines. Good commit messages are essential when\n    looking back in time and trying to understand why changes were made.\n\n    If you discover that changes are needed to the core layer of the\n    project, it is worth sharing those with the community as soon as\n"}
{"text": "\n\n\nSetting Up to Use the Yocto Project\n    possible. Chances are if you have discovered the need for changes,\n    someone else in the community needs them also.\n\n#.  *Development Environment Summary:* Aside from the previous steps,\n    here are best practices within the Yocto Project development\n    environment:\n\n    -  Use :ref:`overview-manual/development-environment:git` as the source control\n       system.\n\n    -  Maintain your Metadata in layers that make sense for your\n       situation. See the \":ref:`overview-manual/yp-intro:the yocto project layer model`\"\n       section in the Yocto Project Overview and Concepts Manual and the\n       \":ref:`dev-manual/layers:understanding and creating layers`\"\n       section for more information on layers.\n\n    -  Separate the project's Metadata and code by using separate Git\n       repositories. See the \":ref:`overview-manual/development-environment:yocto project source repositories`\"\n       section in the Yocto Project Overview and Concepts Manual for\n       information on these repositories. See the\n       \":ref:`dev-manual/start:locating yocto project source files`\"\n       section for information on how to set up local Git repositories\n       for related upstream Yocto Project Git repositories.\n\n    -  Set up the directory for the shared state cache\n       (:term:`SSTATE_DIR`) where\n       it makes sense. For example, set up the sstate cache on a system\n       used by developers in the same organization and share the same\n       source directories on their machines.\n\n    -  Set up an Autobuilder and have it populate the sstate cache and\n       source directories.\n\n    -  The Yocto Project community encourages you to send patches to the\n       project to fix bugs or add features. If you do submit patches,\n       follow the project commit guidelines for writing good commit\n       messages. See the \":doc:`../contributor-guide/submit-changes`\"\n       section in the Yocto Project and OpenEmbedded Contributor Guide.\n\n    -  Send changes to the core sooner than later as others are likely\n       to run into the same issues. For some guidance on mailing lists\n       to use, see the lists in the\n       \":ref:`contributor-guide/submit-changes:finding a suitable mailing list`\"\n       section. For a description\n       of the available mailing lists, see the \":ref:`resources-mailinglist`\" section in\n       the Yocto Project Reference Manual.\n\nPreparing the Build Host\n========================\n\nThis section provides procedures to set up a system to be used as your\n:term:`Build Host` for\ndevelopment using the Yocto Project. Your build host can be a native\nLinux machine (recommended), it can be a machine (Linux, Mac, or\nWindows) that uses `CROPS <https://github.com/crops/poky-container>`__,\nwhich leverages `Docker Containers <https://www.docker.com/>`__ or it\ncan be a Windows machine capable of running version 2 of Windows Subsystem\nFor Linux (WSL 2).\n\n.. note::\n\n   The Yocto Project is not compatible with version 1 of\n   :wikipedia:`Windows Subsystem for Linux <Windows_Subsystem_for_Linux>`.\n   It is compatible but neither officially supported nor validated with\n   WSL 2. If you still decide to use WSL please upgrade to\n   `WSL 2 <https://learn.microsoft.com/en-us/windows/wsl/install>`__.\n\nOnce your build host is set up to use the Yocto Project, further steps\nare necessary depending on what you want to accomplish. See the\nfollowing references for information on how to prepare for Board Support\nPackage (BSP) development and kernel development:\n\n-  *BSP Development:* See the \":ref:`bsp-guide/bsp:preparing your build host to work with bsp layers`\"\n   section in the Yocto Project Board Support Package (BSP) Developer's\n   Guide.\n\n-  *Kernel Development:* See the \":ref:`kernel-dev/common:preparing the build host to work on the kernel`\"\n   section in the Yocto Project Linux Kernel Development Manual.\n\nSetting Up a Native Linux Host\n------------------------------\n\nFollow these steps to prepare a native Linux machine as your Yocto\nProject Build Host:\n\n#. *Use a Supported Linux Distribution:* You should have a reasonably\n   current Linux-based host system. You will have the best results with\n   a recent release of Fedora, openSUSE, Debian, Ubuntu, RHEL or CentOS\n   as these releases are frequently tested against the Yocto Project and\n   officially supported. For a list of the distributions under\n   validation and their status, see the \":ref:`Supported Linux\n   Distributions <system-requirements-supported-distros>`\"\n   section in the Yocto Project Reference Manual and the wiki page at\n   :yocto_wiki:`Distribution Support </Distribution_Support>`.\n\n#. *Have Enough Free Memory:* Your system should have at least 50 Gbytes\n   of free disk space for building images.\n\n#. *Meet Minimal Version Requirements:* The OpenEmbedded build system\n   should be able to run on any modern distribution that has the\n"}
{"text": "\n\n\nSetting Up to Use the Yocto Project\n   following versions for Git, tar, Python, gcc and make.\n\n   -  Git &MIN_GIT_VERSION; or greater\n\n   -  tar &MIN_TAR_VERSION; or greater\n\n   -  Python &MIN_PYTHON_VERSION; or greater.\n\n   -  gcc &MIN_GCC_VERSION; or greater.\n\n   -  GNU make &MIN_MAKE_VERSION; or greater\n\n   If your build host does not meet any of these listed version\n   requirements, you can take steps to prepare the system so that you\n   can still use the Yocto Project. See the\n   \":ref:`ref-manual/system-requirements:required git, tar, python, make and gcc versions`\"\n   section in the Yocto Project Reference Manual for information.\n\n#. *Install Development Host Packages:* Required development host\n   packages vary depending on your build host and what you want to do\n   with the Yocto Project. Collectively, the number of required packages\n   is large if you want to be able to cover all cases.\n\n   For lists of required packages for all scenarios, see the\n   \":ref:`ref-manual/system-requirements:required packages for the build host`\"\n   section in the Yocto Project Reference Manual.\n\nOnce you have completed the previous steps, you are ready to continue\nusing a given development path on your native Linux machine. If you are\ngoing to use BitBake, see the\n\":ref:`dev-manual/start:cloning the \\`\\`poky\\`\\` repository`\"\nsection. If you are going\nto use the Extensible SDK, see the \":doc:`/sdk-manual/extensible`\" Chapter in the Yocto\nProject Application Development and the Extensible Software Development\nKit (eSDK) manual. If you want to work on the kernel, see the :doc:`/kernel-dev/index`. If you are going to use\nToaster, see the \":doc:`/toaster-manual/setup-and-use`\"\nsection in the Toaster User Manual. If you are a VSCode user, you can configure\nthe `Yocto Project BitBake\n<https://marketplace.visualstudio.com/items?itemName=yocto-project.yocto-bitbake>`__\nextension accordingly.\n\nSetting Up to Use CROss PlatformS (CROPS)\n-----------------------------------------\n\nWith `CROPS <https://github.com/crops/poky-container>`__, which\nleverages `Docker Containers <https://www.docker.com/>`__, you can\ncreate a Yocto Project development environment that is operating system\nagnostic. You can set up a container in which you can develop using the\nYocto Project on a Windows, Mac, or Linux machine.\n\nFollow these general steps to prepare a Windows, Mac, or Linux machine\nas your Yocto Project build host:\n\n#. *Determine What Your Build Host Needs:*\n   `Docker <https://www.docker.com/what-docker>`__ is a software\n   container platform that you need to install on the build host.\n   Depending on your build host, you might have to install different\n   software to support Docker containers. Go to the Docker installation\n   page and read about the platform requirements in \"`Supported\n   Platforms <https://docs.docker.com/engine/install/#supported-platforms>`__\"\n   your build host needs to run containers.\n\n#. *Choose What To Install:* Depending on whether or not your build host\n   meets system requirements, you need to install \"Docker CE Stable\" or\n   the \"Docker Toolbox\". Most situations call for Docker CE. However, if\n   you have a build host that does not meet requirements (e.g.\n   Pre-Windows 10 or Windows 10 \"Home\" version), you must install Docker\n   Toolbox instead.\n\n#. *Go to the Install Site for Your Platform:* Click the link for the\n   Docker edition associated with your build host's native software. For\n   example, if your build host is running Microsoft Windows Version 10\n   and you want the Docker CE Stable edition, click that link under\n   \"Supported Platforms\".\n\n#. *Install the Software:* Once you have understood all the\n   pre-requisites, you can download and install the appropriate\n   software. Follow the instructions for your specific machine and the\n   type of the software you need to install:\n\n   -  Install `Docker Desktop on\n      Windows <https://docs.docker.com/docker-for-windows/install/#install-docker-desktop-on-windows>`__\n      for Windows build hosts that meet requirements.\n\n   -  Install `Docker Desktop on\n      MacOs <https://docs.docker.com/docker-for-mac/install/#install-and-run-docker-desktop-on-mac>`__\n      for Mac build hosts that meet requirements.\n\n   -  Install `Docker Engine on\n      CentOS <https://docs.docker.com/engine/install/centos/>`__\n      for Linux build hosts running the CentOS distribution.\n\n   -  Install `Docker Engine on\n      Debian <https://docs.docker.com/engine/install/debian/>`__\n      for Linux build hosts running the Debian distribution.\n\n   -  Install `Docker Engine for\n      Fedora <https://docs.docker.com/engine/install/fedora/>`__\n      for Linux build hosts running the Fedora distribution.\n\n"}
{"text": "\n\n\nSetting Up to Use the Yocto Project\n   -  Install `Docker Engine for\n      Ubuntu <https://docs.docker.com/engine/install/ubuntu/>`__\n      for Linux build hosts running the Ubuntu distribution.\n\n#. *Optionally Orient Yourself With Docker:* If you are unfamiliar with\n   Docker and the container concept, you can learn more here -\n   https://docs.docker.com/get-started/.\n\n#. *Launch Docker or Docker Toolbox:* You should be able to launch\n   Docker or the Docker Toolbox and have a terminal shell on your\n   development host.\n\n#. *Set Up the Containers to Use the Yocto Project:* Go to\n   https://github.com/crops/docker-win-mac-docs/wiki and follow\n   the directions for your particular build host (i.e. Linux, Mac, or\n   Windows).\n\n   Once you complete the setup instructions for your machine, you have\n   the Poky, Extensible SDK, and Toaster containers available. You can\n   click those links from the page and learn more about using each of\n   those containers.\n\nOnce you have a container set up, everything is in place to develop just\nas if you were running on a native Linux machine. If you are going to\nuse the Poky container, see the\n\":ref:`dev-manual/start:cloning the \\`\\`poky\\`\\` repository`\"\nsection. If you are going to use the Extensible SDK container, see the\n\":doc:`/sdk-manual/extensible`\" Chapter in the Yocto\nProject Application Development and the Extensible Software Development\nKit (eSDK) manual. If you are going to use the Toaster container, see\nthe \":doc:`/toaster-manual/setup-and-use`\"\nsection in the Toaster User Manual. If you are a VSCode user, you can configure\nthe `Yocto Project BitBake\n<https://marketplace.visualstudio.com/items?itemName=yocto-project.yocto-bitbake>`__\nextension accordingly.\n\nSetting Up to Use Windows Subsystem For Linux (WSL 2)\n-----------------------------------------------------\n\nWith `Windows Subsystem for Linux (WSL 2)\n<https://learn.microsoft.com/en-us/windows/wsl/>`__,\nyou can create a Yocto Project development environment that allows you\nto build on Windows. You can set up a Linux distribution inside Windows\nin which you can develop using the Yocto Project.\n\nFollow these general steps to prepare a Windows machine using WSL 2 as\nyour Yocto Project build host:\n\n#. *Make sure your Windows machine is capable of running WSL 2:*\n\n   While all Windows 11 and Windows Server 2022 builds support WSL 2,\n   the first versions of Windows 10 and Windows Server 2019 didn't.\n   Check the minimum build numbers for `Windows 10\n   <https://learn.microsoft.com/en-us/windows/wsl/install-manual#step-2---check-requirements-for-running-wsl-2>`__\n   and for `Windows Server 2019\n   <https://learn.microsoft.com/en-us/windows/wsl/install-on-server>`__.\n\n   To check which build version you are running, you may open a command\n   prompt on Windows and execute the command \"ver\"::\n\n      C:\\Users\\myuser> ver\n\n      Microsoft Windows [Version 10.0.19041.153]\n\n#. *Install the Linux distribution of your choice inside WSL 2:*\n   Once you know your version of Windows supports WSL 2, you can\n   install the distribution of your choice from the Microsoft Store.\n   Open the Microsoft Store and search for Linux. While there are\n   several Linux distributions available, the assumption is that your\n   pick will be one of the distributions supported by the Yocto Project\n   as stated on the instructions for using a native Linux host. After\n   making your selection, simply click \"Get\" to download and install the\n   distribution.\n\n#. *Check which Linux distribution WSL 2 is using:* Open a Windows\n   PowerShell and run::\n\n      C:\\WINDOWS\\system32> wsl -l -v\n      NAME    STATE   VERSION\n      *Ubuntu Running 2\n\n   Note that WSL 2 supports running as many different Linux distributions\n   as you want to install.\n\n#. *Optionally Get Familiar with WSL:* You can learn more on\n   https://docs.microsoft.com/en-us/windows/wsl/wsl2-about.\n\n#. *Launch your WSL Distibution:* From the Windows start menu simply\n   launch your WSL distribution just like any other application.\n\n#. *Optimize your WSL 2 storage often:* Due to the way storage is\n   handled on WSL 2, the storage space used by the underlying Linux\n   distribution is not reflected immediately, and since BitBake heavily\n   uses storage, after several builds, you may be unaware you are\n   running out of space. As WSL 2 uses a VHDX file for storage, this issue\n   can be easily avoided by regularly optimizing this file in a manual way:\n\n   1. *Find the location of your VHDX file:*\n\n      First you need to find the distro app package directory, to achieve this\n"}
{"text": "\n\n\nSetting Up to Use the Yocto Project\n      open a Windows Powershell as Administrator and run::\n\n         C:\\WINDOWS\\system32> Get-AppxPackage -Name \"*Ubuntu*\" | Select PackageFamilyName\n         PackageFamilyName\n         -----------------\n         CanonicalGroupLimited.UbuntuonWindows_79abcdefgh\n\n\n      You should now\n      replace the PackageFamilyName and your user on the following path\n      to find your VHDX file::\n\n         ls C:\\Users\\myuser\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79abcdefgh\\LocalState\\\n         Mode                 LastWriteTime         Length Name\n         -a----         3/14/2020   9:52 PM    57418973184 ext4.vhdx\n\n      Your VHDX file path is:\n      ``C:\\Users\\myuser\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79abcdefgh\\LocalState\\ext4.vhdx``\n\n   2a. *Optimize your VHDX file using Windows Powershell:*\n\n       To use the ``optimize-vhd`` cmdlet below, first install the Hyper-V\n       option on Windows. Then, open a Windows Powershell as Administrator to\n       optimize your VHDX file, shutting down WSL first::\n\n         C:\\WINDOWS\\system32> wsl --shutdown\n         C:\\WINDOWS\\system32> optimize-vhd -Path C:\\Users\\myuser\\AppData\\Local\\Packages\\CanonicalGroupLimited.UbuntuonWindows_79abcdefgh\\LocalState\\ext4.vhdx -Mode full\n\n       A progress bar should be shown while optimizing the\n       VHDX file, and storage should now be reflected correctly on the\n       Windows Explorer.\n\n   2b. *Optimize your VHDX file using DiskPart:*\n\n       The ``optimize-vhd`` cmdlet noted in step 2a above is provided by\n       Hyper-V. Not all SKUs of Windows can install Hyper-V. As an alternative,\n       use the DiskPart tool. To start, open a Windows command prompt as\n       Administrator to optimize your VHDX file, shutting down WSL first::\n\n         C:\\WINDOWS\\system32> wsl --shutdown\n         C:\\WINDOWS\\system32> diskpart\n\n         DISKPART> select vdisk file=\"<path_to_VHDX_file>\"\n         DISKPART> attach vdisk readonly\n         DISKPART> compact vdisk\n         DISKPART> exit\n\n.. note::\n\n   The current implementation of WSL 2 does not have out-of-the-box\n   access to external devices such as those connected through a USB\n   port, but it automatically mounts your ``C:`` drive on ``/mnt/c/``\n   (and others), which you can use to share deploy artifacts to be later\n   flashed on hardware through Windows, but your :term:`Build Directory`\n   should not reside inside this mountpoint.\n\nOnce you have WSL 2 set up, everything is in place to develop just as if\nyou were running on a native Linux machine. If you are going to use the\nExtensible SDK container, see the \":doc:`/sdk-manual/extensible`\" Chapter in the Yocto\nProject Application Development and the Extensible Software Development\nKit (eSDK) manual. If you are going to use the Toaster container, see\nthe \":doc:`/toaster-manual/setup-and-use`\"\nsection in the Toaster User Manual. If you are a VSCode user, you can configure\nthe `Yocto Project BitBake\n<https://marketplace.visualstudio.com/items?itemName=yocto-project.yocto-bitbake>`__\nextension accordingly.\n\nLocating Yocto Project Source Files\n===================================\n\nThis section shows you how to locate, fetch and configure the source\nfiles you'll need to work with the Yocto Project.\n\n.. note::\n\n   -  For concepts and introductory information about Git as it is used\n      in the Yocto Project, see the \":ref:`overview-manual/development-environment:git`\"\n      section in the Yocto Project Overview and Concepts Manual.\n\n   -  For concepts on Yocto Project source repositories, see the\n      \":ref:`overview-manual/development-environment:yocto project source repositories`\"\n      section in the Yocto Project Overview and Concepts Manual.\"\n\nAccessing Source Repositories\n-----------------------------\n\nWorking from a copy of the upstream :ref:`dev-manual/start:accessing source repositories` is the\npreferred method for obtaining and using a Yocto Project release. You\ncan view the Yocto Project Source Repositories at\n:yocto_git:`/`. In particular, you can find the ``poky``\nrepository at :yocto_git:`/poky`.\n\nUse the following procedure to locate the latest upstream copy of the\n``poky`` Git repository:\n\n#. *Access Repositories:* Open a browser and go to\n   :yocto_git:`/` to access the GUI-based interface into the\n   Yocto Project source repositories.\n\n#. *Select the Repository:* Click on the repository in which you are\n"}
{"text": "\n\n\nSetting Up to Use the Yocto Project\n   interested (e.g. ``poky``).\n\n#. *Find the URL Used to Clone the Repository:* At the bottom of the\n   page, note the URL used to clone that repository\n   (e.g. :yocto_git:`/poky`).\n\n   .. note::\n\n      For information on cloning a repository, see the\n      \":ref:`dev-manual/start:cloning the \\`\\`poky\\`\\` repository`\" section.\n\nAccessing Source Archives\n-------------------------\n\nThe Yocto Project also provides source archives of its releases, which\nare available on :yocto_dl:`/releases/yocto/`. Then, choose the subdirectory\ncontaining the release you wish to use, for example\n:yocto_dl:`yocto-&DISTRO; </releases/yocto/yocto-&DISTRO;/>`.\n\nYou will find there source archives of individual components (if you wish\nto use them individually), and of the corresponding Poky release bundling\na selection of these components. \n\n.. note::\n\n   The recommended method for accessing Yocto Project components is to\n   use Git to clone the upstream repository and work from within that\n   locally cloned repository.\n\nUsing the Downloads Page\n------------------------\n\nThe :yocto_home:`Yocto Project Website <>` uses a \"RELEASES\" page\nfrom which you can locate and download tarballs of any Yocto Project\nrelease. Rather than Git repositories, these files represent snapshot\ntarballs similar to the tarballs located in the Index of Releases\ndescribed in the \":ref:`dev-manual/start:accessing source archives`\" section.\n\n#. *Go to the Yocto Project Website:* Open The\n   :yocto_home:`Yocto Project Website <>` in your browser.\n\n#. *Get to the Downloads Area:* Select the \"RELEASES\" item from the\n   pull-down \"DEVELOPMENT\" tab menu near the top of the page.\n\n#. *Select a Yocto Project Release:* On the top of the \"RELEASE\" page currently\n   supported releases are displayed, further down past supported Yocto Project\n   releases are visible. The \"Download\" links in the rows of the table there\n   will lead to the download tarballs for the release.\n   (e.g. &DISTRO_NAME_NO_CAP;, &DISTRO_NAME_NO_CAP_MINUS_ONE;, and so forth).\n\n   .. note::\n\n      For a \"map\" of Yocto Project releases to version numbers, see the\n      :yocto_wiki:`Releases </Releases>` wiki page.\n\n   You can use the \"RELEASE ARCHIVE\" link to reveal a menu of all Yocto\n   Project releases.\n\n#. *Download Tools or Board Support Packages (BSPs):* Next to the tarballs you\n   will find download tools or BSPs as well. Just select a Yocto Project\n   release and look for what you need.\n\nCloning and Checking Out Branches\n=================================\n\nTo use the Yocto Project for development, you need a release locally\ninstalled on your development system. This locally installed set of\nfiles is referred to as the :term:`Source Directory`\nin the Yocto Project documentation.\n\nThe preferred method of creating your Source Directory is by using\n:ref:`overview-manual/development-environment:git` to clone a local copy of the upstream\n``poky`` repository. Working from a cloned copy of the upstream\nrepository allows you to contribute back into the Yocto Project or to\nsimply work with the latest software on a development branch. Because\nGit maintains and creates an upstream repository with a complete history\nof changes and you are working with a local clone of that repository,\nyou have access to all the Yocto Project development branches and tag\nnames used in the upstream repository.\n\nCloning the ``poky`` Repository\n-------------------------------\n\nFollow these steps to create a local version of the upstream\n:term:`Poky` Git repository.\n\n#. *Set Your Directory:* Change your working directory to where you want\n   to create your local copy of ``poky``.\n\n#. *Clone the Repository:* The following example command clones the\n   ``poky`` repository and uses the default name \"poky\" for your local\n   repository::\n\n      $ git clone git://git.yoctoproject.org/poky\n      Cloning into 'poky'...\n      remote: Counting objects: 432160, done.\n      remote: Compressing objects: 100% (102056/102056), done.\n      remote: Total 432160 (delta 323116), reused 432037 (delta 323000)\n      Receiving objects: 100% (432160/432160), 153.81 MiB | 8.54 MiB/s, done.\n      Resolving deltas: 100% (323116/323116), done.\n"}
{"text": "\n\n\nSetting Up to Use the Yocto Project\n      Checking connectivity... done.\n\n   Unless you\n   specify a specific development branch or tag name, Git clones the\n   \"master\" branch, which results in a snapshot of the latest\n   development changes for \"master\". For information on how to check out\n   a specific development branch or on how to check out a local branch\n   based on a tag name, see the\n   \":ref:`dev-manual/start:checking out by branch in poky`\" and\n   \":ref:`dev-manual/start:checking out by tag in poky`\" sections, respectively.\n\n   Once the local repository is created, you can change to that\n   directory and check its status. The ``master`` branch is checked out\n   by default::\n\n      $ cd poky\n      $ git status\n      On branch master\n      Your branch is up-to-date with 'origin/master'.\n      nothing to commit, working directory clean\n      $ git branch\n      * master\n\n   Your local repository of poky is identical to the\n   upstream poky repository at the time from which it was cloned. As you\n   work with the local branch, you can periodically use the\n   ``git pull --rebase`` command to be sure you are up-to-date\n   with the upstream branch.\n\nChecking Out by Branch in Poky\n------------------------------\n\nWhen you clone the upstream poky repository, you have access to all its\ndevelopment branches. Each development branch in a repository is unique\nas it forks off the \"master\" branch. To see and use the files of a\nparticular development branch locally, you need to know the branch name\nand then specifically check out that development branch.\n\n.. note::\n\n   Checking out an active development branch by branch name gives you a\n   snapshot of that particular branch at the time you check it out.\n   Further development on top of the branch that occurs after check it\n   out can occur.\n\n#. *Switch to the Poky Directory:* If you have a local poky Git\n   repository, switch to that directory. If you do not have the local\n   copy of poky, see the\n   \":ref:`dev-manual/start:cloning the \\`\\`poky\\`\\` repository`\"\n   section.\n\n#. *Determine Existing Branch Names:*\n   ::\n\n      $ git branch -a\n      * master\n      remotes/origin/1.1_M1\n      remotes/origin/1.1_M2\n      remotes/origin/1.1_M3\n      remotes/origin/1.1_M4\n      remotes/origin/1.2_M1\n      remotes/origin/1.2_M2\n      remotes/origin/1.2_M3\n      . . .\n      remotes/origin/thud\n      remotes/origin/thud-next\n      remotes/origin/warrior\n      remotes/origin/warrior-next\n      remotes/origin/zeus\n      remotes/origin/zeus-next\n      ... and so on ...\n\n#. *Check out the Branch:* Check out the development branch in which you\n   want to work. For example, to access the files for the Yocto Project\n   &DISTRO; Release (&DISTRO_NAME;), use the following command::\n\n      $ git checkout -b &DISTRO_NAME_NO_CAP; origin/&DISTRO_NAME_NO_CAP;\n      Branch &DISTRO_NAME_NO_CAP; set up to track remote branch &DISTRO_NAME_NO_CAP; from origin.\n      Switched to a new branch '&DISTRO_NAME_NO_CAP;'\n\n   The previous command checks out the \"&DISTRO_NAME_NO_CAP;\" development\n   branch and reports that the branch is tracking the upstream\n   \"origin/&DISTRO_NAME_NO_CAP;\" branch.\n\n   The following command displays the branches that are now part of your\n   local poky repository. The asterisk character indicates the branch\n   that is currently checked out for work::\n\n      $ git branch\n        master\n        * &DISTRO_NAME_NO_CAP;\n\nChecking Out by Tag in Poky\n---------------------------\n\nSimilar to branches, the upstream repository uses tags to mark specific\ncommits associated with significant points in a development branch (i.e.\na release point or stage of a release). You might want to set up a local\nbranch based on one of those points in the repository. The process is\nsimilar to checking out by branch name except you use tag names.\n"}
{"text": "\n\n\n\nSetting Up to Use the Yocto Project\n.. note::\n\n   Checking out a branch based on a tag gives you a stable set of files\n   not affected by development on the branch above the tag.\n\n#. *Switch to the Poky Directory:* If you have a local poky Git\n   repository, switch to that directory. If you do not have the local\n   copy of poky, see the\n   \":ref:`dev-manual/start:cloning the \\`\\`poky\\`\\` repository`\"\n   section.\n\n#. *Fetch the Tag Names:* To checkout the branch based on a tag name,\n   you need to fetch the upstream tags into your local repository::\n\n      $ git fetch --tags\n      $\n\n#. *List the Tag Names:* You can list the tag names now::\n\n      $ git tag\n      1.1_M1.final\n      1.1_M1.rc1\n      1.1_M1.rc2\n      1.1_M2.final\n      1.1_M2.rc1\n         .\n         .\n         .\n      yocto-2.5\n      yocto-2.5.1\n      yocto-2.5.2\n      yocto-2.5.3\n      yocto-2.6\n      yocto-2.6.1\n      yocto-2.6.2\n      yocto-2.7\n      yocto_1.5_M5.rc8\n\n\n#. *Check out the Branch:*\n   ::\n\n      $ git checkout tags/yocto-&DISTRO; -b my_yocto_&DISTRO;\n      Switched to a new branch 'my_yocto_&DISTRO;'\n      $ git branch\n        master\n      * my_yocto_&DISTRO;\n\n   The previous command creates and\n   checks out a local branch named \"my_yocto_&DISTRO;\", which is based on\n   the commit in the upstream poky repository that has the same tag. In\n   this example, the files you have available locally as a result of the\n   ``checkout`` command are a snapshot of the \"&DISTRO_NAME_NO_CAP;\"\n   development branch at the point where Yocto Project &DISTRO; was\n   released.\n"}
{"text": "\n\n\nSetting Up to Use the Yocto Project\n.. _device-manager:\n\nSelecting a Device Manager\n\n\n.. _device-manager:\n\nSelecting a Device Manager\n**************************\n\nThe Yocto Project provides multiple ways to manage the device manager\n(``/dev``):\n\n-  Persistent and Pre-Populated ``/dev``: For this case, the ``/dev``\n   directory is persistent and the required device nodes are created\n   during the build.\n\n-  Use ``devtmpfs`` with a Device Manager: For this case, the ``/dev``\n   directory is provided by the kernel as an in-memory file system and\n   is automatically populated by the kernel at runtime. Additional\n   configuration of device nodes is done in user space by a device\n   manager like ``udev`` or ``busybox-mdev``.\n\nUsing Persistent and Pre-Populated ``/dev``\n===========================================\n\nTo use the static method for device population, you need to set the\n:term:`USE_DEVFS` variable to \"0\"\nas follows::\n\n   USE_DEVFS = \"0\"\n\nThe content of the resulting ``/dev`` directory is defined in a Device\nTable file. The\n:term:`IMAGE_DEVICE_TABLES`\nvariable defines the Device Table to use and should be set in the\nmachine or distro configuration file. Alternatively, you can set this\nvariable in your ``local.conf`` configuration file.\n\nIf you do not define the :term:`IMAGE_DEVICE_TABLES` variable, the default\n``device_table-minimal.txt`` is used::\n\n   IMAGE_DEVICE_TABLES = \"device_table-mymachine.txt\"\n\nThe population is handled by the ``makedevs`` utility during image\ncreation:\n\nUsing ``devtmpfs`` and a Device Manager\n=======================================\n\nTo use the dynamic method for device population, you need to use (or be\nsure to set) the :term:`USE_DEVFS`\nvariable to \"1\", which is the default::\n\n   USE_DEVFS = \"1\"\n\nWith this\nsetting, the resulting ``/dev`` directory is populated by the kernel\nusing ``devtmpfs``. Make sure the corresponding kernel configuration\nvariable ``CONFIG_DEVTMPFS`` is set when building you build a Linux\nkernel.\n\nAll devices created by ``devtmpfs`` will be owned by ``root`` and have\npermissions ``0600``.\n\nTo have more control over the device nodes, you can use a device manager\nlike ``udev`` or ``busybox-mdev``. You choose the device manager by\ndefining the ``VIRTUAL-RUNTIME_dev_manager`` variable in your machine or\ndistro configuration file. Alternatively, you can set this variable in\nyour ``local.conf`` configuration file::\n\n   VIRTUAL-RUNTIME_dev_manager = \"udev\"\n\n   # Some alternative values\n   # VIRTUAL-RUNTIME_dev_manager = \"busybox-mdev\"\n   # VIRTUAL-RUNTIME_dev_manager = \"systemd\"\n\n"}
{"text": "\n\nDealing with Vulnerability Reports\n\n\nDealing with Vulnerability Reports\n**********************************\n\nThe Yocto Project and OpenEmbedded are open-source, community-based projects\nused in numerous products. They assemble multiple other open-source projects,\nand need to handle security issues and practices both internal (in the code\nmaintained by both projects), and external (maintained by other projects and\norganizations).\n\nThis manual assembles security-related information concerning the whole\necosystem. It includes information on reporting a potential security issue,\nthe operation of the YP Security team and how to contribute in the\nrelated code. It is written to be useful for both security researchers and\nYP developers.\n\nHow to report a potential security vulnerability?\n=================================================\n\nIf you would like to report a public issue (for example, one with a released\nCVE number), please report it using the\n:yocto_bugs:`Security Bugzilla </enter_bug.cgi?product=Security>`.\n\nIf you are dealing with a not-yet-released issue, or an urgent one, please send\na message to security AT yoctoproject DOT org, including as many details as\npossible: the layer or software module affected, the recipe and its version,\nand any example code, if available. This mailing list is monitored by the\nYocto Project Security team.\n\nFor each layer, you might also look for specific instructions (if any) for\nreporting potential security issues in the specific ``SECURITY.md`` file at the\nroot of the repository. Instructions on how and where submit a patch are\nusually available in ``README.md``. If this is your first patch to the\nYocto Project/OpenEmbedded, you might want to have a look into the\nContributor's Manual section\n\":ref:`contributor-guide/submit-changes:preparing changes for submission`\".\n\nBranches maintained with security fixes\n---------------------------------------\n\nSee the\n:ref:`Release process <ref-manual/release-process:Stable Release Process>`\ndocumentation for details regarding the policies and maintenance of stable\nbranches.\n\nThe :yocto_wiki:`Releases page </Releases>` contains a list\nof all releases of the Yocto Project. Versions in gray are no longer actively\nmaintained with security patches, but well-tested patches may still be accepted\nfor them for significant issues.\n\nSecurity-related discussions at the Yocto Project\n-------------------------------------------------\n\nWe have set up two security-related mailing lists:\n\n  -  Public List: yocto [dash] security [at] yoctoproject[dot] org\n\n    This is a public mailing list for anyone to subscribe to. This list is an\n    open list to discuss public security issues/patches and security-related\n    initiatives. For more information, including subscription information,\n    please see the  :yocto_lists:`yocto-security mailing list info page </g/yocto-security>`.\n\n  - Private List: security [at] yoctoproject [dot] org\n\n    This is a private mailing list for reporting non-published potential\n    vulnerabilities. The list is monitored by the Yocto Project Security team.\n\n\nWhat you should do if you find a security vulnerability\n-------------------------------------------------------\n\nIf you find a security flaw: a crash, an information leakage, or anything that\ncan have a security impact if exploited in any Open Source software built or\nused by the Yocto Project, please report this to the Yocto Project Security\nTeam. If you prefer to contact the upstream project directly, please send a\ncopy to the security team at the Yocto Project as well. If you believe this is\nhighly sensitive information, please report the vulnerability in a secure way,\ni.e. encrypt the email and send it to the private list. This ensures that\nthe exploit is not leaked and exploited before a response/fix has been generated.\n\nSecurity team\n=============\n\nThe Yocto Project/OpenEmbedded security team coordinates the work on security\nsubjects in the project. All general discussion takes place publicly. The\nSecurity Team only uses confidential communication tools to deal with private\nvulnerability reports before they are released.\n\nSecurity team appointment\n-------------------------\n\nThe Yocto Project Security Team consists of at least three members. When new\nmembers are needed, the Yocto Project Technical Steering Committee (YP TSC)\nasks for nominations by public channels including a nomination deadline.\nSelf-nominations are possible. When the limit time is\nreached, the YP TSC posts the list of candidates for the comments of project\nparticipants and developers. Comments may be sent publicly or privately to the\nYP and OE TSCs. The candidates are approved by both YP TSC and OpenEmbedded\nTechnical Steering Committee (OE TSC) and the final list of the team members\n"}
{"text": "\n\nDealing with Vulnerability Reports\nis announced publicly. The aim is to have people representing technical\nleadership, security knowledge and infrastructure present with enough people\nto provide backup/coverage but keep the notification list small enough to\nminimize information risk and maintain trust.\n\nYP Security Team members may resign at any time.\n\nSecurity Team Operations\n------------------------\n\nThe work of the Security Team might require high confidentiality. Team members\nare individuals selected by merit and do not represent the companies they work\nfor. They do not share information about confidential issues outside of the team\nand do not hint about ongoing embargoes.\n\nTeam members can bring in domain experts as needed. Those people should be\nadded to individual issues only and adhere to the same standards as the YP\nSecurity Team.\n\nThe YP security team organizes its meetings and communication as needed.\n\nWhen the YP Security team receives a report about a potential security\nvulnerability, they quickly analyze and notify the reporter of the result.\nThey might also request more information.\n\nIf the issue is confirmed and affects the code maintained by the YP, they\nconfidentially notify maintainers of that code and work with them to prepare\na fix.\n\nIf the issue is confirmed and affects an upstream project, the YP security team\nnotifies the project. Usually, the upstream project analyzes the problem again.\nIf they deem it a real security problem in their software, they develop and\nrelease a fix following their security policy. They may want to include the\noriginal reporter in the loop. There is also sometimes some coordination for\nhandling patches, backporting patches etc, or just understanding the problem\nor what caused it.\n\nWhen the fix is publicly available, the YP security team member or the\npackage maintainer sends patches against the YP code base, following usual\nprocedures, including public code review.\n\nWhat Yocto Security Team does when it receives a security vulnerability\n-----------------------------------------------------------------------\n\nThe YP Security Team team performs a quick analysis and would usually report\nthe flaw to the upstream project. Normally the upstream project analyzes the\nproblem. If they deem it a real security problem in their software, they\ndevelop and release a fix following their own security policy. They may want\nto include the original reporter in the loop. There is also sometimes some\ncoordination for handling patches, backporting patches etc, or just\nunderstanding the problem or what caused it.\n\nThe security policy of the upstream project might include a notification to\nLinux distributions or other important downstream projects in advance to\ndiscuss coordinated disclosure. These mailing lists are normally non-public.\n\nWhen the upstream project releases a version with the fix, they are responsible\nfor contacting `Mitre <https://www.cve.org/>`__ to get a CVE number assigned and\nthe CVE record published.\n\nIf an upstream project does not respond quickly\n-----------------------------------------------\n\nIf an upstream project does not fix the problem in a reasonable time,\nthe Yocto's Security Team will contact other interested parties (usually\nother distributions) in the community and together try to solve the\nvulnerability as quickly as possible.\n\nThe Yocto Project Security team adheres to the 90 days disclosure policy\nby default. An increase of the embargo time is possible when necessary.\n\nCurrent Security Team members\n-----------------------------\n\nFor secure communications, please send your messages encrypted using the GPG\nkeys. Remember, message headers are not encrypted so do not include sensitive\ninformation in the subject line.\n\n  -  Ross Burton: <ross@burtonini.com> `Public key <https://keys.openpgp.org/search?q=ross%40burtonini.com>`__\n\n  -  Michael Halstead: <mhalstead [at] linuxfoundation [dot] org>\n     `Public key <https://pgp.mit.edu/pks/lookup?op=vindex&search=0x3373170601861969>`__\n     or `Public key <https://keyserver.ubuntu.com/pks/lookup?op=get&search=0xd1f2407285e571ed12a407a73373170601861969>`__\n\n  -  Richard Purdie: <richard.purdie@linuxfoundation.org> `Public key <https://keys.openpgp.org/search?q=richard.purdie%40linuxfoundation.org>`__\n\n  -  Marta Rybczynska: <marta DOT rybczynska [at] syslinbit [dot] com> `Public key <https://keys.openpgp.org/search?q=marta.rybczynska@syslinbit.com>`__\n\n  -  Steve Sakoman: <steve [at] sakoman [dot] com> `Public key <https://keys.openpgp.org/search?q=steve%40sakoman.com>`__\n"}
{"text": "\n\nOptionally Using an External Toolchain\n\n\nOptionally Using an External Toolchain\n**************************************\n\nYou might want to use an external toolchain as part of your development.\nIf this is the case, the fundamental steps you need to accomplish are as\nfollows:\n\n-  Understand where the installed toolchain resides. For cases where you\n   need to build the external toolchain, you would need to take separate\n   steps to build and install the toolchain.\n\n-  Make sure you add the layer that contains the toolchain to your\n   ``bblayers.conf`` file through the\n   :term:`BBLAYERS` variable.\n\n-  Set the :term:`EXTERNAL_TOOLCHAIN` variable in your ``local.conf`` file\n   to the location in which you installed the toolchain.\n\nThe toolchain configuration is very flexible and customizable. It\nis primarily controlled with the :term:`TCMODE` variable. This variable\ncontrols which ``tcmode-*.inc`` file to include from the\n``meta/conf/distro/include`` directory within the :term:`Source Directory`.\n\nThe default value of :term:`TCMODE` is \"default\", which tells the\nOpenEmbedded build system to use its internally built toolchain (i.e.\n``tcmode-default.inc``). However, other patterns are accepted. In\nparticular, \"external-\\*\" refers to external toolchains. One example is\nthe Mentor Graphics Sourcery G++ Toolchain. Support for this toolchain resides\nin the separate ``meta-sourcery`` layer at\nhttps://github.com/MentorEmbedded/meta-sourcery/.\nSee its ``README`` file for details about how to use this layer.\n\nAnother example of external toolchain layer is\n:yocto_git:`meta-arm-toolchain </meta-arm/tree/meta-arm-toolchain/>`\nsupporting GNU toolchains released by ARM.\n\nYou can find further information by reading about the :term:`TCMODE` variable\nin the Yocto Project Reference Manual's variable glossary.\n"}
